{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\tejit\\\\OneDrive\\\\Desktop\\\\expence tracker final\\\\expence-tracker\\\\src\\\\context\\\\ExpenseContext.js\",\n  _s = $RefreshSig$();\n// src/context/ExpenseContext.js\nimport React, { createContext, useState, useEffect, useContext } from 'react';\nimport { AuthContext } from './AuthContext';\nimport { sendBudgetAlertEmail } from '../services/EmailService';\nimport { scanReceiptImage, parseReceiptData } from '../services/ReceiptScanningService';\n// Add Firebase imports\nimport { db, storage } from '../config/firebase';\nimport { collection, addDoc, doc, deleteDoc, updateDoc, query, where, getDocs, onSnapshot, getDoc, setDoc, limit } from 'firebase/firestore';\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ExpenseContext = /*#__PURE__*/createContext();\nexport const ExpenseProvider = ({\n  children\n}) => {\n  _s();\n  const [expenses, setExpenses] = useState([]);\n  const [incomes, setIncomes] = useState([]);\n  const [budgets, setBudgets] = useState({});\n  const [alerts, setAlerts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [emailStatus, setEmailStatus] = useState({\n    sent: false,\n    error: null\n  });\n  const [expenseCategories, setExpenseCategories] = useState([]);\n  const [incomeCategories, setIncomeCategories] = useState([]);\n  // Add new state for receipt scanning\n  const [receiptScanStatus, setReceiptScanStatus] = useState({\n    scanning: false,\n    error: null,\n    data: null\n  });\n  // Track receipt scan history\n  const [receiptScans, setReceiptScans] = useState([]);\n  const {\n    currentUser\n  } = useContext(AuthContext);\n\n  // Default categories if none are found\n  const DEFAULT_EXPENSE_CATEGORIES = ['Food', 'Housing', 'Transportation', 'Entertainment', 'Utilities', 'Healthcare', 'Shopping', 'Personal Care', 'Education', 'Other'];\n  const DEFAULT_INCOME_CATEGORIES = ['Salary', 'Freelance', 'Investment', 'Gift', 'Business', 'Side Hustle', 'Rental', 'Other'];\n\n  // Load expenses from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setExpenses([]);\n      setLoading(false);\n      return;\n    }\n    setLoading(true);\n\n    // Query Firestore for expenses\n    const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(expensesQuery, snapshot => {\n      const expensesList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setExpenses(expensesList);\n      setLoading(false);\n    }, error => {\n      console.error(\"Error getting expenses:\", error);\n      setLoading(false);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Load incomes from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setIncomes([]);\n      return;\n    }\n\n    // Query Firestore for incomes\n    const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(incomesQuery, snapshot => {\n      const incomesList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setIncomes(incomesList);\n    }, error => {\n      console.error(\"Error getting incomes:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Clear email status after some time\n  useEffect(() => {\n    if (emailStatus.sent || emailStatus.error) {\n      const timer = setTimeout(() => {\n        setEmailStatus({\n          sent: false,\n          error: null\n        });\n      }, 5000);\n      return () => clearTimeout(timer);\n    }\n  }, [emailStatus]);\n\n  // Clear receipt scan data after processing\n  useEffect(() => {\n    if (receiptScanStatus.data && !receiptScanStatus.scanning) {\n      const timer = setTimeout(() => {\n        setReceiptScanStatus(prevState => ({\n          ...prevState,\n          data: null\n        }));\n      }, 30000); // Give user 30 seconds to review before clearing\n\n      return () => clearTimeout(timer);\n    }\n  }, [receiptScanStatus]);\n\n  // Add a new expense with validation\n  const addExpense = async expense => {\n    if (!currentUser) return false;\n    try {\n      // Validate expense data\n      if (!expense.category) {\n        console.error('Missing category in expense');\n        return false;\n      }\n      const amount = parseFloat(expense.amount);\n      if (isNaN(amount) || amount <= 0) {\n        console.error('Invalid expense amount:', expense.amount);\n        return false;\n      }\n\n      // Handle receipt image if present\n      let receiptImageUrl = expense.receiptImageUrl || null;\n      if (expense.receiptImage instanceof File) {\n        const storageRef = ref(storage, `receipts/${currentUser.uid}/${Date.now()}_${expense.receiptImage.name}`);\n        await uploadBytes(storageRef, expense.receiptImage);\n        receiptImageUrl = await getDownloadURL(storageRef);\n      }\n\n      // Create new expense object\n      const newExpense = {\n        ...expense,\n        amount,\n        date: expense.date || new Date().toISOString().slice(0, 10),\n        userId: currentUser.uid,\n        createdAt: new Date().toISOString(),\n        fromReceipt: expense.fromReceipt || false,\n        receiptImageUrl,\n        receiptScanId: expense.receiptScanId || null\n      };\n\n      // Delete any properties we don't want to store\n      delete newExpense.receiptImage;\n\n      // Add to Firestore\n      const docRef = await addDoc(collection(db, 'expenses'), newExpense);\n\n      // Check for budget alerts\n      await checkBudgetAlerts({\n        ...newExpense,\n        id: docRef.id\n      });\n      return docRef.id;\n    } catch (error) {\n      console.error('Error adding expense:', error);\n      return false;\n    }\n  };\n\n  // New function to handle receipt scanning\n  const scanReceipt = async imageFile => {\n    if (!currentUser) return {\n      success: false,\n      error: 'User not logged in'\n    };\n    if (!imageFile) {\n      setReceiptScanStatus({\n        scanning: false,\n        error: 'No image provided',\n        data: null\n      });\n      return {\n        success: false,\n        error: 'No image provided'\n      };\n    }\n    try {\n      var _parsedData$items;\n      // Set scanning status\n      setReceiptScanStatus({\n        scanning: true,\n        error: null,\n        data: null\n      });\n\n      // Call the receipt scanning service\n      const scanResult = await scanReceiptImage(imageFile);\n      if (!scanResult || !scanResult.success) {\n        const errorMessage = (scanResult === null || scanResult === void 0 ? void 0 : scanResult.error) || 'Failed to scan receipt';\n        setReceiptScanStatus({\n          scanning: false,\n          error: errorMessage,\n          data: null\n        });\n        return {\n          success: false,\n          error: errorMessage\n        };\n      }\n\n      // Process the scanned data\n      const parsedData = parseReceiptData(scanResult);\n      if (!parsedData) {\n        setReceiptScanStatus({\n          scanning: false,\n          error: 'Failed to parse receipt data',\n          data: null\n        });\n        return {\n          success: false,\n          error: 'Failed to parse receipt data'\n        };\n      }\n\n      // Create a scan record\n      const scanId = Date.now();\n      const scanRecord = {\n        id: scanId,\n        date: new Date().toISOString(),\n        rawData: scanResult,\n        parsedData: parsedData,\n        userId: currentUser.uid,\n        status: 'pending',\n        // pending, applied, rejected\n        imageUrl: scanResult.imageUrl\n      };\n\n      // Store the scan record in Firestore\n      await addDoc(collection(db, 'receiptScans'), scanRecord);\n\n      // Prepare the extracted data for the UI\n      const extractedExpense = {\n        amount: parsedData.amount,\n        description: parsedData.merchantName || 'Receipt expense',\n        category: mapVendorToCategory(parsedData.merchantName || ''),\n        date: parsedData.date || new Date().toISOString().slice(0, 10),\n        fromReceipt: true,\n        receiptImageUrl: parsedData.imageUrl || null,\n        receiptScanId: scanId,\n        notes: `Receipt from ${parsedData.merchantName || 'unknown vendor'}${((_parsedData$items = parsedData.items) === null || _parsedData$items === void 0 ? void 0 : _parsedData$items.length) > 0 ? `, Items: ${parsedData.items.join(', ')}` : ''}`\n      };\n\n      // Update scan status with the extracted data\n      setReceiptScanStatus({\n        scanning: false,\n        error: null,\n        data: extractedExpense\n      });\n      return {\n        success: true,\n        data: extractedExpense,\n        scanId\n      };\n    } catch (error) {\n      console.error('Error scanning receipt:', error);\n      setReceiptScanStatus({\n        scanning: false,\n        error: error.message || 'Error scanning receipt',\n        data: null\n      });\n      return {\n        success: false,\n        error: error.message || 'Error scanning receipt'\n      };\n    }\n  };\n\n  // Function to add the expense from a scanned receipt\n  const addExpenseFromReceipt = async (expenseData, modifications = {}) => {\n    if (!currentUser) return false;\n    try {\n      // Combine scanned data with any user modifications\n      const finalExpenseData = {\n        ...expenseData,\n        ...modifications,\n        fromReceipt: true\n      };\n\n      // Use the existing addExpense function\n      const result = await addExpense(finalExpenseData);\n      if (result && finalExpenseData.receiptScanId) {\n        // Update the scan record status in Firestore\n        const scanRef = doc(db, 'receiptScans', String(finalExpenseData.receiptScanId));\n        await updateDoc(scanRef, {\n          status: 'applied'\n        });\n\n        // Clear the scanned data after successful addition\n        setReceiptScanStatus(prevState => ({\n          ...prevState,\n          data: null\n        }));\n      }\n      return result;\n    } catch (error) {\n      console.error('Error adding expense from receipt:', error);\n      return false;\n    }\n  };\n\n  // Function to reject a scanned receipt\n  const rejectScannedReceipt = async scanId => {\n    if (!scanId) return false;\n    try {\n      var _receiptScanStatus$da;\n      // Update the scan record status in Firestore\n      const scanRef = doc(db, 'receiptScans', String(scanId));\n      await updateDoc(scanRef, {\n        status: 'rejected'\n      });\n\n      // Clear any pending scan data with this ID\n      if (((_receiptScanStatus$da = receiptScanStatus.data) === null || _receiptScanStatus$da === void 0 ? void 0 : _receiptScanStatus$da.receiptScanId) === scanId) {\n        setReceiptScanStatus({\n          scanning: false,\n          error: null,\n          data: null\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error('Error rejecting scanned receipt:', error);\n      return false;\n    }\n  };\n\n  // Helper function to map vendor names to appropriate categories\n  const mapVendorToCategory = vendorName => {\n    const vendorNameLower = vendorName.toLowerCase();\n\n    // Simple mapping logic - can be expanded based on common vendors\n    if (!vendorName) return 'Other';\n    const categoryMappings = {\n      'restaurant': 'Food',\n      'café': 'Food',\n      'cafe': 'Food',\n      'grocery': 'Food',\n      'supermarket': 'Food',\n      'market': 'Food',\n      'gas': 'Transportation',\n      'fuel': 'Transportation',\n      'uber': 'Transportation',\n      'lyft': 'Transportation',\n      'taxi': 'Transportation',\n      'pharmacy': 'Healthcare',\n      'drug': 'Healthcare',\n      'doctor': 'Healthcare',\n      'clinic': 'Healthcare',\n      'hospital': 'Healthcare',\n      'rent': 'Housing',\n      'mortgage': 'Housing',\n      'netflix': 'Entertainment',\n      'spotify': 'Entertainment',\n      'cinema': 'Entertainment',\n      'movie': 'Entertainment',\n      'theater': 'Entertainment',\n      'amazon': 'Shopping',\n      'walmart': 'Shopping',\n      'target': 'Shopping',\n      'utility': 'Utilities',\n      'electric': 'Utilities',\n      'water': 'Utilities',\n      'gas bill': 'Utilities',\n      'phone': 'Utilities',\n      'internet': 'Utilities',\n      'school': 'Education',\n      'college': 'Education',\n      'university': 'Education',\n      'tuition': 'Education',\n      'book': 'Education',\n      'haircut': 'Personal Care',\n      'salon': 'Personal Care',\n      'spa': 'Personal Care',\n      'gym': 'Personal Care'\n    };\n    for (const [keyword, category] of Object.entries(categoryMappings)) {\n      if (vendorNameLower.includes(keyword)) {\n        return category;\n      }\n    }\n    return 'Other';\n  };\n\n  // Add a new income with validation\n  const addIncome = async income => {\n    if (!currentUser) return false;\n    try {\n      // Validate income data\n      if (!income.source) {\n        console.error('Missing source in income');\n        return false;\n      }\n      const amount = parseFloat(income.amount);\n      if (isNaN(amount) || amount <= 0) {\n        console.error('Invalid income amount:', income.amount);\n        return false;\n      }\n\n      // Create new income object\n      const newIncome = {\n        ...income,\n        amount,\n        date: income.date || new Date().toISOString().slice(0, 10),\n        userId: currentUser.uid,\n        createdAt: new Date().toISOString()\n      };\n\n      // Add to Firestore\n      const docRef = await addDoc(collection(db, 'incomes'), newIncome);\n      return docRef.id;\n    } catch (error) {\n      console.error('Error adding income:', error);\n      return false;\n    }\n  };\n\n  // Delete an expense\n  const deleteExpense = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      // Get the expense before deleting it (to check for receipt info)\n      const expenseRef = doc(db, 'expenses', id);\n      const expenseSnap = await getDoc(expenseRef);\n      if (expenseSnap.exists()) {\n        const expenseData = expenseSnap.data();\n\n        // Delete the expense document\n        await deleteDoc(expenseRef);\n\n        // If this was a receipt-based expense, update the scan record\n        if (expenseData.receiptScanId) {\n          const scanRef = doc(db, 'receiptScans', String(expenseData.receiptScanId));\n          const scanSnap = await getDoc(scanRef);\n          if (scanSnap.exists()) {\n            await updateDoc(scanRef, {\n              status: 'rejected'\n            });\n          }\n        }\n      } else {\n        // Document not found\n        console.error('Expense not found');\n        return false;\n      }\n      return true;\n    } catch (error) {\n      console.error('Error deleting expense:', error);\n      return false;\n    }\n  };\n\n  // Delete an income\n  const deleteIncome = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      await deleteDoc(doc(db, 'incomes', id));\n      return true;\n    } catch (error) {\n      console.error('Error deleting income:', error);\n      return false;\n    }\n  };\n\n  // Update budget settings\n  const updateBudget = async (category, amount) => {\n    if (!currentUser || !category || category.trim() === '' || isNaN(parseFloat(amount))) {\n      return false;\n    }\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        // Update existing budgets document\n        await updateDoc(budgetRef, {\n          [category]: parseFloat(amount)\n        });\n      } else {\n        // Create new budgets document\n        await setDoc(budgetRef, {\n          [category]: parseFloat(amount)\n        });\n      }\n\n      // Update local state\n      setBudgets(prevBudgets => ({\n        ...prevBudgets,\n        [category]: parseFloat(amount)\n      }));\n      return true;\n    } catch (error) {\n      console.error('Error updating budget:', error);\n      return false;\n    }\n  };\n\n  // Delete a budget\n  const deleteBudget = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n\n        // Remove the category from the budgets\n        if (currentBudgets[category] !== undefined) {\n          delete currentBudgets[category];\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error deleting budget:', error);\n      return false;\n    }\n  };\n\n  // Check if adding this expense exceeds the budget\n  const checkBudgetAlerts = async (newExpense, allExpenses = expenses) => {\n    if (!currentUser) return; // Don't process if no user is logged in\n    if (!newExpense || !newExpense.category) return;\n    const {\n      category\n    } = newExpense;\n\n    // Get budgets from Firestore\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (!budgetDoc.exists()) return;\n      const budgets = budgetDoc.data();\n\n      // Check if there's a budget for this category\n      if (budgets[category]) {\n        // Get current month expenses for this category\n        const currentDate = new Date();\n        const currentMonth = currentDate.getMonth();\n        const currentYear = currentDate.getFullYear();\n        const monthlyExpenses = allExpenses.filter(expense => {\n          if (!expense.date) return false;\n          try {\n            const expenseDate = new Date(expense.date);\n            return expenseDate.getMonth() === currentMonth && expenseDate.getFullYear() === currentYear && expense.category === category && expense.userId === currentUser.uid;\n          } catch (e) {\n            console.error('Invalid date format:', expense.date);\n            return false;\n          }\n        });\n        const totalSpent = monthlyExpenses.reduce((sum, expense) => {\n          const amount = parseFloat(expense.amount);\n          return sum + (isNaN(amount) ? 0 : amount);\n        }, 0);\n        const budgetAmount = parseFloat(budgets[category]);\n        if (!isNaN(budgetAmount) && totalSpent > budgetAmount) {\n          var _currentUser$preferen;\n          // Create new alert\n          const newAlert = {\n            message: `Budget alert: You've exceeded your ${category} budget of $${budgetAmount.toFixed(2)}`,\n            category: category,\n            read: false,\n            date: new Date().toISOString(),\n            userId: currentUser.uid\n          };\n\n          // Add to Firestore\n          const alertRef = await addDoc(collection(db, 'alerts'), newAlert);\n\n          // Send email alert if user has enabled email notifications\n          if ((currentUser === null || currentUser === void 0 ? void 0 : (_currentUser$preferen = currentUser.preferences) === null || _currentUser$preferen === void 0 ? void 0 : _currentUser$preferen.emailNotifications) !== false) {\n            if (currentUser.email) {\n              sendBudgetAlertEmail(currentUser, category, budgetAmount, totalSpent).then(result => {\n                setEmailStatus({\n                  sent: result.success,\n                  error: result.success ? null : result.message\n                });\n              }).catch(error => {\n                setEmailStatus({\n                  sent: false,\n                  error: error.message || 'Error sending email'\n                });\n              });\n            } else {\n              setEmailStatus({\n                sent: false,\n                error: \"No email address found for user\"\n              });\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error checking budget alerts:', error);\n    }\n  };\n\n  // Mark an alert as read\n  const markAlertAsRead = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      const alertRef = doc(db, 'alerts', id);\n      await updateDoc(alertRef, {\n        read: true\n      });\n      return true;\n    } catch (error) {\n      console.error('Error marking alert as read:', error);\n      return false;\n    }\n  };\n\n  // Delete an alert\n  const deleteAlert = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      await deleteDoc(doc(db, 'alerts', id));\n      return true;\n    } catch (error) {\n      console.error('Error deleting alert:', error);\n      return false;\n    }\n  };\n\n  // Add a new expense category\n  const addExpenseCategory = async category => {\n    if (!currentUser || !category || category.trim() === '') return false;\n    try {\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      let updatedCategories;\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n\n        // Check if category already exists\n        if (currentCategories.includes(category)) {\n          return false;\n        }\n        updatedCategories = [...currentCategories, category];\n      } else {\n        updatedCategories = [...DEFAULT_EXPENSE_CATEGORIES, category];\n      }\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setExpenseCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error adding expense category:', error);\n      return false;\n    }\n  };\n\n  // Delete an expense category\n  const deleteExpenseCategory = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      // Don't delete if there are expenses using this category\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('category', '==', category), limit(1));\n      const expensesSnap = await getDocs(expensesQuery);\n      if (!expensesSnap.empty) {\n        return {\n          success: false,\n          reason: 'Category in use by existing expenses'\n        };\n      }\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\n\n        // Update Firestore\n        await setDoc(categoriesRef, {\n          categories: updatedCategories\n        });\n\n        // Update local state\n        setExpenseCategories(updatedCategories);\n      }\n\n      // Also remove any budgets for this category\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n        if (currentBudgets[category] !== undefined) {\n          delete currentBudgets[category];\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error deleting expense category:', error);\n      return {\n        success: false,\n        reason: error.message\n      };\n    }\n  };\n\n  // Edit an expense category\n  const editExpenseCategory = async (oldCategory, newCategory) => {\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\n    try {\n      // Don't allow editing the \"Other\" category\n      if (oldCategory === 'Other') return false;\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (!categoriesDoc.exists()) return false;\n      const currentCategories = categoriesDoc.data().categories || [];\n\n      // Check if the new category name already exists\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\n\n      // Check if the category is in use\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('category', '==', oldCategory), limit(1));\n      const expensesSnap = await getDocs(expensesQuery);\n      if (!expensesSnap.empty) return false;\n\n      // Update categories\n      const updatedCategories = currentCategories.map(cat => cat === oldCategory ? newCategory : cat);\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setExpenseCategories(updatedCategories);\n\n      // Update any budget for this category\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n        if (currentBudgets[oldCategory] !== undefined) {\n          const budgetAmount = currentBudgets[oldCategory];\n          delete currentBudgets[oldCategory];\n          currentBudgets[newCategory] = budgetAmount;\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error editing expense category:', error);\n      return false;\n    }\n  };\n\n  // Add a new income category\n  const addIncomeCategory = async category => {\n    if (!currentUser || !category || category.trim() === '') return false;\n    try {\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      let updatedCategories;\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n\n        // Check if category already exists\n        if (currentCategories.includes(category)) {\n          return false;\n        }\n        updatedCategories = [...currentCategories, category];\n      } else {\n        updatedCategories = [...DEFAULT_INCOME_CATEGORIES, category];\n      }\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setIncomeCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error adding income category:', error);\n      return false;\n    }\n  };\n\n  // Delete an income category\n  const deleteIncomeCategory = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      // Don't delete if there are incomes using this category\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid), where('source', '==', category), limit(1));\n      const incomesSnap = await getDocs(incomesQuery);\n      if (!incomesSnap.empty) {\n        return {\n          success: false,\n          reason: 'Category in use by existing incomes'\n        };\n      }\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\n\n        // Update Firestore\n        await setDoc(categoriesRef, {\n          categories: updatedCategories\n        });\n\n        // Update local state\n        setIncomeCategories(updatedCategories);\n      }\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error deleting income category:', error);\n      return {\n        success: false,\n        reason: error.message\n      };\n    }\n  };\n\n  // Edit an income category\n  const editIncomeCategory = async (oldCategory, newCategory) => {\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\n    try {\n      // Don't allow editing the \"Other\" category\n      if (oldCategory === 'Other') return false;\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (!categoriesDoc.exists()) return false;\n      const currentCategories = categoriesDoc.data().categories || [];\n\n      // Check if the new category name already exists\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\n\n      // Check if the category is in use\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid), where('source', '==', oldCategory), limit(1));\n      const incomesSnap = await getDocs(incomesQuery);\n      if (!incomesSnap.empty) return false;\n\n      // Update categories\n      const updatedCategories = currentCategories.map(cat => cat === oldCategory ? newCategory : cat);\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setIncomeCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error editing income category:', error);\n      return false;\n    }\n  };\n\n  // Get expenses for a specific month\n  const getMonthlyExpenses = (month, year) => {\n    if (!currentUser) return [];\n    const targetDate = new Date(year, month);\n    const targetMonth = targetDate.getMonth();\n    const targetYear = targetDate.getFullYear();\n    return expenses.filter(expense => {\n      if (!expense.date) return false;\n      try {\n        const expenseDate = new Date(expense.date);\n        return expenseDate.getMonth() === targetMonth && expenseDate.getFullYear() === targetYear && expense.userId === currentUser.uid;\n      } catch (e) {\n        return false;\n      }\n    });\n  };\n\n  // Get incomes for a specific month\n  const getMonthlyIncomes = (month, year) => {\n    if (!currentUser) return [];\n    const targetDate = new Date(year, month);\n    const targetMonth = targetDate.getMonth();\n    const targetYear = targetDate.getFullYear();\n    return incomes.filter(income => {\n      if (!income.date) return false;\n      try {\n        const incomeDate = new Date(income.date);\n        return incomeDate.getMonth() === targetMonth && incomeDate.getFullYear() === targetYear && income.userId === currentUser.uid;\n      } catch (e) {\n        return false;\n      }\n    });\n  };\n\n  // Get historical receipt scans\n  const getReceiptScans = async () => {\n    if (!currentUser) return [];\n    try {\n      const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n      const scansSnap = await getDocs(scansQuery);\n      return scansSnap.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error getting receipt scans:', error);\n      return [];\n    }\n  };\n\n  // Update an existing expense\n  const updateExpense = async (id, updatedData) => {\n    if (!currentUser || !id) return false;\n    try {\n      const expenseRef = doc(db, 'expenses', id);\n      await updateDoc(expenseRef, updatedData);\n      return true;\n    } catch (error) {\n      console.error('Error updating expense:', error);\n      return false;\n    }\n  };\n\n  // Update an existing income\n  const updateIncome = async (id, updatedData) => {\n    if (!currentUser || !id) return false;\n    try {\n      const incomeRef = doc(db, 'incomes', id);\n      await updateDoc(incomeRef, updatedData);\n      return true;\n    } catch (error) {\n      console.error('Error updating income:', error);\n      return false;\n    }\n  };\n\n  // Export data for backups\n  const exportData = async () => {\n    if (!currentUser) return null;\n    try {\n      // Get all current user data\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid));\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid));\n      const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n      const [expensesSnap, incomesSnap, scansSnap, categoriesSnap, budgetsSnap] = await Promise.all([getDocs(expensesQuery), getDocs(incomesQuery), getDocs(scansQuery), getDoc(doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories')), getDoc(doc(db, 'users', currentUser.uid, 'settings', 'budgets'))]);\n      const exportData = {\n        expenses: expensesSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        incomes: incomesSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        receiptScans: scansSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        expenseCategories: categoriesSnap.exists() ? categoriesSnap.data().categories : DEFAULT_EXPENSE_CATEGORIES,\n        incomeCategories: incomeCategories,\n        budgets: budgetsSnap.exists() ? budgetsSnap.data() : {},\n        exportDate: new Date().toISOString(),\n        userId: currentUser.uid\n      };\n      return exportData;\n    } catch (error) {\n      console.error('Error exporting data:', error);\n      return null;\n    }\n  };\n\n  // Import data from backups\n  const importData = async data => {\n    if (!currentUser || !data) return false;\n    try {\n      // Validate data structure\n      if (!data.expenses || !data.incomes || !data.budgets || !data.expenseCategories || !data.incomeCategories) {\n        console.error('Invalid import data structure');\n        return false;\n      }\n\n      // Begin batch operations\n      const batch = db.batch();\n\n      // Update expense categories\n      const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      batch.set(expenseCategoriesRef, {\n        categories: data.expenseCategories\n      });\n\n      // Update income categories\n      const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      batch.set(incomeCategoriesRef, {\n        categories: data.incomeCategories\n      });\n\n      // Update budgets\n      const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      batch.set(budgetsRef, data.budgets);\n\n      // Commit the batch\n      await batch.commit();\n\n      // Update local state\n      setExpenseCategories(data.expenseCategories);\n      setIncomeCategories(data.incomeCategories);\n      setBudgets(data.budgets);\n\n      // Handle expense and income imports separately (may be too many for a single batch)\n      for (const expense of data.expenses) {\n        try {\n          const {\n            id,\n            ...expenseData\n          } = expense;\n          expenseData.userId = currentUser.uid; // Ensure correct user ID\n          await addDoc(collection(db, 'expenses'), expenseData);\n        } catch (e) {\n          console.error('Error importing expense:', e);\n          // Continue with other imports\n        }\n      }\n      for (const income of data.incomes) {\n        try {\n          const {\n            id,\n            ...incomeData\n          } = income;\n          incomeData.userId = currentUser.uid; // Ensure correct user ID\n          await addDoc(collection(db, 'incomes'), incomeData);\n        } catch (e) {\n          console.error('Error importing income:', e);\n          // Continue with other imports\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error importing data:', error);\n      return false;\n    }\n  };\n\n  // Get spending insights\n  const getSpendingInsights = async (months = 3) => {\n    if (!currentUser || months < 1) return null;\n    try {\n      const currentDate = new Date();\n      const insights = {\n        topCategories: [],\n        monthlyTotals: [],\n        yearlyComparison: {},\n        receiptUsage: {\n          total: 0,\n          percentage: 0\n        }\n      };\n\n      // Get relevant expenses from Firestore\n      const startDate = new Date();\n      startDate.setMonth(startDate.getMonth() - months);\n\n      // Format for Firestore query\n      const startDateString = startDate.toISOString();\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('date', '>=', startDateString));\n      const expensesSnap = await getDocs(expensesQuery);\n      const relevantExpenses = expensesSnap.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n\n      // Calculate top spending categories\n      const categoryTotals = {};\n      relevantExpenses.forEach(expense => {\n        const {\n          category,\n          amount\n        } = expense;\n        if (!category) return;\n        categoryTotals[category] = (categoryTotals[category] || 0) + parseFloat(amount || 0);\n      });\n      insights.topCategories = Object.entries(categoryTotals).map(([category, total]) => ({\n        category,\n        total\n      })).sort((a, b) => b.total - a.total).slice(0, 5); // Get top 5\n\n      // Calculate monthly totals\n      const monthlyData = {};\n      relevantExpenses.forEach(expense => {\n        if (!expense.date) return;\n        const expenseDate = new Date(expense.date);\n        const monthYear = `${expenseDate.getFullYear()}-${expenseDate.getMonth() + 1}`;\n        if (!monthlyData[monthYear]) {\n          monthlyData[monthYear] = {\n            month: expenseDate.getMonth(),\n            year: expenseDate.getFullYear(),\n            total: 0,\n            label: expenseDate.toLocaleString('default', {\n              month: 'short',\n              year: 'numeric'\n            })\n          };\n        }\n        monthlyData[monthYear].total += parseFloat(expense.amount || 0);\n      });\n      insights.monthlyTotals = Object.values(monthlyData).sort((a, b) => {\n        if (a.year !== b.year) return a.year - b.year;\n        return a.month - b.month;\n      });\n\n      // Calculate receipt usage statistics\n      const receiptsCount = relevantExpenses.filter(expense => expense.fromReceipt).length;\n      insights.receiptUsage = {\n        total: receiptsCount,\n        percentage: relevantExpenses.length > 0 ? receiptsCount / relevantExpenses.length * 100 : 0\n      };\n      return insights;\n    } catch (error) {\n      console.error('Error generating spending insights:', error);\n      return null;\n    }\n  };\n\n  // Load categories and other settings from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setExpenseCategories([]);\n      setIncomeCategories([]);\n      setBudgets({});\n      return;\n    }\n\n    // Load categories and budgets\n    const fetchSettings = async () => {\n      try {\n        // Get expense categories\n        const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n        const expenseCategoriesDoc = await getDoc(expenseCategoriesRef);\n        if (expenseCategoriesDoc.exists()) {\n          setExpenseCategories(expenseCategoriesDoc.data().categories || DEFAULT_EXPENSE_CATEGORIES);\n        } else {\n          // Create default categories if none exist\n          await setDoc(expenseCategoriesRef, {\n            categories: DEFAULT_EXPENSE_CATEGORIES\n          });\n          setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\n        }\n\n        // Get income categories\n        const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n        const incomeCategoriesDoc = await getDoc(incomeCategoriesRef);\n        if (incomeCategoriesDoc.exists()) {\n          setIncomeCategories(incomeCategoriesDoc.data().categories || DEFAULT_INCOME_CATEGORIES);\n        } else {\n          // Create default categories if none exist\n          await setDoc(incomeCategoriesRef, {\n            categories: DEFAULT_INCOME_CATEGORIES\n          });\n          setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\n        }\n\n        // Get budgets\n        const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n        const budgetsDoc = await getDoc(budgetsRef);\n        if (budgetsDoc.exists()) {\n          setBudgets(budgetsDoc.data());\n        }\n      } catch (error) {\n        console.error('Error loading settings:', error);\n        setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\n        setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\n      }\n    };\n    fetchSettings();\n  }, [currentUser]);\n\n  // Load alerts from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setAlerts([]);\n      return;\n    }\n\n    // Query Firestore for alerts\n    const alertsQuery = query(collection(db, 'alerts'), where('userId', '==', currentUser.uid), where('read', '==', false));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(alertsQuery, snapshot => {\n      const alertsList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setAlerts(alertsList);\n    }, error => {\n      console.error(\"Error getting alerts:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Load receipt scans from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setReceiptScans([]);\n      return;\n    }\n\n    // Query Firestore for receipt scans\n    const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(scansQuery, snapshot => {\n      const scansList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setReceiptScans(scansList);\n    }, error => {\n      console.error(\"Error getting receipt scans:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n  return /*#__PURE__*/_jsxDEV(ExpenseContext.Provider, {\n    value: {\n      expenses,\n      incomes,\n      budgets,\n      alerts,\n      expenseCategories,\n      incomeCategories,\n      receiptScanStatus,\n      receiptScans,\n      emailStatus,\n      loading,\n      addExpense,\n      addIncome,\n      deleteExpense,\n      deleteIncome,\n      updateExpense,\n      updateIncome,\n      updateBudget,\n      deleteBudget,\n      markAlertAsRead,\n      deleteAlert,\n      addExpenseCategory,\n      deleteExpenseCategory,\n      editExpenseCategory,\n      addIncomeCategory,\n      deleteIncomeCategory,\n      editIncomeCategory,\n      scanReceipt,\n      addExpenseFromReceipt,\n      rejectScannedReceipt,\n      getMonthlyExpenses,\n      getMonthlyIncomes,\n      getReceiptScans,\n      exportData,\n      importData,\n      getSpendingInsights\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1385,\n    columnNumber: 5\n  }, this);\n};\n_s(ExpenseProvider, \"jN6mlIMGqoim1aOMvmQUTdySb1Y=\");\n_c = ExpenseProvider;\nvar _c;\n$RefreshReg$(_c, \"ExpenseProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","AuthContext","sendBudgetAlertEmail","scanReceiptImage","parseReceiptData","db","storage","collection","addDoc","doc","deleteDoc","updateDoc","query","where","getDocs","onSnapshot","getDoc","setDoc","limit","ref","uploadBytes","getDownloadURL","jsxDEV","_jsxDEV","ExpenseContext","ExpenseProvider","children","_s","expenses","setExpenses","incomes","setIncomes","budgets","setBudgets","alerts","setAlerts","loading","setLoading","emailStatus","setEmailStatus","sent","error","expenseCategories","setExpenseCategories","incomeCategories","setIncomeCategories","receiptScanStatus","setReceiptScanStatus","scanning","data","receiptScans","setReceiptScans","currentUser","DEFAULT_EXPENSE_CATEGORIES","DEFAULT_INCOME_CATEGORIES","expensesQuery","uid","unsubscribe","snapshot","expensesList","docs","map","id","console","incomesQuery","incomesList","timer","setTimeout","clearTimeout","prevState","addExpense","expense","category","amount","parseFloat","isNaN","receiptImageUrl","receiptImage","File","storageRef","Date","now","name","newExpense","date","toISOString","slice","userId","createdAt","fromReceipt","receiptScanId","docRef","checkBudgetAlerts","scanReceipt","imageFile","success","_parsedData$items","scanResult","errorMessage","parsedData","scanId","scanRecord","rawData","status","imageUrl","extractedExpense","description","merchantName","mapVendorToCategory","notes","items","length","join","message","addExpenseFromReceipt","expenseData","modifications","finalExpenseData","result","scanRef","String","rejectScannedReceipt","_receiptScanStatus$da","vendorName","vendorNameLower","toLowerCase","categoryMappings","keyword","Object","entries","includes","addIncome","income","source","newIncome","deleteExpense","expenseRef","expenseSnap","exists","scanSnap","deleteIncome","updateBudget","trim","budgetRef","budgetDoc","prevBudgets","deleteBudget","currentBudgets","undefined","allExpenses","currentDate","currentMonth","getMonth","currentYear","getFullYear","monthlyExpenses","filter","expenseDate","e","totalSpent","reduce","sum","budgetAmount","_currentUser$preferen","newAlert","toFixed","read","alertRef","preferences","emailNotifications","email","then","catch","markAlertAsRead","deleteAlert","addExpenseCategory","categoriesRef","categoriesDoc","updatedCategories","currentCategories","categories","deleteExpenseCategory","expensesSnap","empty","reason","cat","editExpenseCategory","oldCategory","newCategory","addIncomeCategory","deleteIncomeCategory","incomesSnap","editIncomeCategory","getMonthlyExpenses","month","year","targetDate","targetMonth","targetYear","getMonthlyIncomes","incomeDate","getReceiptScans","scansQuery","scansSnap","updateExpense","updatedData","updateIncome","incomeRef","exportData","categoriesSnap","budgetsSnap","Promise","all","exportDate","importData","batch","expenseCategoriesRef","set","incomeCategoriesRef","budgetsRef","commit","incomeData","getSpendingInsights","months","insights","topCategories","monthlyTotals","yearlyComparison","receiptUsage","total","percentage","startDate","setMonth","startDateString","relevantExpenses","categoryTotals","forEach","sort","a","b","monthlyData","monthYear","label","toLocaleString","values","receiptsCount","fetchSettings","expenseCategoriesDoc","incomeCategoriesDoc","budgetsDoc","alertsQuery","alertsList","scansList","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/tejit/OneDrive/Desktop/expence tracker final/expence-tracker/src/context/ExpenseContext.js"],"sourcesContent":["// src/context/ExpenseContext.js\r\nimport React, { createContext, useState, useEffect, useContext } from 'react';\r\nimport { AuthContext } from './AuthContext';\r\nimport { sendBudgetAlertEmail } from '../services/EmailService';\r\nimport { scanReceiptImage, parseReceiptData } from '../services/ReceiptScanningService';\r\n// Add Firebase imports\r\nimport { db, storage } from '../config/firebase';\r\nimport { \r\n  collection, \r\n  addDoc, \r\n  doc, \r\n  deleteDoc, \r\n  updateDoc, \r\n  query, \r\n  where, \r\n  getDocs, \r\n  onSnapshot, \r\n  getDoc,\r\n  setDoc,\r\n  limit \r\n} from 'firebase/firestore';\r\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\r\n\r\nexport const ExpenseContext = createContext();\r\n\r\nexport const ExpenseProvider = ({ children }) => {\r\n  const [expenses, setExpenses] = useState([]);\r\n  const [incomes, setIncomes] = useState([]);\r\n  const [budgets, setBudgets] = useState({});\r\n  const [alerts, setAlerts] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [emailStatus, setEmailStatus] = useState({ sent: false, error: null });\r\n  const [expenseCategories, setExpenseCategories] = useState([]);\r\n  const [incomeCategories, setIncomeCategories] = useState([]);\r\n  // Add new state for receipt scanning\r\n  const [receiptScanStatus, setReceiptScanStatus] = useState({ \r\n    scanning: false, \r\n    error: null, \r\n    data: null \r\n  });\r\n  // Track receipt scan history\r\n  const [receiptScans, setReceiptScans] = useState([]);\r\n  \r\n  const { currentUser } = useContext(AuthContext);\r\n  \r\n  // Default categories if none are found\r\n  const DEFAULT_EXPENSE_CATEGORIES = [\r\n    'Food', 'Housing', 'Transportation', 'Entertainment', \r\n    'Utilities', 'Healthcare', 'Shopping', 'Personal Care', 'Education', 'Other'\r\n  ];\r\n  \r\n  const DEFAULT_INCOME_CATEGORIES = [\r\n    'Salary', 'Freelance', 'Investment', 'Gift', \r\n    'Business', 'Side Hustle', 'Rental', 'Other'\r\n  ];\r\n  \r\n  // Load expenses from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setExpenses([]);\r\n      setLoading(false);\r\n      return;\r\n    }\r\n    \r\n    setLoading(true);\r\n    \r\n    // Query Firestore for expenses\r\n    const expensesQuery = query(\r\n      collection(db, 'expenses'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(expensesQuery, (snapshot) => {\r\n      const expensesList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setExpenses(expensesList);\r\n      setLoading(false);\r\n    }, (error) => {\r\n      console.error(\"Error getting expenses:\", error);\r\n      setLoading(false);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Load incomes from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setIncomes([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for incomes\r\n    const incomesQuery = query(\r\n      collection(db, 'incomes'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(incomesQuery, (snapshot) => {\r\n      const incomesList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setIncomes(incomesList);\r\n    }, (error) => {\r\n      console.error(\"Error getting incomes:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Clear email status after some time\r\n  useEffect(() => {\r\n    if (emailStatus.sent || emailStatus.error) {\r\n      const timer = setTimeout(() => {\r\n        setEmailStatus({ sent: false, error: null });\r\n      }, 5000);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [emailStatus]);\r\n  \r\n  // Clear receipt scan data after processing\r\n  useEffect(() => {\r\n    if (receiptScanStatus.data && !receiptScanStatus.scanning) {\r\n      const timer = setTimeout(() => {\r\n        setReceiptScanStatus(prevState => ({\r\n          ...prevState, \r\n          data: null\r\n        }));\r\n      }, 30000); // Give user 30 seconds to review before clearing\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [receiptScanStatus]);\r\n  \r\n  // Add a new expense with validation\r\n  const addExpense = async (expense) => {\r\n    if (!currentUser) return false;\r\n    \r\n    try {\r\n      // Validate expense data\r\n      if (!expense.category) {\r\n        console.error('Missing category in expense');\r\n        return false;\r\n      }\r\n      \r\n      const amount = parseFloat(expense.amount);\r\n      if (isNaN(amount) || amount <= 0) {\r\n        console.error('Invalid expense amount:', expense.amount);\r\n        return false;\r\n      }\r\n      \r\n      // Handle receipt image if present\r\n      let receiptImageUrl = expense.receiptImageUrl || null;\r\n      if (expense.receiptImage instanceof File) {\r\n        const storageRef = ref(storage, `receipts/${currentUser.uid}/${Date.now()}_${expense.receiptImage.name}`);\r\n        await uploadBytes(storageRef, expense.receiptImage);\r\n        receiptImageUrl = await getDownloadURL(storageRef);\r\n      }\r\n      \r\n      // Create new expense object\r\n      const newExpense = {\r\n        ...expense,\r\n        amount,\r\n        date: expense.date || new Date().toISOString().slice(0, 10),\r\n        userId: currentUser.uid,\r\n        createdAt: new Date().toISOString(),\r\n        fromReceipt: expense.fromReceipt || false,\r\n        receiptImageUrl,\r\n        receiptScanId: expense.receiptScanId || null\r\n      };\r\n      \r\n      // Delete any properties we don't want to store\r\n      delete newExpense.receiptImage;\r\n      \r\n      // Add to Firestore\r\n      const docRef = await addDoc(collection(db, 'expenses'), newExpense);\r\n      \r\n      // Check for budget alerts\r\n      await checkBudgetAlerts({\r\n        ...newExpense,\r\n        id: docRef.id\r\n      });\r\n      \r\n      return docRef.id;\r\n    } catch (error) {\r\n      console.error('Error adding expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // New function to handle receipt scanning\r\n  const scanReceipt = async (imageFile) => {\r\n    if (!currentUser) return { success: false, error: 'User not logged in' };\r\n    if (!imageFile) {\r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: 'No image provided',\r\n        data: null\r\n      });\r\n      return { success: false, error: 'No image provided' };\r\n    }\r\n    \r\n    try {\r\n      // Set scanning status\r\n      setReceiptScanStatus({\r\n        scanning: true,\r\n        error: null,\r\n        data: null\r\n      });\r\n      \r\n      // Call the receipt scanning service\r\n      const scanResult = await scanReceiptImage(imageFile);\r\n      \r\n      if (!scanResult || !scanResult.success) {\r\n        const errorMessage = scanResult?.error || 'Failed to scan receipt';\r\n        setReceiptScanStatus({\r\n          scanning: false,\r\n          error: errorMessage,\r\n          data: null\r\n        });\r\n        \r\n        return { success: false, error: errorMessage };\r\n      }\r\n      \r\n      // Process the scanned data\r\n      const parsedData = parseReceiptData(scanResult);\r\n      \r\n      if (!parsedData) {\r\n        setReceiptScanStatus({\r\n          scanning: false,\r\n          error: 'Failed to parse receipt data',\r\n          data: null\r\n        });\r\n        \r\n        return { success: false, error: 'Failed to parse receipt data' };\r\n      }\r\n      \r\n      // Create a scan record\r\n      const scanId = Date.now();\r\n      const scanRecord = {\r\n        id: scanId,\r\n        date: new Date().toISOString(),\r\n        rawData: scanResult,\r\n        parsedData: parsedData,\r\n        userId: currentUser.uid,\r\n        status: 'pending', // pending, applied, rejected\r\n        imageUrl: scanResult.imageUrl\r\n      };\r\n      \r\n      // Store the scan record in Firestore\r\n      await addDoc(collection(db, 'receiptScans'), scanRecord);\r\n      \r\n      // Prepare the extracted data for the UI\r\n      const extractedExpense = {\r\n        amount: parsedData.amount,\r\n        description: parsedData.merchantName || 'Receipt expense',\r\n        category: mapVendorToCategory(parsedData.merchantName || ''),\r\n        date: parsedData.date || new Date().toISOString().slice(0, 10),\r\n        fromReceipt: true,\r\n        receiptImageUrl: parsedData.imageUrl || null,\r\n        receiptScanId: scanId,\r\n        notes: `Receipt from ${parsedData.merchantName || 'unknown vendor'}${parsedData.items?.length > 0 ? `, Items: ${parsedData.items.join(', ')}` : ''}`\r\n      };\r\n      \r\n      // Update scan status with the extracted data\r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: null,\r\n        data: extractedExpense\r\n      });\r\n      \r\n      return {\r\n        success: true,\r\n        data: extractedExpense,\r\n        scanId\r\n      };\r\n    } catch (error) {\r\n      console.error('Error scanning receipt:', error);\r\n      \r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: error.message || 'Error scanning receipt',\r\n        data: null\r\n      });\r\n      \r\n      return {\r\n        success: false,\r\n        error: error.message || 'Error scanning receipt'\r\n      };\r\n    }\r\n  };\r\n  \r\n  // Function to add the expense from a scanned receipt\r\n  const addExpenseFromReceipt = async (expenseData, modifications = {}) => {\r\n    if (!currentUser) return false;\r\n    \r\n    try {\r\n      // Combine scanned data with any user modifications\r\n      const finalExpenseData = {\r\n        ...expenseData,\r\n        ...modifications,\r\n        fromReceipt: true\r\n      };\r\n      \r\n      // Use the existing addExpense function\r\n      const result = await addExpense(finalExpenseData);\r\n      \r\n      if (result && finalExpenseData.receiptScanId) {\r\n        // Update the scan record status in Firestore\r\n        const scanRef = doc(db, 'receiptScans', String(finalExpenseData.receiptScanId));\r\n        await updateDoc(scanRef, { status: 'applied' });\r\n        \r\n        // Clear the scanned data after successful addition\r\n        setReceiptScanStatus(prevState => ({\r\n          ...prevState,\r\n          data: null\r\n        }));\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('Error adding expense from receipt:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Function to reject a scanned receipt\r\n  const rejectScannedReceipt = async (scanId) => {\r\n    if (!scanId) return false;\r\n    \r\n    try {\r\n      // Update the scan record status in Firestore\r\n      const scanRef = doc(db, 'receiptScans', String(scanId));\r\n      await updateDoc(scanRef, { status: 'rejected' });\r\n      \r\n      // Clear any pending scan data with this ID\r\n      if (receiptScanStatus.data?.receiptScanId === scanId) {\r\n        setReceiptScanStatus({\r\n          scanning: false,\r\n          error: null,\r\n          data: null\r\n        });\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error rejecting scanned receipt:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Helper function to map vendor names to appropriate categories\r\n  const mapVendorToCategory = (vendorName) => {\r\n    const vendorNameLower = vendorName.toLowerCase();\r\n    \r\n    // Simple mapping logic - can be expanded based on common vendors\r\n    if (!vendorName) return 'Other';\r\n    \r\n    const categoryMappings = {\r\n      'restaurant': 'Food',\r\n      'café': 'Food',\r\n      'cafe': 'Food',\r\n      'grocery': 'Food',\r\n      'supermarket': 'Food',\r\n      'market': 'Food',\r\n      'gas': 'Transportation',\r\n      'fuel': 'Transportation',\r\n      'uber': 'Transportation',\r\n      'lyft': 'Transportation',\r\n      'taxi': 'Transportation',\r\n      'pharmacy': 'Healthcare',\r\n      'drug': 'Healthcare',\r\n      'doctor': 'Healthcare',\r\n      'clinic': 'Healthcare',\r\n      'hospital': 'Healthcare',\r\n      'rent': 'Housing',\r\n      'mortgage': 'Housing',\r\n      'netflix': 'Entertainment',\r\n      'spotify': 'Entertainment',\r\n      'cinema': 'Entertainment',\r\n      'movie': 'Entertainment',\r\n      'theater': 'Entertainment',\r\n      'amazon': 'Shopping',\r\n      'walmart': 'Shopping',\r\n      'target': 'Shopping',\r\n      'utility': 'Utilities',\r\n      'electric': 'Utilities',\r\n      'water': 'Utilities',\r\n      'gas bill': 'Utilities',\r\n      'phone': 'Utilities',\r\n      'internet': 'Utilities',\r\n      'school': 'Education',\r\n      'college': 'Education',\r\n      'university': 'Education',\r\n      'tuition': 'Education',\r\n      'book': 'Education',\r\n      'haircut': 'Personal Care',\r\n      'salon': 'Personal Care',\r\n      'spa': 'Personal Care',\r\n      'gym': 'Personal Care'\r\n    };\r\n    \r\n    for (const [keyword, category] of Object.entries(categoryMappings)) {\r\n      if (vendorNameLower.includes(keyword)) {\r\n        return category;\r\n      }\r\n    }\r\n    \r\n    return 'Other';\r\n  };\r\n  \r\n  // Add a new income with validation\r\n  const addIncome = async (income) => {\r\n    if (!currentUser) return false;\r\n    \r\n    try {\r\n      // Validate income data\r\n      if (!income.source) {\r\n        console.error('Missing source in income');\r\n        return false;\r\n      }\r\n      \r\n      const amount = parseFloat(income.amount);\r\n      if (isNaN(amount) || amount <= 0) {\r\n        console.error('Invalid income amount:', income.amount);\r\n        return false;\r\n      }\r\n      \r\n      // Create new income object\r\n      const newIncome = {\r\n        ...income,\r\n        amount,\r\n        date: income.date || new Date().toISOString().slice(0, 10),\r\n        userId: currentUser.uid,\r\n        createdAt: new Date().toISOString()\r\n      };\r\n      \r\n      // Add to Firestore\r\n      const docRef = await addDoc(collection(db, 'incomes'), newIncome);\r\n      \r\n      return docRef.id;\r\n    } catch (error) {\r\n      console.error('Error adding income:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an expense\r\n  const deleteExpense = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      // Get the expense before deleting it (to check for receipt info)\r\n      const expenseRef = doc(db, 'expenses', id);\r\n      const expenseSnap = await getDoc(expenseRef);\r\n      \r\n      if (expenseSnap.exists()) {\r\n        const expenseData = expenseSnap.data();\r\n        \r\n        // Delete the expense document\r\n        await deleteDoc(expenseRef);\r\n        \r\n        // If this was a receipt-based expense, update the scan record\r\n        if (expenseData.receiptScanId) {\r\n          const scanRef = doc(db, 'receiptScans', String(expenseData.receiptScanId));\r\n          const scanSnap = await getDoc(scanRef);\r\n          \r\n          if (scanSnap.exists()) {\r\n            await updateDoc(scanRef, { status: 'rejected' });\r\n          }\r\n        }\r\n      } else {\r\n        // Document not found\r\n        console.error('Expense not found');\r\n        return false;\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an income\r\n  const deleteIncome = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      await deleteDoc(doc(db, 'incomes', id));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting income:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Update budget settings\r\n  const updateBudget = async (category, amount) => {\r\n    if (!currentUser || !category || category.trim() === '' || isNaN(parseFloat(amount))) {\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        // Update existing budgets document\r\n        await updateDoc(budgetRef, {\r\n          [category]: parseFloat(amount)\r\n        });\r\n      } else {\r\n        // Create new budgets document\r\n        await setDoc(budgetRef, {\r\n          [category]: parseFloat(amount)\r\n        });\r\n      }\r\n      \r\n      // Update local state\r\n      setBudgets(prevBudgets => ({\r\n        ...prevBudgets,\r\n        [category]: parseFloat(amount)\r\n      }));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating budget:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete a budget\r\n  const deleteBudget = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        // Remove the category from the budgets\r\n        if (currentBudgets[category] !== undefined) {\r\n          delete currentBudgets[category];\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting budget:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Check if adding this expense exceeds the budget\r\n  const checkBudgetAlerts = async (newExpense, allExpenses = expenses) => {\r\n    if (!currentUser) return; // Don't process if no user is logged in\r\n    if (!newExpense || !newExpense.category) return;\r\n    \r\n    const { category } = newExpense;\r\n    \r\n    // Get budgets from Firestore\r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (!budgetDoc.exists()) return;\r\n      \r\n      const budgets = budgetDoc.data();\r\n      \r\n      // Check if there's a budget for this category\r\n      if (budgets[category]) {\r\n        // Get current month expenses for this category\r\n        const currentDate = new Date();\r\n        const currentMonth = currentDate.getMonth();\r\n        const currentYear = currentDate.getFullYear();\r\n        \r\n        const monthlyExpenses = allExpenses.filter(expense => {\r\n          if (!expense.date) return false;\r\n          \r\n          try {\r\n            const expenseDate = new Date(expense.date);\r\n            return expenseDate.getMonth() === currentMonth && \r\n                  expenseDate.getFullYear() === currentYear &&\r\n                  expense.category === category &&\r\n                  expense.userId === currentUser.uid;\r\n          } catch (e) {\r\n            console.error('Invalid date format:', expense.date);\r\n            return false;\r\n          }\r\n        });\r\n        \r\n        const totalSpent = monthlyExpenses.reduce((sum, expense) => {\r\n          const amount = parseFloat(expense.amount);\r\n          return sum + (isNaN(amount) ? 0 : amount);\r\n        }, 0);\r\n        \r\n        const budgetAmount = parseFloat(budgets[category]);\r\n        \r\n        if (!isNaN(budgetAmount) && totalSpent > budgetAmount) {\r\n          // Create new alert\r\n          const newAlert = {\r\n            message: `Budget alert: You've exceeded your ${category} budget of $${budgetAmount.toFixed(2)}`,\r\n            category: category,\r\n            read: false,\r\n            date: new Date().toISOString(),\r\n            userId: currentUser.uid\r\n          };\r\n          \r\n          // Add to Firestore\r\n          const alertRef = await addDoc(collection(db, 'alerts'), newAlert);\r\n          \r\n          // Send email alert if user has enabled email notifications\r\n          if (currentUser?.preferences?.emailNotifications !== false) {\r\n            if (currentUser.email) {\r\n              sendBudgetAlertEmail(\r\n                currentUser,\r\n                category,\r\n                budgetAmount,\r\n                totalSpent\r\n              ).then(result => {\r\n                setEmailStatus({ \r\n                  sent: result.success, \r\n                  error: result.success ? null : result.message \r\n                });\r\n              }).catch(error => {\r\n                setEmailStatus({ \r\n                  sent: false, \r\n                  error: error.message || 'Error sending email'\r\n                });\r\n              });\r\n            } else {\r\n              setEmailStatus({ \r\n                sent: false, \r\n                error: \"No email address found for user\"\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error checking budget alerts:', error);\r\n    }\r\n  };\r\n  \r\n  // Mark an alert as read\r\n  const markAlertAsRead = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const alertRef = doc(db, 'alerts', id);\r\n      await updateDoc(alertRef, { read: true });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error marking alert as read:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an alert\r\n  const deleteAlert = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      await deleteDoc(doc(db, 'alerts', id));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting alert:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Add a new expense category\r\n  const addExpenseCategory = async (category) => {\r\n    if (!currentUser || !category || category.trim() === '') return false;\r\n    \r\n    try {\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      let updatedCategories;\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        \r\n        // Check if category already exists\r\n        if (currentCategories.includes(category)) {\r\n          return false;\r\n        }\r\n        \r\n        updatedCategories = [...currentCategories, category];\r\n      } else {\r\n        updatedCategories = [...DEFAULT_EXPENSE_CATEGORIES, category];\r\n      }\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setExpenseCategories(updatedCategories);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error adding expense category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an expense category\r\n  const deleteExpenseCategory = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      // Don't delete if there are expenses using this category\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('category', '==', category),\r\n        limit(1)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      if (!expensesSnap.empty) {\r\n        return { success: false, reason: 'Category in use by existing expenses' };\r\n      }\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\r\n        \r\n        // Update Firestore\r\n        await setDoc(categoriesRef, { categories: updatedCategories });\r\n        \r\n        // Update local state\r\n        setExpenseCategories(updatedCategories);\r\n      }\r\n      \r\n      // Also remove any budgets for this category\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        if (currentBudgets[category] !== undefined) {\r\n          delete currentBudgets[category];\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Error deleting expense category:', error);\r\n      return { success: false, reason: error.message };\r\n    }\r\n  };\r\n  \r\n  // Edit an expense category\r\n  const editExpenseCategory = async (oldCategory, newCategory) => {\r\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\r\n    \r\n    try {\r\n      // Don't allow editing the \"Other\" category\r\n      if (oldCategory === 'Other') return false;\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (!categoriesDoc.exists()) return false;\r\n      \r\n      const currentCategories = categoriesDoc.data().categories || [];\r\n      \r\n      // Check if the new category name already exists\r\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\r\n      \r\n      // Check if the category is in use\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('category', '==', oldCategory),\r\n        limit(1)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      if (!expensesSnap.empty) return false;\r\n      \r\n      // Update categories\r\n      const updatedCategories = currentCategories.map(cat => \r\n        cat === oldCategory ? newCategory : cat\r\n      );\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setExpenseCategories(updatedCategories);\r\n      \r\n      // Update any budget for this category\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        if (currentBudgets[oldCategory] !== undefined) {\r\n          const budgetAmount = currentBudgets[oldCategory];\r\n          delete currentBudgets[oldCategory];\r\n          currentBudgets[newCategory] = budgetAmount;\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error editing expense category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Add a new income category\r\n  const addIncomeCategory = async (category) => {\r\n    if (!currentUser || !category || category.trim() === '') return false;\r\n    \r\n    try {\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      let updatedCategories;\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        \r\n        // Check if category already exists\r\n        if (currentCategories.includes(category)) {\r\n          return false;\r\n        }\r\n        \r\n        updatedCategories = [...currentCategories, category];\r\n      } else {\r\n        updatedCategories = [...DEFAULT_INCOME_CATEGORIES, category];\r\n      }\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setIncomeCategories(updatedCategories);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error adding income category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an income category\r\n  const deleteIncomeCategory = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      // Don't delete if there are incomes using this category\r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('source', '==', category),\r\n        limit(1)\r\n      );\r\n      \r\n      const incomesSnap = await getDocs(incomesQuery);\r\n      \r\n      if (!incomesSnap.empty) {\r\n        return { success: false, reason: 'Category in use by existing incomes' };\r\n      }\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\r\n        \r\n        // Update Firestore\r\n        await setDoc(categoriesRef, { categories: updatedCategories });\r\n        \r\n        // Update local state\r\n        setIncomeCategories(updatedCategories);\r\n      }\r\n      \r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Error deleting income category:', error);\r\n      return { success: false, reason: error.message };\r\n    }\r\n  };\r\n  \r\n  // Edit an income category\r\n  const editIncomeCategory = async (oldCategory, newCategory) => {\r\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\r\n    \r\n    try {\r\n      // Don't allow editing the \"Other\" category\r\n      if (oldCategory === 'Other') return false;\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (!categoriesDoc.exists()) return false;\r\n      \r\n      const currentCategories = categoriesDoc.data().categories || [];\r\n      \r\n      // Check if the new category name already exists\r\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\r\n      \r\n      // Check if the category is in use\r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('source', '==', oldCategory),\r\n        limit(1)\r\n      );\r\n      \r\n      const incomesSnap = await getDocs(incomesQuery);\r\n      \r\n      if (!incomesSnap.empty) return false;\r\n      \r\n      // Update categories\r\n      const updatedCategories = currentCategories.map(cat => \r\n        cat === oldCategory ? newCategory : cat\r\n      );\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setIncomeCategories(updatedCategories);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error editing income category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Get expenses for a specific month\r\n  const getMonthlyExpenses = (month, year) => {\r\n    if (!currentUser) return [];\r\n    \r\n    const targetDate = new Date(year, month);\r\n    const targetMonth = targetDate.getMonth();\r\n    const targetYear = targetDate.getFullYear();\r\n    \r\n    return expenses.filter(expense => {\r\n      if (!expense.date) return false;\r\n      \r\n      try {\r\n        const expenseDate = new Date(expense.date);\r\n        return expenseDate.getMonth() === targetMonth && \r\n              expenseDate.getFullYear() === targetYear &&\r\n              expense.userId === currentUser.uid;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    });\r\n  };\r\n  \r\n  // Get incomes for a specific month\r\n  const getMonthlyIncomes = (month, year) => {\r\n    if (!currentUser) return [];\r\n    \r\n    const targetDate = new Date(year, month);\r\n    const targetMonth = targetDate.getMonth();\r\n    const targetYear = targetDate.getFullYear();\r\n    \r\n    return incomes.filter(income => {\r\n      if (!income.date) return false;\r\n      \r\n      try {\r\n        const incomeDate = new Date(income.date);\r\n        return incomeDate.getMonth() === targetMonth && \r\n              incomeDate.getFullYear() === targetYear &&\r\n              income.userId === currentUser.uid;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    });\r\n  };\r\n  \r\n  // Get historical receipt scans\r\n  const getReceiptScans = async () => {\r\n    if (!currentUser) return [];\r\n    \r\n    try {\r\n      const scansQuery = query(\r\n        collection(db, 'receiptScans'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const scansSnap = await getDocs(scansQuery);\r\n      \r\n      return scansSnap.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error getting receipt scans:', error);\r\n      return [];\r\n    }\r\n  };\r\n  \r\n  // Update an existing expense\r\n  const updateExpense = async (id, updatedData) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const expenseRef = doc(db, 'expenses', id);\r\n      await updateDoc(expenseRef, updatedData);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Update an existing income\r\n  const updateIncome = async (id, updatedData) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const incomeRef = doc(db, 'incomes', id);\r\n      await updateDoc(incomeRef, updatedData);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating income:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Export data for backups\r\n  const exportData = async () => {\r\n    if (!currentUser) return null;\r\n    \r\n    try {\r\n      // Get all current user data\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const scansQuery = query(\r\n        collection(db, 'receiptScans'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const [expensesSnap, incomesSnap, scansSnap, categoriesSnap, budgetsSnap] = await Promise.all([\r\n        getDocs(expensesQuery),\r\n        getDocs(incomesQuery),\r\n        getDocs(scansQuery),\r\n        getDoc(doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories')),\r\n        getDoc(doc(db, 'users', currentUser.uid, 'settings', 'budgets'))\r\n      ]);\r\n      \r\n      const exportData = {\r\n        expenses: expensesSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        incomes: incomesSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        receiptScans: scansSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        expenseCategories: categoriesSnap.exists() ? categoriesSnap.data().categories : DEFAULT_EXPENSE_CATEGORIES,\r\n        incomeCategories: incomeCategories,\r\n        budgets: budgetsSnap.exists() ? budgetsSnap.data() : {},\r\n        exportDate: new Date().toISOString(),\r\n        userId: currentUser.uid\r\n      };\r\n      \r\n      return exportData;\r\n    } catch (error) {\r\n      console.error('Error exporting data:', error);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  // Import data from backups\r\n  const importData = async (data) => {\r\n    if (!currentUser || !data) return false;\r\n    \r\n    try {\r\n      // Validate data structure\r\n      if (!data.expenses || !data.incomes || !data.budgets || \r\n          !data.expenseCategories || !data.incomeCategories) {\r\n        console.error('Invalid import data structure');\r\n        return false;\r\n      }\r\n      \r\n      // Begin batch operations\r\n      const batch = db.batch();\r\n      \r\n      // Update expense categories\r\n      const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      batch.set(expenseCategoriesRef, { categories: data.expenseCategories });\r\n      \r\n      // Update income categories\r\n      const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      batch.set(incomeCategoriesRef, { categories: data.incomeCategories });\r\n      \r\n      // Update budgets\r\n      const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      batch.set(budgetsRef, data.budgets);\r\n      \r\n      // Commit the batch\r\n      await batch.commit();\r\n      \r\n      // Update local state\r\n      setExpenseCategories(data.expenseCategories);\r\n      setIncomeCategories(data.incomeCategories);\r\n      setBudgets(data.budgets);\r\n      \r\n      // Handle expense and income imports separately (may be too many for a single batch)\r\n      for (const expense of data.expenses) {\r\n        try {\r\n          const { id, ...expenseData } = expense;\r\n          expenseData.userId = currentUser.uid; // Ensure correct user ID\r\n          await addDoc(collection(db, 'expenses'), expenseData);\r\n        } catch (e) {\r\n          console.error('Error importing expense:', e);\r\n          // Continue with other imports\r\n        }\r\n      }\r\n      \r\n      for (const income of data.incomes) {\r\n        try {\r\n          const { id, ...incomeData } = income;\r\n          incomeData.userId = currentUser.uid; // Ensure correct user ID\r\n          await addDoc(collection(db, 'incomes'), incomeData);\r\n        } catch (e) {\r\n          console.error('Error importing income:', e);\r\n          // Continue with other imports\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error importing data:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Get spending insights\r\n  const getSpendingInsights = async (months = 3) => {\r\n    if (!currentUser || months < 1) return null;\r\n    \r\n    try {\r\n      const currentDate = new Date();\r\n      const insights = {\r\n        topCategories: [],\r\n        monthlyTotals: [],\r\n        yearlyComparison: {},\r\n        receiptUsage: {\r\n          total: 0,\r\n          percentage: 0\r\n        }\r\n      };\r\n      \r\n      // Get relevant expenses from Firestore\r\n      const startDate = new Date();\r\n      startDate.setMonth(startDate.getMonth() - months);\r\n      \r\n      // Format for Firestore query\r\n      const startDateString = startDate.toISOString();\r\n      \r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('date', '>=', startDateString)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      const relevantExpenses = expensesSnap.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      \r\n      // Calculate top spending categories\r\n      const categoryTotals = {};\r\n      relevantExpenses.forEach(expense => {\r\n        const { category, amount } = expense;\r\n        if (!category) return;\r\n        \r\n        categoryTotals[category] = (categoryTotals[category] || 0) + parseFloat(amount || 0);\r\n      });\r\n      \r\n      insights.topCategories = Object.entries(categoryTotals)\r\n        .map(([category, total]) => ({ category, total }))\r\n        .sort((a, b) => b.total - a.total)\r\n        .slice(0, 5); // Get top 5\r\n      \r\n      // Calculate monthly totals\r\n      const monthlyData = {};\r\n      relevantExpenses.forEach(expense => {\r\n        if (!expense.date) return;\r\n        \r\n        const expenseDate = new Date(expense.date);\r\n        const monthYear = `${expenseDate.getFullYear()}-${expenseDate.getMonth()+1}`;\r\n        \r\n        if (!monthlyData[monthYear]) {\r\n          monthlyData[monthYear] = {\r\n            month: expenseDate.getMonth(),\r\n            year: expenseDate.getFullYear(),\r\n            total: 0,\r\n            label: expenseDate.toLocaleString('default', { month: 'short', year: 'numeric' })\r\n          };\r\n        }\r\n        \r\n        monthlyData[monthYear].total += parseFloat(expense.amount || 0);\r\n      });\r\n      \r\n      insights.monthlyTotals = Object.values(monthlyData)\r\n        .sort((a, b) => {\r\n          if (a.year !== b.year) return a.year - b.year;\r\n          return a.month - b.month;\r\n        });\r\n      \r\n      // Calculate receipt usage statistics\r\n      const receiptsCount = relevantExpenses.filter(expense => expense.fromReceipt).length;\r\n      insights.receiptUsage = {\r\n        total: receiptsCount,\r\n        percentage: relevantExpenses.length > 0 \r\n          ? (receiptsCount / relevantExpenses.length) * 100 \r\n          : 0\r\n      };\r\n      \r\n      return insights;\r\n    } catch (error) {\r\n      console.error('Error generating spending insights:', error);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  // Load categories and other settings from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setExpenseCategories([]);\r\n      setIncomeCategories([]);\r\n      setBudgets({});\r\n      return;\r\n    }\r\n    \r\n    // Load categories and budgets\r\n    const fetchSettings = async () => {\r\n      try {\r\n        // Get expense categories\r\n        const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n        const expenseCategoriesDoc = await getDoc(expenseCategoriesRef);\r\n        \r\n        if (expenseCategoriesDoc.exists()) {\r\n          setExpenseCategories(expenseCategoriesDoc.data().categories || DEFAULT_EXPENSE_CATEGORIES);\r\n        } else {\r\n          // Create default categories if none exist\r\n          await setDoc(expenseCategoriesRef, {\r\n            categories: DEFAULT_EXPENSE_CATEGORIES\r\n          });\r\n          setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\r\n        }\r\n        \r\n        // Get income categories\r\n        const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n        const incomeCategoriesDoc = await getDoc(incomeCategoriesRef);\r\n        \r\n        if (incomeCategoriesDoc.exists()) {\r\n          setIncomeCategories(incomeCategoriesDoc.data().categories || DEFAULT_INCOME_CATEGORIES);\r\n        } else {\r\n          // Create default categories if none exist\r\n          await setDoc(incomeCategoriesRef, {\r\n            categories: DEFAULT_INCOME_CATEGORIES\r\n          });\r\n          setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\r\n        }\r\n        \r\n        // Get budgets\r\n        const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n        const budgetsDoc = await getDoc(budgetsRef);\r\n        \r\n        if (budgetsDoc.exists()) {\r\n          setBudgets(budgetsDoc.data());\r\n        }\r\n      } catch (error) {\r\n        console.error('Error loading settings:', error);\r\n        setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\r\n        setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\r\n      }\r\n    };\r\n    \r\n    fetchSettings();\r\n  }, [currentUser]);\r\n  \r\n  // Load alerts from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setAlerts([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for alerts\r\n    const alertsQuery = query(\r\n      collection(db, 'alerts'),\r\n      where('userId', '==', currentUser.uid),\r\n      where('read', '==', false)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(alertsQuery, (snapshot) => {\r\n      const alertsList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setAlerts(alertsList);\r\n    }, (error) => {\r\n      console.error(\"Error getting alerts:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Load receipt scans from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setReceiptScans([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for receipt scans\r\n    const scansQuery = query(\r\n      collection(db, 'receiptScans'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(scansQuery, (snapshot) => {\r\n      const scansList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setReceiptScans(scansList);\r\n    }, (error) => {\r\n      console.error(\"Error getting receipt scans:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  return (\r\n    <ExpenseContext.Provider value={{\r\n      expenses,\r\n      incomes,\r\n      budgets,\r\n      alerts,\r\n      expenseCategories,\r\n      incomeCategories,\r\n      receiptScanStatus,\r\n      receiptScans,\r\n      emailStatus,\r\n      loading,\r\n      addExpense,\r\n      addIncome,\r\n      deleteExpense,\r\n      deleteIncome,\r\n      updateExpense,\r\n      updateIncome,\r\n      updateBudget,\r\n      deleteBudget,\r\n      markAlertAsRead,\r\n      deleteAlert,\r\n      addExpenseCategory,\r\n      deleteExpenseCategory,\r\n      editExpenseCategory,\r\n      addIncomeCategory,\r\n      deleteIncomeCategory,\r\n      editIncomeCategory,\r\n      scanReceipt,\r\n      addExpenseFromReceipt,\r\n      rejectScannedReceipt,\r\n      getMonthlyExpenses,\r\n      getMonthlyIncomes,\r\n      getReceiptScans,\r\n      exportData,\r\n      importData,\r\n      getSpendingInsights\r\n    }}>\r\n      {children}\r\n    </ExpenseContext.Provider>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}