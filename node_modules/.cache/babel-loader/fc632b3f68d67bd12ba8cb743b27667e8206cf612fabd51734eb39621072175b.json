{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\tejit\\\\OneDrive\\\\Desktop\\\\expence tracker final\\\\expence-tracker\\\\src\\\\context\\\\ExpenseContext.js\",\n  _s = $RefreshSig$();\n// src/context/ExpenseContext.js\nimport React, { createContext, useState, useEffect, useContext } from 'react';\nimport { AuthContext } from './AuthContext';\nimport { sendBudgetAlertEmail } from '../services/EmailService';\nimport { scanReceiptImage, parseReceiptData } from '../services/ReceiptScanningService';\n// Add Firebase imports\nimport { db, storage } from '../config/firebase';\nimport { collection, addDoc, doc, deleteDoc, updateDoc, query, where, getDocs, onSnapshot, getDoc, setDoc, limit } from 'firebase/firestore';\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ExpenseContext = /*#__PURE__*/createContext();\nexport const ExpenseProvider = ({\n  children\n}) => {\n  _s();\n  const [expenses, setExpenses] = useState([]);\n  const [incomes, setIncomes] = useState([]);\n  const [budgets, setBudgets] = useState({});\n  const [alerts, setAlerts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [emailStatus, setEmailStatus] = useState({\n    sent: false,\n    error: null\n  });\n  const [expenseCategories, setExpenseCategories] = useState([]);\n  const [incomeCategories, setIncomeCategories] = useState([]);\n  // Add new state for receipt scanning\n  const [receiptScanStatus, setReceiptScanStatus] = useState({\n    scanning: false,\n    error: null,\n    data: null\n  });\n  // Track receipt scan history\n  const [receiptScans, setReceiptScans] = useState([]);\n  const {\n    currentUser\n  } = useContext(AuthContext);\n\n  // Default categories if none are found\n  const DEFAULT_EXPENSE_CATEGORIES = ['Food', 'Housing', 'Transportation', 'Entertainment', 'Utilities', 'Healthcare', 'Shopping', 'Personal Care', 'Education', 'Other'];\n  const DEFAULT_INCOME_CATEGORIES = ['Salary', 'Freelance', 'Investment', 'Gift', 'Business', 'Side Hustle', 'Rental', 'Other'];\n\n  // Load expenses from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setExpenses([]);\n      setLoading(false);\n      return;\n    }\n    setLoading(true);\n\n    // Query Firestore for expenses\n    const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(expensesQuery, snapshot => {\n      const expensesList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setExpenses(expensesList);\n      setLoading(false);\n    }, error => {\n      console.error(\"Error getting expenses:\", error);\n      setLoading(false);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Load incomes from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setIncomes([]);\n      return;\n    }\n\n    // Query Firestore for incomes\n    const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(incomesQuery, snapshot => {\n      const incomesList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setIncomes(incomesList);\n    }, error => {\n      console.error(\"Error getting incomes:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Clear email status after some time\n  useEffect(() => {\n    if (emailStatus.sent || emailStatus.error) {\n      const timer = setTimeout(() => {\n        setEmailStatus({\n          sent: false,\n          error: null\n        });\n      }, 5000);\n      return () => clearTimeout(timer);\n    }\n  }, [emailStatus]);\n\n  // Clear receipt scan data after processing\n  useEffect(() => {\n    if (receiptScanStatus.data && !receiptScanStatus.scanning) {\n      const timer = setTimeout(() => {\n        setReceiptScanStatus(prevState => ({\n          ...prevState,\n          data: null\n        }));\n      }, 30000); // Give user 30 seconds to review before clearing\n\n      return () => clearTimeout(timer);\n    }\n  }, [receiptScanStatus]);\n\n  // Add a new expense with validation\n  // Updated addExpense function for ExpenseContext.js\n  // Fix in ExpenseContext.js\n  const addExpense = async expense => {\n    if (!currentUser) {\n      console.error('Cannot add expense: No authenticated user');\n      return false;\n    }\n    try {\n      // Ensure expense has all required fields\n      const newExpense = {\n        category: expense.category || 'Other',\n        amount: parseFloat(expense.amount) || 0,\n        date: expense.date || new Date().toISOString().slice(0, 10),\n        description: expense.description || '',\n        userId: currentUser.uid,\n        // Make sure this is always set\n        createdAt: new Date().toISOString(),\n        // Additional fields\n        isSplit: expense.isSplit || false,\n        userShare: expense.userShare || parseFloat(expense.amount) || 0\n      };\n\n      // Log for debugging\n      console.log('Adding expense to Firestore:', newExpense);\n\n      // Add to Firestore with error handling\n      try {\n        const docRef = await addDoc(collection(db, 'expenses'), newExpense);\n        console.log('Expense added with ID:', docRef.id);\n        return docRef.id;\n      } catch (firestoreError) {\n        console.error('Firestore error adding expense:', firestoreError);\n        return false;\n      }\n    } catch (error) {\n      console.error('Error adding expense:', error);\n      return false;\n    }\n  };\n\n  // New function to handle receipt scanning\n  // In ExpenseContext.js\n  // In ExpenseContext.js - scanReceipt function\n  const scanReceipt = async imageFile => {\n    if (!currentUser) {\n      setReceiptScanStatus({\n        scanning: false,\n        error: 'User not logged in',\n        data: null\n      });\n      return {\n        success: false,\n        error: 'User not logged in'\n      };\n    }\n    if (!imageFile) {\n      setReceiptScanStatus({\n        scanning: false,\n        error: 'No image provided',\n        data: null\n      });\n      return {\n        success: false,\n        error: 'No image provided'\n      };\n    }\n    try {\n      // Set scanning status first\n      setReceiptScanStatus({\n        scanning: true,\n        error: null,\n        data: null\n      });\n      console.log('Processing receipt image:', imageFile.name);\n\n      // For now, skip the actual upload since we're having issues\n      // and just simulate a successful OCR result\n\n      // Generate a temporary URL for the uploaded image\n      const imageUrl = URL.createObjectURL(imageFile);\n\n      // Simulate processing time\n      await new Promise(resolve => setTimeout(resolve, 1500));\n\n      // Mock a successful response with extracted data\n      const extractedData = {\n        merchantName: \"Chinese Plate\",\n        amount: 79.66,\n        date: new Date().toISOString().slice(0, 10),\n        receiptNumber: `REC-${Math.floor(Math.random() * 10000)}`,\n        items: [\"Chinese Buffet\", \"Beverages\", \"Desserts\"],\n        confidence: 0.92,\n        taxAmount: 2.20,\n        currencyCode: 'USD',\n        imageUrl: imageUrl,\n        success: true\n      };\n      console.log('Receipt data extracted:', extractedData);\n\n      // Parse the data into the expected format\n      const parsedData = {\n        amount: extractedData.amount,\n        date: extractedData.date,\n        merchantName: extractedData.merchantName,\n        description: extractedData.merchantName,\n        category: \"Food\",\n        // Map to a valid category\n        items: extractedData.items,\n        receiptNumber: extractedData.receiptNumber,\n        taxAmount: extractedData.taxAmount,\n        imageUrl: extractedData.imageUrl,\n        confidence: extractedData.confidence\n      };\n\n      // Update the receipt scan status with the extracted data\n      setReceiptScanStatus({\n        scanning: false,\n        error: null,\n        data: {\n          amount: parsedData.amount,\n          description: parsedData.merchantName,\n          category: parsedData.category,\n          date: parsedData.date,\n          fromReceipt: true,\n          receiptImageUrl: parsedData.imageUrl,\n          notes: `Receipt from ${parsedData.merchantName}. Items: ${parsedData.items.join(', ')}`\n        }\n      });\n      console.log('Receipt scan completed successfully');\n      return {\n        success: true,\n        data: parsedData,\n        imageUrl: parsedData.imageUrl\n      };\n    } catch (error) {\n      console.error('Error scanning receipt:', error);\n      setReceiptScanStatus({\n        scanning: false,\n        error: error.message || 'Error scanning receipt',\n        data: null\n      });\n      return {\n        success: false,\n        error: error.message || 'Error scanning receipt'\n      };\n    }\n  };\n\n  // Function to add the expense from a scanned receipt\n  const addExpenseFromReceipt = async (expenseData, modifications = {}) => {\n    if (!currentUser) return false;\n    try {\n      // Combine scanned data with any user modifications\n      const finalExpenseData = {\n        ...expenseData,\n        ...modifications,\n        fromReceipt: true\n      };\n\n      // Use the existing addExpense function\n      const result = await addExpense(finalExpenseData);\n      if (result && finalExpenseData.receiptScanId) {\n        // Update the scan record status in Firestore\n        const scanRef = doc(db, 'receiptScans', String(finalExpenseData.receiptScanId));\n        await updateDoc(scanRef, {\n          status: 'applied'\n        });\n\n        // Clear the scanned data after successful addition\n        setReceiptScanStatus(prevState => ({\n          ...prevState,\n          data: null\n        }));\n      }\n      return result;\n    } catch (error) {\n      console.error('Error adding expense from receipt:', error);\n      return false;\n    }\n  };\n\n  // Function to reject a scanned receipt\n  const rejectScannedReceipt = async scanId => {\n    if (!scanId) return false;\n    try {\n      var _receiptScanStatus$da;\n      // Update the scan record status in Firestore\n      const scanRef = doc(db, 'receiptScans', String(scanId));\n      await updateDoc(scanRef, {\n        status: 'rejected'\n      });\n\n      // Clear any pending scan data with this ID\n      if (((_receiptScanStatus$da = receiptScanStatus.data) === null || _receiptScanStatus$da === void 0 ? void 0 : _receiptScanStatus$da.receiptScanId) === scanId) {\n        setReceiptScanStatus({\n          scanning: false,\n          error: null,\n          data: null\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error('Error rejecting scanned receipt:', error);\n      return false;\n    }\n  };\n\n  // Helper function to map vendor names to appropriate categories\n  const mapVendorToCategory = vendorName => {\n    const vendorNameLower = vendorName.toLowerCase();\n\n    // Simple mapping logic - can be expanded based on common vendors\n    if (!vendorName) return 'Other';\n    const categoryMappings = {\n      'restaurant': 'Food',\n      'café': 'Food',\n      'cafe': 'Food',\n      'grocery': 'Food',\n      'supermarket': 'Food',\n      'market': 'Food',\n      'gas': 'Transportation',\n      'fuel': 'Transportation',\n      'uber': 'Transportation',\n      'lyft': 'Transportation',\n      'taxi': 'Transportation',\n      'pharmacy': 'Healthcare',\n      'drug': 'Healthcare',\n      'doctor': 'Healthcare',\n      'clinic': 'Healthcare',\n      'hospital': 'Healthcare',\n      'rent': 'Housing',\n      'mortgage': 'Housing',\n      'netflix': 'Entertainment',\n      'spotify': 'Entertainment',\n      'cinema': 'Entertainment',\n      'movie': 'Entertainment',\n      'theater': 'Entertainment',\n      'amazon': 'Shopping',\n      'walmart': 'Shopping',\n      'target': 'Shopping',\n      'utility': 'Utilities',\n      'electric': 'Utilities',\n      'water': 'Utilities',\n      'gas bill': 'Utilities',\n      'phone': 'Utilities',\n      'internet': 'Utilities',\n      'school': 'Education',\n      'college': 'Education',\n      'university': 'Education',\n      'tuition': 'Education',\n      'book': 'Education',\n      'haircut': 'Personal Care',\n      'salon': 'Personal Care',\n      'spa': 'Personal Care',\n      'gym': 'Personal Care'\n    };\n    for (const [keyword, category] of Object.entries(categoryMappings)) {\n      if (vendorNameLower.includes(keyword)) {\n        return category;\n      }\n    }\n    return 'Other';\n  };\n\n  // Add a new income with validation\n  const addIncome = async income => {\n    if (!currentUser) {\n      console.error('Cannot add income: No authenticated user');\n      return false;\n    }\n    try {\n      console.log('Starting income creation with data:', income);\n\n      // Validate income data\n      if (!income.source) {\n        console.error('Missing source in income');\n        return false;\n      }\n      const amount = parseFloat(income.amount);\n      if (isNaN(amount) || amount <= 0) {\n        console.error('Invalid income amount:', income.amount);\n        return false;\n      }\n\n      // Create new income object with proper types and defaults\n      const newIncome = {\n        source: income.source,\n        amount: amount,\n        date: income.date || new Date().toISOString().slice(0, 10),\n        description: income.description || '',\n        userId: currentUser.uid,\n        createdAt: new Date().toISOString()\n      };\n      console.log('Formatted income object:', newIncome);\n\n      // Log the collection reference and ensure Firestore is connected\n      const incomesCollection = collection(db, 'incomes');\n      console.log('Incomes collection reference:', incomesCollection);\n\n      // Add to Firestore\n      console.log('Adding income to Firestore...');\n      const docRef = await addDoc(incomesCollection, newIncome);\n      console.log('Income added to Firestore, ID:', docRef.id);\n      return docRef.id;\n    } catch (error) {\n      console.error('Error adding income:', error);\n      console.error('Error code:', error.code);\n      console.error('Error message:', error.message);\n\n      // Check for specific Firebase errors\n      if (error.code === 'permission-denied') {\n        console.error('Firebase permission denied. Check Firestore rules.');\n      }\n      return false;\n    }\n  };\n\n  // Delete an expense\n  const deleteExpense = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      // Get the expense before deleting it (to check for receipt info)\n      const expenseRef = doc(db, 'expenses', id);\n      const expenseSnap = await getDoc(expenseRef);\n      if (expenseSnap.exists()) {\n        const expenseData = expenseSnap.data();\n\n        // Delete the expense document\n        await deleteDoc(expenseRef);\n\n        // If this was a receipt-based expense, update the scan record\n        if (expenseData.receiptScanId) {\n          const scanRef = doc(db, 'receiptScans', String(expenseData.receiptScanId));\n          const scanSnap = await getDoc(scanRef);\n          if (scanSnap.exists()) {\n            await updateDoc(scanRef, {\n              status: 'rejected'\n            });\n          }\n        }\n      } else {\n        // Document not found\n        console.error('Expense not found');\n        return false;\n      }\n      return true;\n    } catch (error) {\n      console.error('Error deleting expense:', error);\n      return false;\n    }\n  };\n\n  // Delete an income\n  const deleteIncome = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      await deleteDoc(doc(db, 'incomes', id));\n      return true;\n    } catch (error) {\n      console.error('Error deleting income:', error);\n      return false;\n    }\n  };\n\n  // Update budget settings\n  const updateBudget = async (category, amount) => {\n    if (!currentUser || !category || category.trim() === '' || isNaN(parseFloat(amount))) {\n      return false;\n    }\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        // Update existing budgets document\n        await updateDoc(budgetRef, {\n          [category]: parseFloat(amount)\n        });\n      } else {\n        // Create new budgets document\n        await setDoc(budgetRef, {\n          [category]: parseFloat(amount)\n        });\n      }\n\n      // Update local state\n      setBudgets(prevBudgets => ({\n        ...prevBudgets,\n        [category]: parseFloat(amount)\n      }));\n      return true;\n    } catch (error) {\n      console.error('Error updating budget:', error);\n      return false;\n    }\n  };\n\n  // Delete a budget\n  const deleteBudget = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n\n        // Remove the category from the budgets\n        if (currentBudgets[category] !== undefined) {\n          delete currentBudgets[category];\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error deleting budget:', error);\n      return false;\n    }\n  };\n\n  // Check if adding this expense exceeds the budget\n  const checkBudgetAlerts = async (newExpense, allExpenses = expenses) => {\n    if (!currentUser) return; // Don't process if no user is logged in\n    if (!newExpense || !newExpense.category) return;\n    const {\n      category\n    } = newExpense;\n\n    // Get budgets from Firestore\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (!budgetDoc.exists()) return;\n      const budgets = budgetDoc.data();\n\n      // Check if there's a budget for this category\n      if (budgets[category]) {\n        // Get current month expenses for this category\n        const currentDate = new Date();\n        const currentMonth = currentDate.getMonth();\n        const currentYear = currentDate.getFullYear();\n        const monthlyExpenses = allExpenses.filter(expense => {\n          if (!expense.date) return false;\n          try {\n            const expenseDate = new Date(expense.date);\n            return expenseDate.getMonth() === currentMonth && expenseDate.getFullYear() === currentYear && expense.category === category && expense.userId === currentUser.uid;\n          } catch (e) {\n            console.error('Invalid date format:', expense.date);\n            return false;\n          }\n        });\n        const totalSpent = monthlyExpenses.reduce((sum, expense) => {\n          const amount = parseFloat(expense.amount);\n          return sum + (isNaN(amount) ? 0 : amount);\n        }, 0);\n        const budgetAmount = parseFloat(budgets[category]);\n        if (!isNaN(budgetAmount) && totalSpent > budgetAmount) {\n          var _currentUser$preferen;\n          // Create new alert\n          const newAlert = {\n            message: `Budget alert: You've exceeded your ${category} budget of $${budgetAmount.toFixed(2)}`,\n            category: category,\n            read: false,\n            date: new Date().toISOString(),\n            userId: currentUser.uid\n          };\n\n          // Add to Firestore\n          const alertRef = await addDoc(collection(db, 'alerts'), newAlert);\n\n          // Send email alert if user has enabled email notifications\n          if ((currentUser === null || currentUser === void 0 ? void 0 : (_currentUser$preferen = currentUser.preferences) === null || _currentUser$preferen === void 0 ? void 0 : _currentUser$preferen.emailNotifications) !== false) {\n            if (currentUser.email) {\n              sendBudgetAlertEmail(currentUser, category, budgetAmount, totalSpent).then(result => {\n                setEmailStatus({\n                  sent: result.success,\n                  error: result.success ? null : result.message\n                });\n              }).catch(error => {\n                setEmailStatus({\n                  sent: false,\n                  error: error.message || 'Error sending email'\n                });\n              });\n            } else {\n              setEmailStatus({\n                sent: false,\n                error: \"No email address found for user\"\n              });\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error checking budget alerts:', error);\n    }\n  };\n\n  // Mark an alert as read\n  const markAlertAsRead = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      const alertRef = doc(db, 'alerts', id);\n      await updateDoc(alertRef, {\n        read: true\n      });\n      return true;\n    } catch (error) {\n      console.error('Error marking alert as read:', error);\n      return false;\n    }\n  };\n\n  // Delete an alert\n  const deleteAlert = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      await deleteDoc(doc(db, 'alerts', id));\n      return true;\n    } catch (error) {\n      console.error('Error deleting alert:', error);\n      return false;\n    }\n  };\n\n  // Add a new expense category\n  const addExpenseCategory = async category => {\n    if (!currentUser || !category || category.trim() === '') return false;\n    try {\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      let updatedCategories;\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n\n        // Check if category already exists\n        if (currentCategories.includes(category)) {\n          return false;\n        }\n        updatedCategories = [...currentCategories, category];\n      } else {\n        updatedCategories = [...DEFAULT_EXPENSE_CATEGORIES, category];\n      }\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setExpenseCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error adding expense category:', error);\n      return false;\n    }\n  };\n\n  // Delete an expense category\n  const deleteExpenseCategory = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      // Don't delete if there are expenses using this category\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('category', '==', category), limit(1));\n      const expensesSnap = await getDocs(expensesQuery);\n      if (!expensesSnap.empty) {\n        return {\n          success: false,\n          reason: 'Category in use by existing expenses'\n        };\n      }\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\n\n        // Update Firestore\n        await setDoc(categoriesRef, {\n          categories: updatedCategories\n        });\n\n        // Update local state\n        setExpenseCategories(updatedCategories);\n      }\n\n      // Also remove any budgets for this category\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n        if (currentBudgets[category] !== undefined) {\n          delete currentBudgets[category];\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error deleting expense category:', error);\n      return {\n        success: false,\n        reason: error.message\n      };\n    }\n  };\n\n  // Edit an expense category\n  const editExpenseCategory = async (oldCategory, newCategory) => {\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\n    try {\n      // Don't allow editing the \"Other\" category\n      if (oldCategory === 'Other') return false;\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (!categoriesDoc.exists()) return false;\n      const currentCategories = categoriesDoc.data().categories || [];\n\n      // Check if the new category name already exists\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\n\n      // Check if the category is in use\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('category', '==', oldCategory), limit(1));\n      const expensesSnap = await getDocs(expensesQuery);\n      if (!expensesSnap.empty) return false;\n\n      // Update categories\n      const updatedCategories = currentCategories.map(cat => cat === oldCategory ? newCategory : cat);\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setExpenseCategories(updatedCategories);\n\n      // Update any budget for this category\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n        if (currentBudgets[oldCategory] !== undefined) {\n          const budgetAmount = currentBudgets[oldCategory];\n          delete currentBudgets[oldCategory];\n          currentBudgets[newCategory] = budgetAmount;\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error editing expense category:', error);\n      return false;\n    }\n  };\n\n  // Add a new income category\n  const addIncomeCategory = async category => {\n    if (!currentUser || !category || category.trim() === '') return false;\n    try {\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      let updatedCategories;\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n\n        // Check if category already exists\n        if (currentCategories.includes(category)) {\n          return false;\n        }\n        updatedCategories = [...currentCategories, category];\n      } else {\n        updatedCategories = [...DEFAULT_INCOME_CATEGORIES, category];\n      }\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setIncomeCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error adding income category:', error);\n      return false;\n    }\n  };\n\n  // Delete an income category\n  const deleteIncomeCategory = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      // Don't delete if there are incomes using this category\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid), where('source', '==', category), limit(1));\n      const incomesSnap = await getDocs(incomesQuery);\n      if (!incomesSnap.empty) {\n        return {\n          success: false,\n          reason: 'Category in use by existing incomes'\n        };\n      }\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\n\n        // Update Firestore\n        await setDoc(categoriesRef, {\n          categories: updatedCategories\n        });\n\n        // Update local state\n        setIncomeCategories(updatedCategories);\n      }\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error deleting income category:', error);\n      return {\n        success: false,\n        reason: error.message\n      };\n    }\n  };\n\n  // Edit an income category\n  const editIncomeCategory = async (oldCategory, newCategory) => {\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\n    try {\n      // Don't allow editing the \"Other\" category\n      if (oldCategory === 'Other') return false;\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (!categoriesDoc.exists()) return false;\n      const currentCategories = categoriesDoc.data().categories || [];\n\n      // Check if the new category name already exists\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\n\n      // Check if the category is in use\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid), where('source', '==', oldCategory), limit(1));\n      const incomesSnap = await getDocs(incomesQuery);\n      if (!incomesSnap.empty) return false;\n\n      // Update categories\n      const updatedCategories = currentCategories.map(cat => cat === oldCategory ? newCategory : cat);\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setIncomeCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error editing income category:', error);\n      return false;\n    }\n  };\n\n  // Get expenses for a specific month\n  const getMonthlyExpenses = (month, year) => {\n    if (!currentUser) return [];\n    const targetDate = new Date(year, month);\n    const targetMonth = targetDate.getMonth();\n    const targetYear = targetDate.getFullYear();\n    return expenses.filter(expense => {\n      if (!expense.date) return false;\n      try {\n        const expenseDate = new Date(expense.date);\n        return expenseDate.getMonth() === targetMonth && expenseDate.getFullYear() === targetYear && expense.userId === currentUser.uid;\n      } catch (e) {\n        return false;\n      }\n    });\n  };\n\n  // Get incomes for a specific month\n  const getMonthlyIncomes = (month, year) => {\n    if (!currentUser) return [];\n    const targetDate = new Date(year, month);\n    const targetMonth = targetDate.getMonth();\n    const targetYear = targetDate.getFullYear();\n    return incomes.filter(income => {\n      if (!income.date) return false;\n      try {\n        const incomeDate = new Date(income.date);\n        return incomeDate.getMonth() === targetMonth && incomeDate.getFullYear() === targetYear && income.userId === currentUser.uid;\n      } catch (e) {\n        return false;\n      }\n    });\n  };\n\n  // Get historical receipt scans\n  const getReceiptScans = async () => {\n    if (!currentUser) return [];\n    try {\n      const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n      const scansSnap = await getDocs(scansQuery);\n      return scansSnap.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error getting receipt scans:', error);\n      return [];\n    }\n  };\n\n  // Update an existing expense\n  const updateExpense = async (id, updatedData) => {\n    if (!currentUser || !id) return false;\n    try {\n      const expenseRef = doc(db, 'expenses', id);\n      await updateDoc(expenseRef, updatedData);\n      return true;\n    } catch (error) {\n      console.error('Error updating expense:', error);\n      return false;\n    }\n  };\n\n  // Update an existing income\n  const updateIncome = async (id, updatedData) => {\n    if (!currentUser || !id) return false;\n    try {\n      const incomeRef = doc(db, 'incomes', id);\n      await updateDoc(incomeRef, updatedData);\n      return true;\n    } catch (error) {\n      console.error('Error updating income:', error);\n      return false;\n    }\n  };\n\n  // Export data for backups\n  const exportData = async () => {\n    if (!currentUser) return null;\n    try {\n      // Get all current user data\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid));\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid));\n      const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n      const [expensesSnap, incomesSnap, scansSnap, categoriesSnap, budgetsSnap] = await Promise.all([getDocs(expensesQuery), getDocs(incomesQuery), getDocs(scansQuery), getDoc(doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories')), getDoc(doc(db, 'users', currentUser.uid, 'settings', 'budgets'))]);\n      const exportData = {\n        expenses: expensesSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        incomes: incomesSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        receiptScans: scansSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        expenseCategories: categoriesSnap.exists() ? categoriesSnap.data().categories : DEFAULT_EXPENSE_CATEGORIES,\n        incomeCategories: incomeCategories,\n        budgets: budgetsSnap.exists() ? budgetsSnap.data() : {},\n        exportDate: new Date().toISOString(),\n        userId: currentUser.uid\n      };\n      return exportData;\n    } catch (error) {\n      console.error('Error exporting data:', error);\n      return null;\n    }\n  };\n\n  // Import data from backups\n  const importData = async data => {\n    if (!currentUser || !data) return false;\n    try {\n      // Validate data structure\n      if (!data.expenses || !data.incomes || !data.budgets || !data.expenseCategories || !data.incomeCategories) {\n        console.error('Invalid import data structure');\n        return false;\n      }\n\n      // Begin batch operations\n      const batch = db.batch();\n\n      // Update expense categories\n      const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      batch.set(expenseCategoriesRef, {\n        categories: data.expenseCategories\n      });\n\n      // Update income categories\n      const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      batch.set(incomeCategoriesRef, {\n        categories: data.incomeCategories\n      });\n\n      // Update budgets\n      const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      batch.set(budgetsRef, data.budgets);\n\n      // Commit the batch\n      await batch.commit();\n\n      // Update local state\n      setExpenseCategories(data.expenseCategories);\n      setIncomeCategories(data.incomeCategories);\n      setBudgets(data.budgets);\n\n      // Handle expense and income imports separately (may be too many for a single batch)\n      for (const expense of data.expenses) {\n        try {\n          const {\n            id,\n            ...expenseData\n          } = expense;\n          expenseData.userId = currentUser.uid; // Ensure correct user ID\n          await addDoc(collection(db, 'expenses'), expenseData);\n        } catch (e) {\n          console.error('Error importing expense:', e);\n          // Continue with other imports\n        }\n      }\n      for (const income of data.incomes) {\n        try {\n          const {\n            id,\n            ...incomeData\n          } = income;\n          incomeData.userId = currentUser.uid; // Ensure correct user ID\n          await addDoc(collection(db, 'incomes'), incomeData);\n        } catch (e) {\n          console.error('Error importing income:', e);\n          // Continue with other imports\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error importing data:', error);\n      return false;\n    }\n  };\n\n  // Get spending insights\n  const getSpendingInsights = async (months = 3) => {\n    if (!currentUser || months < 1) return null;\n    try {\n      const currentDate = new Date();\n      const insights = {\n        topCategories: [],\n        monthlyTotals: [],\n        yearlyComparison: {},\n        receiptUsage: {\n          total: 0,\n          percentage: 0\n        }\n      };\n\n      // Get relevant expenses from Firestore\n      const startDate = new Date();\n      startDate.setMonth(startDate.getMonth() - months);\n\n      // Format for Firestore query\n      const startDateString = startDate.toISOString();\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('date', '>=', startDateString));\n      const expensesSnap = await getDocs(expensesQuery);\n      const relevantExpenses = expensesSnap.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n\n      // Calculate top spending categories\n      const categoryTotals = {};\n      relevantExpenses.forEach(expense => {\n        const {\n          category,\n          amount\n        } = expense;\n        if (!category) return;\n        categoryTotals[category] = (categoryTotals[category] || 0) + parseFloat(amount || 0);\n      });\n      insights.topCategories = Object.entries(categoryTotals).map(([category, total]) => ({\n        category,\n        total\n      })).sort((a, b) => b.total - a.total).slice(0, 5); // Get top 5\n\n      // Calculate monthly totals\n      const monthlyData = {};\n      relevantExpenses.forEach(expense => {\n        if (!expense.date) return;\n        const expenseDate = new Date(expense.date);\n        const monthYear = `${expenseDate.getFullYear()}-${expenseDate.getMonth() + 1}`;\n        if (!monthlyData[monthYear]) {\n          monthlyData[monthYear] = {\n            month: expenseDate.getMonth(),\n            year: expenseDate.getFullYear(),\n            total: 0,\n            label: expenseDate.toLocaleString('default', {\n              month: 'short',\n              year: 'numeric'\n            })\n          };\n        }\n        monthlyData[monthYear].total += parseFloat(expense.amount || 0);\n      });\n      insights.monthlyTotals = Object.values(monthlyData).sort((a, b) => {\n        if (a.year !== b.year) return a.year - b.year;\n        return a.month - b.month;\n      });\n\n      // Calculate receipt usage statistics\n      const receiptsCount = relevantExpenses.filter(expense => expense.fromReceipt).length;\n      insights.receiptUsage = {\n        total: receiptsCount,\n        percentage: relevantExpenses.length > 0 ? receiptsCount / relevantExpenses.length * 100 : 0\n      };\n      return insights;\n    } catch (error) {\n      console.error('Error generating spending insights:', error);\n      return null;\n    }\n  };\n\n  // Load categories and other settings from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setExpenseCategories([]);\n      setIncomeCategories([]);\n      setBudgets({});\n      return;\n    }\n\n    // Load categories and budgets\n    const fetchSettings = async () => {\n      try {\n        // Get expense categories\n        const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n        const expenseCategoriesDoc = await getDoc(expenseCategoriesRef);\n        if (expenseCategoriesDoc.exists()) {\n          setExpenseCategories(expenseCategoriesDoc.data().categories || DEFAULT_EXPENSE_CATEGORIES);\n        } else {\n          // Create default categories if none exist\n          await setDoc(expenseCategoriesRef, {\n            categories: DEFAULT_EXPENSE_CATEGORIES\n          });\n          setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\n        }\n\n        // Get income categories\n        const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n        const incomeCategoriesDoc = await getDoc(incomeCategoriesRef);\n        if (incomeCategoriesDoc.exists()) {\n          setIncomeCategories(incomeCategoriesDoc.data().categories || DEFAULT_INCOME_CATEGORIES);\n        } else {\n          // Create default categories if none exist\n          await setDoc(incomeCategoriesRef, {\n            categories: DEFAULT_INCOME_CATEGORIES\n          });\n          setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\n        }\n\n        // Get budgets\n        const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n        const budgetsDoc = await getDoc(budgetsRef);\n        if (budgetsDoc.exists()) {\n          setBudgets(budgetsDoc.data());\n        }\n      } catch (error) {\n        console.error('Error loading settings:', error);\n        setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\n        setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\n      }\n    };\n    fetchSettings();\n  }, [currentUser]);\n\n  // Load alerts from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setAlerts([]);\n      return;\n    }\n\n    // Query Firestore for alerts\n    const alertsQuery = query(collection(db, 'alerts'), where('userId', '==', currentUser.uid), where('read', '==', false));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(alertsQuery, snapshot => {\n      const alertsList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setAlerts(alertsList);\n    }, error => {\n      console.error(\"Error getting alerts:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Load receipt scans from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setReceiptScans([]);\n      return;\n    }\n\n    // Query Firestore for receipt scans\n    const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(scansQuery, snapshot => {\n      const scansList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setReceiptScans(scansList);\n    }, error => {\n      console.error(\"Error getting receipt scans:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n  return /*#__PURE__*/_jsxDEV(ExpenseContext.Provider, {\n    value: {\n      expenses,\n      incomes,\n      budgets,\n      alerts,\n      expenseCategories,\n      incomeCategories,\n      receiptScanStatus,\n      receiptScans,\n      emailStatus,\n      loading,\n      addExpense,\n      addIncome,\n      deleteExpense,\n      deleteIncome,\n      updateExpense,\n      updateIncome,\n      updateBudget,\n      deleteBudget,\n      markAlertAsRead,\n      deleteAlert,\n      addExpenseCategory,\n      deleteExpenseCategory,\n      editExpenseCategory,\n      addIncomeCategory,\n      deleteIncomeCategory,\n      editIncomeCategory,\n      scanReceipt,\n      addExpenseFromReceipt,\n      rejectScannedReceipt,\n      getMonthlyExpenses,\n      getMonthlyIncomes,\n      getReceiptScans,\n      exportData,\n      importData,\n      getSpendingInsights\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1399,\n    columnNumber: 5\n  }, this);\n};\n_s(ExpenseProvider, \"jN6mlIMGqoim1aOMvmQUTdySb1Y=\");\n_c = ExpenseProvider;\nvar _c;\n$RefreshReg$(_c, \"ExpenseProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","AuthContext","sendBudgetAlertEmail","scanReceiptImage","parseReceiptData","db","storage","collection","addDoc","doc","deleteDoc","updateDoc","query","where","getDocs","onSnapshot","getDoc","setDoc","limit","ref","uploadBytes","getDownloadURL","jsxDEV","_jsxDEV","ExpenseContext","ExpenseProvider","children","_s","expenses","setExpenses","incomes","setIncomes","budgets","setBudgets","alerts","setAlerts","loading","setLoading","emailStatus","setEmailStatus","sent","error","expenseCategories","setExpenseCategories","incomeCategories","setIncomeCategories","receiptScanStatus","setReceiptScanStatus","scanning","data","receiptScans","setReceiptScans","currentUser","DEFAULT_EXPENSE_CATEGORIES","DEFAULT_INCOME_CATEGORIES","expensesQuery","uid","unsubscribe","snapshot","expensesList","docs","map","id","console","incomesQuery","incomesList","timer","setTimeout","clearTimeout","prevState","addExpense","expense","newExpense","category","amount","parseFloat","date","Date","toISOString","slice","description","userId","createdAt","isSplit","userShare","log","docRef","firestoreError","scanReceipt","imageFile","success","name","imageUrl","URL","createObjectURL","Promise","resolve","extractedData","merchantName","receiptNumber","Math","floor","random","items","confidence","taxAmount","currencyCode","parsedData","fromReceipt","receiptImageUrl","notes","join","message","addExpenseFromReceipt","expenseData","modifications","finalExpenseData","result","receiptScanId","scanRef","String","status","rejectScannedReceipt","scanId","_receiptScanStatus$da","mapVendorToCategory","vendorName","vendorNameLower","toLowerCase","categoryMappings","keyword","Object","entries","includes","addIncome","income","source","isNaN","newIncome","incomesCollection","code","deleteExpense","expenseRef","expenseSnap","exists","scanSnap","deleteIncome","updateBudget","trim","budgetRef","budgetDoc","prevBudgets","deleteBudget","currentBudgets","undefined","checkBudgetAlerts","allExpenses","currentDate","currentMonth","getMonth","currentYear","getFullYear","monthlyExpenses","filter","expenseDate","e","totalSpent","reduce","sum","budgetAmount","_currentUser$preferen","newAlert","toFixed","read","alertRef","preferences","emailNotifications","email","then","catch","markAlertAsRead","deleteAlert","addExpenseCategory","categoriesRef","categoriesDoc","updatedCategories","currentCategories","categories","deleteExpenseCategory","expensesSnap","empty","reason","cat","editExpenseCategory","oldCategory","newCategory","addIncomeCategory","deleteIncomeCategory","incomesSnap","editIncomeCategory","getMonthlyExpenses","month","year","targetDate","targetMonth","targetYear","getMonthlyIncomes","incomeDate","getReceiptScans","scansQuery","scansSnap","updateExpense","updatedData","updateIncome","incomeRef","exportData","categoriesSnap","budgetsSnap","all","exportDate","importData","batch","expenseCategoriesRef","set","incomeCategoriesRef","budgetsRef","commit","incomeData","getSpendingInsights","months","insights","topCategories","monthlyTotals","yearlyComparison","receiptUsage","total","percentage","startDate","setMonth","startDateString","relevantExpenses","categoryTotals","forEach","sort","a","b","monthlyData","monthYear","label","toLocaleString","values","receiptsCount","length","fetchSettings","expenseCategoriesDoc","incomeCategoriesDoc","budgetsDoc","alertsQuery","alertsList","scansList","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/tejit/OneDrive/Desktop/expence tracker final/expence-tracker/src/context/ExpenseContext.js"],"sourcesContent":["// src/context/ExpenseContext.js\r\nimport React, { createContext, useState, useEffect, useContext } from 'react';\r\nimport { AuthContext } from './AuthContext';\r\nimport { sendBudgetAlertEmail } from '../services/EmailService';\r\nimport { scanReceiptImage, parseReceiptData } from '../services/ReceiptScanningService';\r\n// Add Firebase imports\r\nimport { db, storage } from '../config/firebase';\r\nimport { \r\n  collection, \r\n  addDoc, \r\n  doc, \r\n  deleteDoc, \r\n  updateDoc, \r\n  query, \r\n  where, \r\n  getDocs, \r\n  onSnapshot, \r\n  getDoc,\r\n  setDoc,\r\n  limit \r\n} from 'firebase/firestore';\r\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\r\n\r\nexport const ExpenseContext = createContext();\r\n\r\nexport const ExpenseProvider = ({ children }) => {\r\n  const [expenses, setExpenses] = useState([]);\r\n  const [incomes, setIncomes] = useState([]);\r\n  const [budgets, setBudgets] = useState({});\r\n  const [alerts, setAlerts] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [emailStatus, setEmailStatus] = useState({ sent: false, error: null });\r\n  const [expenseCategories, setExpenseCategories] = useState([]);\r\n  const [incomeCategories, setIncomeCategories] = useState([]);\r\n  // Add new state for receipt scanning\r\n  const [receiptScanStatus, setReceiptScanStatus] = useState({ \r\n    scanning: false, \r\n    error: null, \r\n    data: null \r\n  });\r\n  // Track receipt scan history\r\n  const [receiptScans, setReceiptScans] = useState([]);\r\n  \r\n  const { currentUser } = useContext(AuthContext);\r\n  \r\n  // Default categories if none are found\r\n  const DEFAULT_EXPENSE_CATEGORIES = [\r\n    'Food', 'Housing', 'Transportation', 'Entertainment', \r\n    'Utilities', 'Healthcare', 'Shopping', 'Personal Care', 'Education', 'Other'\r\n  ];\r\n  \r\n  const DEFAULT_INCOME_CATEGORIES = [\r\n    'Salary', 'Freelance', 'Investment', 'Gift', \r\n    'Business', 'Side Hustle', 'Rental', 'Other'\r\n  ];\r\n  \r\n  // Load expenses from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setExpenses([]);\r\n      setLoading(false);\r\n      return;\r\n    }\r\n    \r\n    setLoading(true);\r\n    \r\n    // Query Firestore for expenses\r\n    const expensesQuery = query(\r\n      collection(db, 'expenses'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(expensesQuery, (snapshot) => {\r\n      const expensesList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setExpenses(expensesList);\r\n      setLoading(false);\r\n    }, (error) => {\r\n      console.error(\"Error getting expenses:\", error);\r\n      setLoading(false);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Load incomes from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setIncomes([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for incomes\r\n    const incomesQuery = query(\r\n      collection(db, 'incomes'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(incomesQuery, (snapshot) => {\r\n      const incomesList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setIncomes(incomesList);\r\n    }, (error) => {\r\n      console.error(\"Error getting incomes:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Clear email status after some time\r\n  useEffect(() => {\r\n    if (emailStatus.sent || emailStatus.error) {\r\n      const timer = setTimeout(() => {\r\n        setEmailStatus({ sent: false, error: null });\r\n      }, 5000);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [emailStatus]);\r\n  \r\n  // Clear receipt scan data after processing\r\n  useEffect(() => {\r\n    if (receiptScanStatus.data && !receiptScanStatus.scanning) {\r\n      const timer = setTimeout(() => {\r\n        setReceiptScanStatus(prevState => ({\r\n          ...prevState, \r\n          data: null\r\n        }));\r\n      }, 30000); // Give user 30 seconds to review before clearing\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [receiptScanStatus]);\r\n  \r\n  // Add a new expense with validation\r\n  // Updated addExpense function for ExpenseContext.js\r\n  // Fix in ExpenseContext.js\r\n  const addExpense = async (expense) => {\r\n    if (!currentUser) {\r\n      console.error('Cannot add expense: No authenticated user');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      // Ensure expense has all required fields\r\n      const newExpense = {\r\n        category: expense.category || 'Other',\r\n        amount: parseFloat(expense.amount) || 0,\r\n        date: expense.date || new Date().toISOString().slice(0, 10),\r\n        description: expense.description || '',\r\n        userId: currentUser.uid, // Make sure this is always set\r\n        createdAt: new Date().toISOString(),\r\n        // Additional fields\r\n        isSplit: expense.isSplit || false,\r\n        userShare: expense.userShare || parseFloat(expense.amount) || 0,\r\n      };\r\n      \r\n      // Log for debugging\r\n      console.log('Adding expense to Firestore:', newExpense);\r\n      \r\n      // Add to Firestore with error handling\r\n      try {\r\n        const docRef = await addDoc(collection(db, 'expenses'), newExpense);\r\n        console.log('Expense added with ID:', docRef.id);\r\n        return docRef.id;\r\n      } catch (firestoreError) {\r\n        console.error('Firestore error adding expense:', firestoreError);\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error adding expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // New function to handle receipt scanning\r\n  // In ExpenseContext.js\r\n  // In ExpenseContext.js - scanReceipt function\r\n  const scanReceipt = async (imageFile) => {\r\n    if (!currentUser) {\r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: 'User not logged in',\r\n        data: null\r\n      });\r\n      return { success: false, error: 'User not logged in' };\r\n    }\r\n    \r\n    if (!imageFile) {\r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: 'No image provided',\r\n        data: null\r\n      });\r\n      return { success: false, error: 'No image provided' };\r\n    }\r\n    \r\n    try {\r\n      // Set scanning status first\r\n      setReceiptScanStatus({\r\n        scanning: true,\r\n        error: null,\r\n        data: null\r\n      });\r\n      \r\n      console.log('Processing receipt image:', imageFile.name);\r\n      \r\n      // For now, skip the actual upload since we're having issues\r\n      // and just simulate a successful OCR result\r\n      \r\n      // Generate a temporary URL for the uploaded image\r\n      const imageUrl = URL.createObjectURL(imageFile);\r\n      \r\n      // Simulate processing time\r\n      await new Promise(resolve => setTimeout(resolve, 1500));\r\n      \r\n      // Mock a successful response with extracted data\r\n      const extractedData = {\r\n        merchantName: \"Chinese Plate\",\r\n        amount: 79.66,\r\n        date: new Date().toISOString().slice(0, 10),\r\n        receiptNumber: `REC-${Math.floor(Math.random() * 10000)}`,\r\n        items: [\"Chinese Buffet\", \"Beverages\", \"Desserts\"],\r\n        confidence: 0.92,\r\n        taxAmount: 2.20,\r\n        currencyCode: 'USD',\r\n        imageUrl: imageUrl,\r\n        success: true\r\n      };\r\n      \r\n      console.log('Receipt data extracted:', extractedData);\r\n      \r\n      // Parse the data into the expected format\r\n      const parsedData = {\r\n        amount: extractedData.amount,\r\n        date: extractedData.date,\r\n        merchantName: extractedData.merchantName,\r\n        description: extractedData.merchantName,\r\n        category: \"Food\", // Map to a valid category\r\n        items: extractedData.items,\r\n        receiptNumber: extractedData.receiptNumber,\r\n        taxAmount: extractedData.taxAmount,\r\n        imageUrl: extractedData.imageUrl,\r\n        confidence: extractedData.confidence\r\n      };\r\n      \r\n      // Update the receipt scan status with the extracted data\r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: null,\r\n        data: {\r\n          amount: parsedData.amount,\r\n          description: parsedData.merchantName,\r\n          category: parsedData.category,\r\n          date: parsedData.date,\r\n          fromReceipt: true,\r\n          receiptImageUrl: parsedData.imageUrl,\r\n          notes: `Receipt from ${parsedData.merchantName}. Items: ${parsedData.items.join(', ')}`\r\n        }\r\n      });\r\n      \r\n      console.log('Receipt scan completed successfully');\r\n      \r\n      return {\r\n        success: true,\r\n        data: parsedData,\r\n        imageUrl: parsedData.imageUrl\r\n      };\r\n    } catch (error) {\r\n      console.error('Error scanning receipt:', error);\r\n      \r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: error.message || 'Error scanning receipt',\r\n        data: null\r\n      });\r\n      \r\n      return {\r\n        success: false,\r\n        error: error.message || 'Error scanning receipt'\r\n      };\r\n    }\r\n  };\r\n  \r\n  // Function to add the expense from a scanned receipt\r\n  const addExpenseFromReceipt = async (expenseData, modifications = {}) => {\r\n    if (!currentUser) return false;\r\n    \r\n    try {\r\n      // Combine scanned data with any user modifications\r\n      const finalExpenseData = {\r\n        ...expenseData,\r\n        ...modifications,\r\n        fromReceipt: true\r\n      };\r\n      \r\n      // Use the existing addExpense function\r\n      const result = await addExpense(finalExpenseData);\r\n      \r\n      if (result && finalExpenseData.receiptScanId) {\r\n        // Update the scan record status in Firestore\r\n        const scanRef = doc(db, 'receiptScans', String(finalExpenseData.receiptScanId));\r\n        await updateDoc(scanRef, { status: 'applied' });\r\n        \r\n        // Clear the scanned data after successful addition\r\n        setReceiptScanStatus(prevState => ({\r\n          ...prevState,\r\n          data: null\r\n        }));\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('Error adding expense from receipt:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Function to reject a scanned receipt\r\n  const rejectScannedReceipt = async (scanId) => {\r\n    if (!scanId) return false;\r\n    \r\n    try {\r\n      // Update the scan record status in Firestore\r\n      const scanRef = doc(db, 'receiptScans', String(scanId));\r\n      await updateDoc(scanRef, { status: 'rejected' });\r\n      \r\n      // Clear any pending scan data with this ID\r\n      if (receiptScanStatus.data?.receiptScanId === scanId) {\r\n        setReceiptScanStatus({\r\n          scanning: false,\r\n          error: null,\r\n          data: null\r\n        });\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error rejecting scanned receipt:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Helper function to map vendor names to appropriate categories\r\n  const mapVendorToCategory = (vendorName) => {\r\n    const vendorNameLower = vendorName.toLowerCase();\r\n    \r\n    // Simple mapping logic - can be expanded based on common vendors\r\n    if (!vendorName) return 'Other';\r\n    \r\n    const categoryMappings = {\r\n      'restaurant': 'Food',\r\n      'café': 'Food',\r\n      'cafe': 'Food',\r\n      'grocery': 'Food',\r\n      'supermarket': 'Food',\r\n      'market': 'Food',\r\n      'gas': 'Transportation',\r\n      'fuel': 'Transportation',\r\n      'uber': 'Transportation',\r\n      'lyft': 'Transportation',\r\n      'taxi': 'Transportation',\r\n      'pharmacy': 'Healthcare',\r\n      'drug': 'Healthcare',\r\n      'doctor': 'Healthcare',\r\n      'clinic': 'Healthcare',\r\n      'hospital': 'Healthcare',\r\n      'rent': 'Housing',\r\n      'mortgage': 'Housing',\r\n      'netflix': 'Entertainment',\r\n      'spotify': 'Entertainment',\r\n      'cinema': 'Entertainment',\r\n      'movie': 'Entertainment',\r\n      'theater': 'Entertainment',\r\n      'amazon': 'Shopping',\r\n      'walmart': 'Shopping',\r\n      'target': 'Shopping',\r\n      'utility': 'Utilities',\r\n      'electric': 'Utilities',\r\n      'water': 'Utilities',\r\n      'gas bill': 'Utilities',\r\n      'phone': 'Utilities',\r\n      'internet': 'Utilities',\r\n      'school': 'Education',\r\n      'college': 'Education',\r\n      'university': 'Education',\r\n      'tuition': 'Education',\r\n      'book': 'Education',\r\n      'haircut': 'Personal Care',\r\n      'salon': 'Personal Care',\r\n      'spa': 'Personal Care',\r\n      'gym': 'Personal Care'\r\n    };\r\n    \r\n    for (const [keyword, category] of Object.entries(categoryMappings)) {\r\n      if (vendorNameLower.includes(keyword)) {\r\n        return category;\r\n      }\r\n    }\r\n    \r\n    return 'Other';\r\n  };\r\n  \r\n  // Add a new income with validation\r\n  const addIncome = async (income) => {\r\n    if (!currentUser) {\r\n      console.error('Cannot add income: No authenticated user');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      console.log('Starting income creation with data:', income);\r\n      \r\n      // Validate income data\r\n      if (!income.source) {\r\n        console.error('Missing source in income');\r\n        return false;\r\n      }\r\n      \r\n      const amount = parseFloat(income.amount);\r\n      if (isNaN(amount) || amount <= 0) {\r\n        console.error('Invalid income amount:', income.amount);\r\n        return false;\r\n      }\r\n      \r\n      // Create new income object with proper types and defaults\r\n      const newIncome = {\r\n        source: income.source,\r\n        amount: amount,\r\n        date: income.date || new Date().toISOString().slice(0, 10),\r\n        description: income.description || '',\r\n        userId: currentUser.uid,\r\n        createdAt: new Date().toISOString()\r\n      };\r\n      \r\n      console.log('Formatted income object:', newIncome);\r\n      \r\n      // Log the collection reference and ensure Firestore is connected\r\n      const incomesCollection = collection(db, 'incomes');\r\n      console.log('Incomes collection reference:', incomesCollection);\r\n      \r\n      // Add to Firestore\r\n      console.log('Adding income to Firestore...');\r\n      const docRef = await addDoc(incomesCollection, newIncome);\r\n      console.log('Income added to Firestore, ID:', docRef.id);\r\n      \r\n      return docRef.id;\r\n    } catch (error) {\r\n      console.error('Error adding income:', error);\r\n      console.error('Error code:', error.code);\r\n      console.error('Error message:', error.message);\r\n      \r\n      // Check for specific Firebase errors\r\n      if (error.code === 'permission-denied') {\r\n        console.error('Firebase permission denied. Check Firestore rules.');\r\n      } \r\n      \r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an expense\r\n  const deleteExpense = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      // Get the expense before deleting it (to check for receipt info)\r\n      const expenseRef = doc(db, 'expenses', id);\r\n      const expenseSnap = await getDoc(expenseRef);\r\n      \r\n      if (expenseSnap.exists()) {\r\n        const expenseData = expenseSnap.data();\r\n        \r\n        // Delete the expense document\r\n        await deleteDoc(expenseRef);\r\n        \r\n        // If this was a receipt-based expense, update the scan record\r\n        if (expenseData.receiptScanId) {\r\n          const scanRef = doc(db, 'receiptScans', String(expenseData.receiptScanId));\r\n          const scanSnap = await getDoc(scanRef);\r\n          \r\n          if (scanSnap.exists()) {\r\n            await updateDoc(scanRef, { status: 'rejected' });\r\n          }\r\n        }\r\n      } else {\r\n        // Document not found\r\n        console.error('Expense not found');\r\n        return false;\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an income\r\n  const deleteIncome = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      await deleteDoc(doc(db, 'incomes', id));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting income:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Update budget settings\r\n  const updateBudget = async (category, amount) => {\r\n    if (!currentUser || !category || category.trim() === '' || isNaN(parseFloat(amount))) {\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        // Update existing budgets document\r\n        await updateDoc(budgetRef, {\r\n          [category]: parseFloat(amount)\r\n        });\r\n      } else {\r\n        // Create new budgets document\r\n        await setDoc(budgetRef, {\r\n          [category]: parseFloat(amount)\r\n        });\r\n      }\r\n      \r\n      // Update local state\r\n      setBudgets(prevBudgets => ({\r\n        ...prevBudgets,\r\n        [category]: parseFloat(amount)\r\n      }));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating budget:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete a budget\r\n  const deleteBudget = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        // Remove the category from the budgets\r\n        if (currentBudgets[category] !== undefined) {\r\n          delete currentBudgets[category];\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting budget:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Check if adding this expense exceeds the budget\r\n  const checkBudgetAlerts = async (newExpense, allExpenses = expenses) => {\r\n    if (!currentUser) return; // Don't process if no user is logged in\r\n    if (!newExpense || !newExpense.category) return;\r\n    \r\n    const { category } = newExpense;\r\n    \r\n    // Get budgets from Firestore\r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (!budgetDoc.exists()) return;\r\n      \r\n      const budgets = budgetDoc.data();\r\n      \r\n      // Check if there's a budget for this category\r\n      if (budgets[category]) {\r\n        // Get current month expenses for this category\r\n        const currentDate = new Date();\r\n        const currentMonth = currentDate.getMonth();\r\n        const currentYear = currentDate.getFullYear();\r\n        \r\n        const monthlyExpenses = allExpenses.filter(expense => {\r\n          if (!expense.date) return false;\r\n          \r\n          try {\r\n            const expenseDate = new Date(expense.date);\r\n            return expenseDate.getMonth() === currentMonth && \r\n                  expenseDate.getFullYear() === currentYear &&\r\n                  expense.category === category &&\r\n                  expense.userId === currentUser.uid;\r\n          } catch (e) {\r\n            console.error('Invalid date format:', expense.date);\r\n            return false;\r\n          }\r\n        });\r\n        \r\n        const totalSpent = monthlyExpenses.reduce((sum, expense) => {\r\n          const amount = parseFloat(expense.amount);\r\n          return sum + (isNaN(amount) ? 0 : amount);\r\n        }, 0);\r\n        \r\n        const budgetAmount = parseFloat(budgets[category]);\r\n        \r\n        if (!isNaN(budgetAmount) && totalSpent > budgetAmount) {\r\n          // Create new alert\r\n          const newAlert = {\r\n            message: `Budget alert: You've exceeded your ${category} budget of $${budgetAmount.toFixed(2)}`,\r\n            category: category,\r\n            read: false,\r\n            date: new Date().toISOString(),\r\n            userId: currentUser.uid\r\n          };\r\n          \r\n          // Add to Firestore\r\n          const alertRef = await addDoc(collection(db, 'alerts'), newAlert);\r\n          \r\n          // Send email alert if user has enabled email notifications\r\n          if (currentUser?.preferences?.emailNotifications !== false) {\r\n            if (currentUser.email) {\r\n              sendBudgetAlertEmail(\r\n                currentUser,\r\n                category,\r\n                budgetAmount,\r\n                totalSpent\r\n              ).then(result => {\r\n                setEmailStatus({ \r\n                  sent: result.success, \r\n                  error: result.success ? null : result.message \r\n                });\r\n              }).catch(error => {\r\n                setEmailStatus({ \r\n                  sent: false, \r\n                  error: error.message || 'Error sending email'\r\n                });\r\n              });\r\n            } else {\r\n              setEmailStatus({ \r\n                sent: false, \r\n                error: \"No email address found for user\"\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error checking budget alerts:', error);\r\n    }\r\n  };\r\n  \r\n  // Mark an alert as read\r\n  const markAlertAsRead = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const alertRef = doc(db, 'alerts', id);\r\n      await updateDoc(alertRef, { read: true });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error marking alert as read:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an alert\r\n  const deleteAlert = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      await deleteDoc(doc(db, 'alerts', id));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting alert:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Add a new expense category\r\n  const addExpenseCategory = async (category) => {\r\n    if (!currentUser || !category || category.trim() === '') return false;\r\n    \r\n    try {\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      let updatedCategories;\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        \r\n        // Check if category already exists\r\n        if (currentCategories.includes(category)) {\r\n          return false;\r\n        }\r\n        \r\n        updatedCategories = [...currentCategories, category];\r\n      } else {\r\n        updatedCategories = [...DEFAULT_EXPENSE_CATEGORIES, category];\r\n      }\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setExpenseCategories(updatedCategories);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error adding expense category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an expense category\r\n  const deleteExpenseCategory = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      // Don't delete if there are expenses using this category\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('category', '==', category),\r\n        limit(1)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      if (!expensesSnap.empty) {\r\n        return { success: false, reason: 'Category in use by existing expenses' };\r\n      }\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\r\n        \r\n        // Update Firestore\r\n        await setDoc(categoriesRef, { categories: updatedCategories });\r\n        \r\n        // Update local state\r\n        setExpenseCategories(updatedCategories);\r\n      }\r\n      \r\n      // Also remove any budgets for this category\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        if (currentBudgets[category] !== undefined) {\r\n          delete currentBudgets[category];\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Error deleting expense category:', error);\r\n      return { success: false, reason: error.message };\r\n    }\r\n  };\r\n  \r\n  // Edit an expense category\r\n  const editExpenseCategory = async (oldCategory, newCategory) => {\r\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\r\n    \r\n    try {\r\n      // Don't allow editing the \"Other\" category\r\n      if (oldCategory === 'Other') return false;\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (!categoriesDoc.exists()) return false;\r\n      \r\n      const currentCategories = categoriesDoc.data().categories || [];\r\n      \r\n      // Check if the new category name already exists\r\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\r\n      \r\n      // Check if the category is in use\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('category', '==', oldCategory),\r\n        limit(1)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      if (!expensesSnap.empty) return false;\r\n      \r\n      // Update categories\r\n      const updatedCategories = currentCategories.map(cat => \r\n        cat === oldCategory ? newCategory : cat\r\n      );\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setExpenseCategories(updatedCategories);\r\n      \r\n      // Update any budget for this category\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        if (currentBudgets[oldCategory] !== undefined) {\r\n          const budgetAmount = currentBudgets[oldCategory];\r\n          delete currentBudgets[oldCategory];\r\n          currentBudgets[newCategory] = budgetAmount;\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error editing expense category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Add a new income category\r\n  const addIncomeCategory = async (category) => {\r\n    if (!currentUser || !category || category.trim() === '') return false;\r\n    \r\n    try {\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      let updatedCategories;\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        \r\n        // Check if category already exists\r\n        if (currentCategories.includes(category)) {\r\n          return false;\r\n        }\r\n        \r\n        updatedCategories = [...currentCategories, category];\r\n      } else {\r\n        updatedCategories = [...DEFAULT_INCOME_CATEGORIES, category];\r\n      }\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setIncomeCategories(updatedCategories);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error adding income category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an income category\r\n  const deleteIncomeCategory = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      // Don't delete if there are incomes using this category\r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('source', '==', category),\r\n        limit(1)\r\n      );\r\n      \r\n      const incomesSnap = await getDocs(incomesQuery);\r\n      \r\n      if (!incomesSnap.empty) {\r\n        return { success: false, reason: 'Category in use by existing incomes' };\r\n      }\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\r\n        \r\n        // Update Firestore\r\n        await setDoc(categoriesRef, { categories: updatedCategories });\r\n        \r\n        // Update local state\r\n        setIncomeCategories(updatedCategories);\r\n      }\r\n      \r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Error deleting income category:', error);\r\n      return { success: false, reason: error.message };\r\n    }\r\n  };\r\n  \r\n  // Edit an income category\r\n  const editIncomeCategory = async (oldCategory, newCategory) => {\r\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\r\n    \r\n    try {\r\n      // Don't allow editing the \"Other\" category\r\n      if (oldCategory === 'Other') return false;\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (!categoriesDoc.exists()) return false;\r\n      \r\n      const currentCategories = categoriesDoc.data().categories || [];\r\n      \r\n      // Check if the new category name already exists\r\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\r\n      \r\n      // Check if the category is in use\r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('source', '==', oldCategory),\r\n        limit(1)\r\n      );\r\n      \r\n      const incomesSnap = await getDocs(incomesQuery);\r\n      \r\n      if (!incomesSnap.empty) return false;\r\n      \r\n      // Update categories\r\n      const updatedCategories = currentCategories.map(cat => \r\n        cat === oldCategory ? newCategory : cat\r\n      );\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setIncomeCategories(updatedCategories);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error editing income category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Get expenses for a specific month\r\n  const getMonthlyExpenses = (month, year) => {\r\n    if (!currentUser) return [];\r\n    \r\n    const targetDate = new Date(year, month);\r\n    const targetMonth = targetDate.getMonth();\r\n    const targetYear = targetDate.getFullYear();\r\n    \r\n    return expenses.filter(expense => {\r\n      if (!expense.date) return false;\r\n      \r\n      try {\r\n        const expenseDate = new Date(expense.date);\r\n        return expenseDate.getMonth() === targetMonth && \r\n              expenseDate.getFullYear() === targetYear &&\r\n              expense.userId === currentUser.uid;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    });\r\n  };\r\n  \r\n  // Get incomes for a specific month\r\n  const getMonthlyIncomes = (month, year) => {\r\n    if (!currentUser) return [];\r\n    \r\n    const targetDate = new Date(year, month);\r\n    const targetMonth = targetDate.getMonth();\r\n    const targetYear = targetDate.getFullYear();\r\n    \r\n    return incomes.filter(income => {\r\n      if (!income.date) return false;\r\n      \r\n      try {\r\n        const incomeDate = new Date(income.date);\r\n        return incomeDate.getMonth() === targetMonth && \r\n              incomeDate.getFullYear() === targetYear &&\r\n              income.userId === currentUser.uid;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    });\r\n  };\r\n  \r\n  // Get historical receipt scans\r\n  const getReceiptScans = async () => {\r\n    if (!currentUser) return [];\r\n    \r\n    try {\r\n      const scansQuery = query(\r\n        collection(db, 'receiptScans'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const scansSnap = await getDocs(scansQuery);\r\n      \r\n      return scansSnap.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error getting receipt scans:', error);\r\n      return [];\r\n    }\r\n  };\r\n  \r\n  // Update an existing expense\r\n  const updateExpense = async (id, updatedData) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const expenseRef = doc(db, 'expenses', id);\r\n      await updateDoc(expenseRef, updatedData);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Update an existing income\r\n  const updateIncome = async (id, updatedData) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const incomeRef = doc(db, 'incomes', id);\r\n      await updateDoc(incomeRef, updatedData);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating income:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Export data for backups\r\n  const exportData = async () => {\r\n    if (!currentUser) return null;\r\n    \r\n    try {\r\n      // Get all current user data\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const scansQuery = query(\r\n        collection(db, 'receiptScans'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const [expensesSnap, incomesSnap, scansSnap, categoriesSnap, budgetsSnap] = await Promise.all([\r\n        getDocs(expensesQuery),\r\n        getDocs(incomesQuery),\r\n        getDocs(scansQuery),\r\n        getDoc(doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories')),\r\n        getDoc(doc(db, 'users', currentUser.uid, 'settings', 'budgets'))\r\n      ]);\r\n      \r\n      const exportData = {\r\n        expenses: expensesSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        incomes: incomesSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        receiptScans: scansSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        expenseCategories: categoriesSnap.exists() ? categoriesSnap.data().categories : DEFAULT_EXPENSE_CATEGORIES,\r\n        incomeCategories: incomeCategories,\r\n        budgets: budgetsSnap.exists() ? budgetsSnap.data() : {},\r\n        exportDate: new Date().toISOString(),\r\n        userId: currentUser.uid\r\n      };\r\n      \r\n      return exportData;\r\n    } catch (error) {\r\n      console.error('Error exporting data:', error);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  // Import data from backups\r\n  const importData = async (data) => {\r\n    if (!currentUser || !data) return false;\r\n    \r\n    try {\r\n      // Validate data structure\r\n      if (!data.expenses || !data.incomes || !data.budgets || \r\n          !data.expenseCategories || !data.incomeCategories) {\r\n        console.error('Invalid import data structure');\r\n        return false;\r\n      }\r\n      \r\n      // Begin batch operations\r\n      const batch = db.batch();\r\n      \r\n      // Update expense categories\r\n      const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      batch.set(expenseCategoriesRef, { categories: data.expenseCategories });\r\n      \r\n      // Update income categories\r\n      const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      batch.set(incomeCategoriesRef, { categories: data.incomeCategories });\r\n      \r\n      // Update budgets\r\n      const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      batch.set(budgetsRef, data.budgets);\r\n      \r\n      // Commit the batch\r\n      await batch.commit();\r\n      \r\n      // Update local state\r\n      setExpenseCategories(data.expenseCategories);\r\n      setIncomeCategories(data.incomeCategories);\r\n      setBudgets(data.budgets);\r\n      \r\n      // Handle expense and income imports separately (may be too many for a single batch)\r\n      for (const expense of data.expenses) {\r\n        try {\r\n          const { id, ...expenseData } = expense;\r\n          expenseData.userId = currentUser.uid; // Ensure correct user ID\r\n          await addDoc(collection(db, 'expenses'), expenseData);\r\n        } catch (e) {\r\n          console.error('Error importing expense:', e);\r\n          // Continue with other imports\r\n        }\r\n      }\r\n      \r\n      for (const income of data.incomes) {\r\n        try {\r\n          const { id, ...incomeData } = income;\r\n          incomeData.userId = currentUser.uid; // Ensure correct user ID\r\n          await addDoc(collection(db, 'incomes'), incomeData);\r\n        } catch (e) {\r\n          console.error('Error importing income:', e);\r\n          // Continue with other imports\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error importing data:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Get spending insights\r\n  const getSpendingInsights = async (months = 3) => {\r\n    if (!currentUser || months < 1) return null;\r\n    \r\n    try {\r\n      const currentDate = new Date();\r\n      const insights = {\r\n        topCategories: [],\r\n        monthlyTotals: [],\r\n        yearlyComparison: {},\r\n        receiptUsage: {\r\n          total: 0,\r\n          percentage: 0\r\n        }\r\n      };\r\n      \r\n      // Get relevant expenses from Firestore\r\n      const startDate = new Date();\r\n      startDate.setMonth(startDate.getMonth() - months);\r\n      \r\n      // Format for Firestore query\r\n      const startDateString = startDate.toISOString();\r\n      \r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('date', '>=', startDateString)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      const relevantExpenses = expensesSnap.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      \r\n      // Calculate top spending categories\r\n      const categoryTotals = {};\r\n      relevantExpenses.forEach(expense => {\r\n        const { category, amount } = expense;\r\n        if (!category) return;\r\n        \r\n        categoryTotals[category] = (categoryTotals[category] || 0) + parseFloat(amount || 0);\r\n      });\r\n      \r\n      insights.topCategories = Object.entries(categoryTotals)\r\n        .map(([category, total]) => ({ category, total }))\r\n        .sort((a, b) => b.total - a.total)\r\n        .slice(0, 5); // Get top 5\r\n      \r\n      // Calculate monthly totals\r\n      const monthlyData = {};\r\n      relevantExpenses.forEach(expense => {\r\n        if (!expense.date) return;\r\n        \r\n        const expenseDate = new Date(expense.date);\r\n        const monthYear = `${expenseDate.getFullYear()}-${expenseDate.getMonth()+1}`;\r\n        \r\n        if (!monthlyData[monthYear]) {\r\n          monthlyData[monthYear] = {\r\n            month: expenseDate.getMonth(),\r\n            year: expenseDate.getFullYear(),\r\n            total: 0,\r\n            label: expenseDate.toLocaleString('default', { month: 'short', year: 'numeric' })\r\n          };\r\n        }\r\n        \r\n        monthlyData[monthYear].total += parseFloat(expense.amount || 0);\r\n      });\r\n      \r\n      insights.monthlyTotals = Object.values(monthlyData)\r\n        .sort((a, b) => {\r\n          if (a.year !== b.year) return a.year - b.year;\r\n          return a.month - b.month;\r\n        });\r\n      \r\n      // Calculate receipt usage statistics\r\n      const receiptsCount = relevantExpenses.filter(expense => expense.fromReceipt).length;\r\n      insights.receiptUsage = {\r\n        total: receiptsCount,\r\n        percentage: relevantExpenses.length > 0 \r\n          ? (receiptsCount / relevantExpenses.length) * 100 \r\n          : 0\r\n      };\r\n      \r\n      return insights;\r\n    } catch (error) {\r\n      console.error('Error generating spending insights:', error);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  // Load categories and other settings from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setExpenseCategories([]);\r\n      setIncomeCategories([]);\r\n      setBudgets({});\r\n      return;\r\n    }\r\n    \r\n    // Load categories and budgets\r\n    const fetchSettings = async () => {\r\n      try {\r\n        // Get expense categories\r\n        const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n        const expenseCategoriesDoc = await getDoc(expenseCategoriesRef);\r\n        \r\n        if (expenseCategoriesDoc.exists()) {\r\n          setExpenseCategories(expenseCategoriesDoc.data().categories || DEFAULT_EXPENSE_CATEGORIES);\r\n        } else {\r\n          // Create default categories if none exist\r\n          await setDoc(expenseCategoriesRef, {\r\n            categories: DEFAULT_EXPENSE_CATEGORIES\r\n          });\r\n          setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\r\n        }\r\n        \r\n        // Get income categories\r\n        const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n        const incomeCategoriesDoc = await getDoc(incomeCategoriesRef);\r\n        \r\n        if (incomeCategoriesDoc.exists()) {\r\n          setIncomeCategories(incomeCategoriesDoc.data().categories || DEFAULT_INCOME_CATEGORIES);\r\n        } else {\r\n          // Create default categories if none exist\r\n          await setDoc(incomeCategoriesRef, {\r\n            categories: DEFAULT_INCOME_CATEGORIES\r\n          });\r\n          setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\r\n        }\r\n        \r\n        // Get budgets\r\n        const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n        const budgetsDoc = await getDoc(budgetsRef);\r\n        \r\n        if (budgetsDoc.exists()) {\r\n          setBudgets(budgetsDoc.data());\r\n        }\r\n      } catch (error) {\r\n        console.error('Error loading settings:', error);\r\n        setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\r\n        setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\r\n      }\r\n    };\r\n    \r\n    fetchSettings();\r\n  }, [currentUser]);\r\n  \r\n  // Load alerts from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setAlerts([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for alerts\r\n    const alertsQuery = query(\r\n      collection(db, 'alerts'),\r\n      where('userId', '==', currentUser.uid),\r\n      where('read', '==', false)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(alertsQuery, (snapshot) => {\r\n      const alertsList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setAlerts(alertsList);\r\n    }, (error) => {\r\n      console.error(\"Error getting alerts:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Load receipt scans from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setReceiptScans([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for receipt scans\r\n    const scansQuery = query(\r\n      collection(db, 'receiptScans'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(scansQuery, (snapshot) => {\r\n      const scansList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setReceiptScans(scansList);\r\n    }, (error) => {\r\n      console.error(\"Error getting receipt scans:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  return (\r\n    <ExpenseContext.Provider value={{\r\n      expenses,\r\n      incomes,\r\n      budgets,\r\n      alerts,\r\n      expenseCategories,\r\n      incomeCategories,\r\n      receiptScanStatus,\r\n      receiptScans,\r\n      emailStatus,\r\n      loading,\r\n      addExpense,\r\n      addIncome,\r\n      deleteExpense,\r\n      deleteIncome,\r\n      updateExpense,\r\n      updateIncome,\r\n      updateBudget,\r\n      deleteBudget,\r\n      markAlertAsRead,\r\n      deleteAlert,\r\n      addExpenseCategory,\r\n      deleteExpenseCategory,\r\n      editExpenseCategory,\r\n      addIncomeCategory,\r\n      deleteIncomeCategory,\r\n      editIncomeCategory,\r\n      scanReceipt,\r\n      addExpenseFromReceipt,\r\n      rejectScannedReceipt,\r\n      getMonthlyExpenses,\r\n      getMonthlyIncomes,\r\n      getReceiptScans,\r\n      exportData,\r\n      importData,\r\n      getSpendingInsights\r\n    }}>\r\n      {children}\r\n    </ExpenseContext.Provider>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}