{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\tejit\\\\OneDrive\\\\Desktop\\\\expence tracker final\\\\expence-tracker\\\\src\\\\context\\\\SplitExpenseContext.js\",\n  _s = $RefreshSig$();\n// src/context/SplitExpenseContext.js\nimport React, { createContext, useState, useEffect, useContext } from 'react';\nimport { AuthContext } from './AuthContext';\nimport { ExpenseContext } from './ExpenseContext';\nimport { createSplitExpense, createParticipant, updateParticipantStatus, calculateSplitStatus } from '../models/SplitExpenseModel';\nimport { sendSplitExpenseEmail } from '../services/EmailService';\n// Add Firebase imports\nimport { db } from '../config/firebase';\nimport { collection, addDoc, doc, deleteDoc, updateDoc, query, where, getDocs, onSnapshot, getDoc, setDoc } from 'firebase/firestore';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const SplitExpenseContext = /*#__PURE__*/createContext();\nexport const SplitExpenseProvider = ({\n  children\n}) => {\n  _s();\n  const [splitExpenses, setSplitExpenses] = useState([]);\n  const [contacts, setContacts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [emailStatus, setEmailStatus] = useState({});\n  const {\n    currentUser\n  } = useContext(AuthContext);\n  const {\n    addExpense\n  } = useContext(ExpenseContext);\n\n  // Load data from Firestore when component mounts or user changes\n  useEffect(() => {\n    if (!currentUser) {\n      setSplitExpenses([]);\n      setContacts([]);\n      setLoading(false);\n      return;\n    }\n    setLoading(true);\n\n    // Query Firestore for split expenses\n    const splitExpensesQuery = query(collection(db, 'splitExpenses'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener for split expenses\n    const unsubscribe = onSnapshot(splitExpensesQuery, snapshot => {\n      try {\n        const splitExpensesList = snapshot.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        }));\n        setSplitExpenses(splitExpensesList);\n      } catch (error) {\n        console.error(\"Error processing split expenses data:\", error);\n        setSplitExpenses([]);\n      }\n\n      // After loading split expenses, load contacts\n      loadContacts();\n    }, error => {\n      console.error(\"Error getting split expenses:\", error.code, error.message);\n      setLoading(false);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Function to load contacts from Firestore\n  const loadContacts = async () => {\n    if (!currentUser) return;\n    try {\n      const contactsQuery = query(collection(db, 'contacts'), where('userId', '==', currentUser.uid));\n      const contactsSnapshot = await getDocs(contactsQuery);\n      const contactsList = contactsSnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setContacts(contactsList);\n    } catch (error) {\n      console.error('Error loading contacts:', error.code, error.message);\n      setContacts([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  /**\r\n   * Create a new split expense\r\n   * @param {Object} expenseData - Expense data (amount, category, etc.)\r\n   * @param {Array} participants - Array of participants\r\n   * @returns {Object} New split expense or null if failed\r\n   */\n  const createNewSplitExpense = async (expenseData, participants) => {\n    if (!currentUser) return null;\n    try {\n      // Find the creator's participant object to determine their share\n      const creatorParticipant = participants.find(p => p.email === currentUser.email || p.name === currentUser.name);\n\n      // If creator isn't found in participants, use the first participant as a fallback\n      const userShare = (creatorParticipant === null || creatorParticipant === void 0 ? void 0 : creatorParticipant.shareAmount) || (participants.length > 0 ? participants[0].shareAmount : 0);\n\n      // First create the base expense with proper split expense attribution\n      const expenseResult = await addExpense({\n        ...expenseData,\n        // Mark this as a split expense\n        isSplit: true,\n        // Add the current user's share for proper budget calculations\n        userShare: userShare,\n        // Add the number of participants\n        participantCount: participants.length,\n        // Add a descriptive note\n        notes: expenseData.notes || `Split with ${participants.length} people`\n      });\n      if (!expenseResult) {\n        throw new Error('Failed to create base expense');\n      }\n\n      // Create the split expense object\n      const newSplitExpense = createSplitExpense({\n        ...expenseData,\n        // The addExpense function returns the ID, but we need the full object\n        id: expenseResult\n      }, participants);\n\n      // Add to Firestore\n      const splitExpenseData = {\n        ...newSplitExpense,\n        userId: currentUser.uid,\n        createdAt: new Date().toISOString()\n      };\n      const docRef = await addDoc(collection(db, 'splitExpenses'), splitExpenseData);\n\n      // Add the Firestore document ID\n      const splitExpenseWithId = {\n        ...splitExpenseData,\n        id: docRef.id\n      };\n\n      // Add any new contacts to Firestore\n      const existingContactEmails = contacts.map(c => c.email).filter(Boolean);\n      for (const participant of participants) {\n        if (participant.email && !existingContactEmails.includes(participant.email)) {\n          await addDoc(collection(db, 'contacts'), {\n            name: participant.name,\n            email: participant.email,\n            userId: currentUser.uid,\n            createdAt: new Date().toISOString()\n          });\n        }\n      }\n\n      // Send email notifications to participants (except the creator)\n      const otherParticipants = participants.filter(p => p.email && p.email !== currentUser.email);\n      if (otherParticipants.length > 0) {\n        console.log(`Sending split expense notifications to ${otherParticipants.length} participants`);\n\n        // Create a queue to send emails sequentially to avoid rate limits\n        const sendEmailQueue = async () => {\n          for (let i = 0; i < otherParticipants.length; i++) {\n            const participant = otherParticipants[i];\n            try {\n              // Track email status\n              setEmailStatus(prev => ({\n                ...prev,\n                [participant.id]: {\n                  sending: true\n                }\n              }));\n\n              // Send the email with minimal parameters\n              const result = await sendSplitExpenseEmail(participant, splitExpenseWithId, currentUser);\n              console.log(`Email result for ${participant.name}:`, result);\n\n              // Update email status\n              setEmailStatus(prev => ({\n                ...prev,\n                [participant.id]: {\n                  sent: result.success,\n                  error: result.success ? null : result.message\n                }\n              }));\n\n              // Wait a bit between emails to avoid rate limiting\n              if (i < otherParticipants.length - 1) {\n                await new Promise(resolve => setTimeout(resolve, 1000));\n              }\n            } catch (error) {\n              console.error(`Failed to send split email to ${participant.name}:`, error);\n\n              // Update email status with error\n              setEmailStatus(prev => ({\n                ...prev,\n                [participant.id]: {\n                  sent: false,\n                  error: error.message || 'Unknown error'\n                }\n              }));\n\n              // Continue with the next participant even if this one fails\n              await new Promise(resolve => setTimeout(resolve, 500));\n            }\n          }\n\n          // Clear email status after all emails have been processed (plus a buffer)\n          setTimeout(() => {\n            setEmailStatus({});\n          }, 10000);\n        };\n\n        // Start the email queue\n        sendEmailQueue();\n      }\n      return splitExpenseWithId;\n    } catch (error) {\n      console.error('Error creating split expense:', error.code, error.message);\n      return null;\n    }\n  };\n\n  /**\r\n   * Get a split expense by ID\r\n   * @param {string|number} id - Split expense ID\r\n   * @returns {Object} Split expense or null if not found\r\n   */\n  const getSplitExpense = id => {\n    return splitExpenses.find(expense => expense.id === id) || null;\n  };\n\n  /**\r\n   * Update a participant's payment status\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @param {string} status - New status (paid, unpaid, declined)\r\n   * @param {string} paymentMethod - Method of payment\r\n   * @returns {boolean} Success status\r\n   */\n  const updatePaymentStatus = async (splitExpenseId, participantId, status, paymentMethod) => {\n    if (!currentUser) return false;\n    try {\n      // Find the split expense\n      const splitExpense = splitExpenses.find(expense => expense.id === splitExpenseId);\n      if (!splitExpense) return false;\n\n      // Update the participant\n      const updatedParticipants = splitExpense.participants.map(participant => {\n        if (participant.id !== participantId) return participant;\n        return updateParticipantStatus(participant, status, paymentMethod);\n      });\n\n      // Recalculate the overall status\n      const updatedStatus = calculateSplitStatus({\n        ...splitExpense,\n        participants: updatedParticipants\n      });\n\n      // Update in Firestore\n      const splitExpenseRef = doc(db, 'splitExpenses', splitExpenseId);\n      await updateDoc(splitExpenseRef, {\n        participants: updatedParticipants,\n        status: updatedStatus,\n        updatedAt: new Date().toISOString()\n      });\n      return true;\n    } catch (error) {\n      console.error('Error updating payment status:', error.code, error.message);\n      return false;\n    }\n  };\n\n  /**\r\n   * Add a new contact\r\n   * @param {string} name - Contact name\r\n   * @param {string} email - Contact email\r\n   * @returns {Object} New contact or null if failed\r\n   */\n  const addContact = async (name, email) => {\n    if (!currentUser || !name.trim()) return null;\n    try {\n      // Check if contact with this email already exists\n      if (email) {\n        const existingContactsQuery = query(collection(db, 'contacts'), where('userId', '==', currentUser.uid), where('email', '==', email.trim()));\n        const existingContacts = await getDocs(existingContactsQuery);\n        if (!existingContacts.empty) {\n          return null; // Contact already exists\n        }\n      }\n\n      // Create new contact object\n      const newContactData = {\n        name: name.trim(),\n        email: (email === null || email === void 0 ? void 0 : email.trim()) || '',\n        userId: currentUser.uid,\n        createdAt: new Date().toISOString()\n      };\n\n      // Add to Firestore\n      const docRef = await addDoc(collection(db, 'contacts'), newContactData);\n      const newContact = {\n        ...newContactData,\n        id: docRef.id\n      };\n      return newContact;\n    } catch (error) {\n      console.error('Error adding contact:', error.code, error.message);\n      return null;\n    }\n  };\n\n  /**\r\n   * Delete a contact\r\n   * @param {string} contactId - Contact ID\r\n   * @returns {boolean} Success status\r\n   */\n  const deleteContact = async contactId => {\n    if (!currentUser) return false;\n    try {\n      // Delete from Firestore\n      await deleteDoc(doc(db, 'contacts', contactId));\n      return true;\n    } catch (error) {\n      console.error('Error deleting contact:', error.code, error.message);\n      return false;\n    }\n  };\n\n  /**\r\n   * Get all split expenses\r\n   * @returns {Array} Array of split expenses\r\n   */\n  const getAllSplitExpenses = () => {\n    return splitExpenses;\n  };\n\n  /**\r\n   * Get all contacts\r\n   * @returns {Array} Array of contacts\r\n   */\n  const getAllContacts = () => {\n    return contacts;\n  };\n\n  /**\r\n   * Delete a split expense\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @returns {boolean} Success status\r\n   */\n  const deleteSplitExpense = async splitExpenseId => {\n    if (!currentUser) return false;\n    try {\n      // Delete from Firestore\n      await deleteDoc(doc(db, 'splitExpenses', splitExpenseId));\n      return true;\n    } catch (error) {\n      console.error('Error deleting split expense:', error.code, error.message);\n      return false;\n    }\n  };\n\n  /**\r\n   * Remind a participant to pay\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @returns {boolean} Success status\r\n   */\n  const sendPaymentReminder = async (splitExpenseId, participantId) => {\n    try {\n      const splitExpense = getSplitExpense(splitExpenseId);\n      if (!splitExpense) return false;\n      const participant = splitExpense.participants.find(p => p.id === participantId);\n      if (!participant || !participant.email) return false;\n\n      // Set status to sending\n      setEmailStatus(prev => ({\n        ...prev,\n        [participantId]: {\n          sending: true\n        }\n      }));\n\n      // Create complete email parameters\n      const emailParams = {\n        to_email: participant.email,\n        to_name: participant.name || 'Participant',\n        creator_name: currentUser.name || 'Group member',\n        expense_description: splitExpense.description || 'Split expense',\n        expense_category: splitExpense.category || 'Uncategorized',\n        expense_date: new Date(splitExpense.date || new Date()).toLocaleDateString(),\n        expense_amount: splitExpense.totalAmount.toFixed(2),\n        share_amount: participant.shareAmount.toFixed(2),\n        is_reminder: true,\n        reminder_message: `This is a friendly reminder that your payment of $${participant.shareAmount.toFixed(2)} for \"${splitExpense.description}\" is still pending.`,\n        // Essential parameters for EmailJS template\n        name: currentUser.name || 'FinTrack',\n        email: currentUser.email || '',\n        reply_to: currentUser.email || '',\n        subject: `Payment Reminder: ${splitExpense.description || 'Split expense'}`\n      };\n      try {\n        // Send reminder email with explicit error handling\n        const result = await sendSplitExpenseEmail(participant, splitExpense, currentUser, true, emailParams);\n        console.log(`Reminder email result for ${participant.name}:`, result);\n\n        // Update email status\n        setEmailStatus(prev => ({\n          ...prev,\n          [participantId]: {\n            sent: result.success,\n            error: result.success ? null : result.message\n          }\n        }));\n\n        // Log reminder in Firestore\n        if (result.success) {\n          const reminderLog = {\n            splitExpenseId,\n            participantId,\n            timestamp: new Date().toISOString(),\n            userId: currentUser.uid,\n            success: true\n          };\n          await addDoc(collection(db, 'reminderLogs'), reminderLog);\n        }\n      } catch (error) {\n        console.error(`Failed to send reminder email to ${participant.name}:`, error);\n\n        // Update email status with error\n        setEmailStatus(prev => ({\n          ...prev,\n          [participantId]: {\n            sent: false,\n            error: error.message || 'Failed to send email'\n          }\n        }));\n      }\n\n      // Clear status after some time\n      setTimeout(() => {\n        setEmailStatus(prev => {\n          const newStatus = {\n            ...prev\n          };\n          delete newStatus[participantId];\n          return newStatus;\n        });\n      }, 10000);\n      return true;\n    } catch (error) {\n      console.error('Error sending payment reminder:', error.code, error.message);\n\n      // Make sure the sending status is cleared if there's an error\n      setEmailStatus(prev => ({\n        ...prev,\n        [participantId]: {\n          sent: false,\n          error: error.message || 'Unknown error occurred'\n        }\n      }));\n      return false;\n    }\n  };\n\n  /**\r\n   * Create a participant from a contact\r\n   * @param {Object} contact - Contact object\r\n   * @returns {Object} Participant object\r\n   */\n  const createParticipantFromContact = contact => {\n    return createParticipant(contact.name, contact.email);\n  };\n\n  /**\r\n   * Get the email status for a participant\r\n   * @param {string} participantId - Participant ID\r\n   * @returns {Object} Email status object or null\r\n   */\n  const getEmailStatus = participantId => {\n    return emailStatus[participantId] || null;\n  };\n  return /*#__PURE__*/_jsxDEV(SplitExpenseContext.Provider, {\n    value: {\n      loading,\n      createNewSplitExpense,\n      getSplitExpense,\n      updatePaymentStatus,\n      addContact,\n      deleteContact,\n      getAllSplitExpenses,\n      getAllContacts,\n      deleteSplitExpense,\n      sendPaymentReminder,\n      createParticipant,\n      createParticipantFromContact,\n      emailStatus,\n      getEmailStatus\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 538,\n    columnNumber: 5\n  }, this);\n};\n_s(SplitExpenseProvider, \"pgg9QacgraqPaGkP56UAW662QoU=\");\n_c = SplitExpenseProvider;\nexport default SplitExpenseContext;\nvar _c;\n$RefreshReg$(_c, \"SplitExpenseProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","AuthContext","ExpenseContext","createSplitExpense","createParticipant","updateParticipantStatus","calculateSplitStatus","sendSplitExpenseEmail","db","collection","addDoc","doc","deleteDoc","updateDoc","query","where","getDocs","onSnapshot","getDoc","setDoc","jsxDEV","_jsxDEV","SplitExpenseContext","SplitExpenseProvider","children","_s","splitExpenses","setSplitExpenses","contacts","setContacts","loading","setLoading","emailStatus","setEmailStatus","currentUser","addExpense","splitExpensesQuery","uid","unsubscribe","snapshot","splitExpensesList","docs","map","id","data","error","console","loadContacts","code","message","contactsQuery","contactsSnapshot","contactsList","createNewSplitExpense","expenseData","participants","creatorParticipant","find","p","email","name","userShare","shareAmount","length","expenseResult","isSplit","participantCount","notes","Error","newSplitExpense","splitExpenseData","userId","createdAt","Date","toISOString","docRef","splitExpenseWithId","existingContactEmails","c","filter","Boolean","participant","includes","otherParticipants","log","sendEmailQueue","i","prev","sending","result","sent","success","Promise","resolve","setTimeout","getSplitExpense","expense","updatePaymentStatus","splitExpenseId","participantId","status","paymentMethod","splitExpense","updatedParticipants","updatedStatus","splitExpenseRef","updatedAt","addContact","trim","existingContactsQuery","existingContacts","empty","newContactData","newContact","deleteContact","contactId","getAllSplitExpenses","getAllContacts","deleteSplitExpense","sendPaymentReminder","emailParams","to_email","to_name","creator_name","expense_description","description","expense_category","category","expense_date","date","toLocaleDateString","expense_amount","totalAmount","toFixed","share_amount","is_reminder","reminder_message","reply_to","subject","reminderLog","timestamp","newStatus","createParticipantFromContact","contact","getEmailStatus","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/tejit/OneDrive/Desktop/expence tracker final/expence-tracker/src/context/SplitExpenseContext.js"],"sourcesContent":["// src/context/SplitExpenseContext.js\r\nimport React, { createContext, useState, useEffect, useContext } from 'react';\r\nimport { AuthContext } from './AuthContext';\r\nimport { ExpenseContext } from './ExpenseContext';\r\nimport { \r\n  createSplitExpense, \r\n  createParticipant, \r\n  updateParticipantStatus, \r\n  calculateSplitStatus \r\n} from '../models/SplitExpenseModel';\r\nimport { sendSplitExpenseEmail } from '../services/EmailService';\r\n// Add Firebase imports\r\nimport { db } from '../config/firebase';\r\nimport { \r\n  collection, \r\n  addDoc, \r\n  doc, \r\n  deleteDoc, \r\n  updateDoc, \r\n  query, \r\n  where, \r\n  getDocs, \r\n  onSnapshot, \r\n  getDoc,\r\n  setDoc\r\n} from 'firebase/firestore';\r\n\r\nexport const SplitExpenseContext = createContext();\r\n\r\nexport const SplitExpenseProvider = ({ children }) => {\r\n  const [splitExpenses, setSplitExpenses] = useState([]);\r\n  const [contacts, setContacts] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [emailStatus, setEmailStatus] = useState({});\r\n  \r\n  const { currentUser } = useContext(AuthContext);\r\n  const { addExpense } = useContext(ExpenseContext);\r\n  \r\n  // Load data from Firestore when component mounts or user changes\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setSplitExpenses([]);\r\n      setContacts([]);\r\n      setLoading(false);\r\n      return;\r\n    }\r\n    \r\n    setLoading(true);\r\n    \r\n    // Query Firestore for split expenses\r\n    const splitExpensesQuery = query(\r\n      collection(db, 'splitExpenses'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener for split expenses\r\n    const unsubscribe = onSnapshot(splitExpensesQuery, (snapshot) => {\r\n      try {\r\n        const splitExpensesList = snapshot.docs.map(doc => ({\r\n          id: doc.id,\r\n          ...doc.data()\r\n        }));\r\n        setSplitExpenses(splitExpensesList);\r\n      } catch (error) {\r\n        console.error(\"Error processing split expenses data:\", error);\r\n        setSplitExpenses([]);\r\n      }\r\n      \r\n      // After loading split expenses, load contacts\r\n      loadContacts();\r\n    }, (error) => {\r\n      console.error(\"Error getting split expenses:\", error.code, error.message);\r\n      setLoading(false);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Function to load contacts from Firestore\r\n  const loadContacts = async () => {\r\n    if (!currentUser) return;\r\n    \r\n    try {\r\n      const contactsQuery = query(\r\n        collection(db, 'contacts'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const contactsSnapshot = await getDocs(contactsQuery);\r\n      const contactsList = contactsSnapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      \r\n      setContacts(contactsList);\r\n    } catch (error) {\r\n      console.error('Error loading contacts:', error.code, error.message);\r\n      setContacts([]);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Create a new split expense\r\n   * @param {Object} expenseData - Expense data (amount, category, etc.)\r\n   * @param {Array} participants - Array of participants\r\n   * @returns {Object} New split expense or null if failed\r\n   */\r\n  const createNewSplitExpense = async (expenseData, participants) => {\r\n    if (!currentUser) return null;\r\n    \r\n    try {\r\n      // Find the creator's participant object to determine their share\r\n      const creatorParticipant = participants.find(p => \r\n        p.email === currentUser.email || \r\n        p.name === currentUser.name\r\n      );\r\n      \r\n      // If creator isn't found in participants, use the first participant as a fallback\r\n      const userShare = creatorParticipant?.shareAmount || \r\n                       (participants.length > 0 ? participants[0].shareAmount : 0);\r\n      \r\n      // First create the base expense with proper split expense attribution\r\n      const expenseResult = await addExpense({\r\n        ...expenseData,\r\n        // Mark this as a split expense\r\n        isSplit: true,\r\n        // Add the current user's share for proper budget calculations\r\n        userShare: userShare,\r\n        // Add the number of participants\r\n        participantCount: participants.length,\r\n        // Add a descriptive note\r\n        notes: expenseData.notes || `Split with ${participants.length} people`\r\n      });\r\n      \r\n      if (!expenseResult) {\r\n        throw new Error('Failed to create base expense');\r\n      }\r\n      \r\n      // Create the split expense object\r\n      const newSplitExpense = createSplitExpense(\r\n        {\r\n          ...expenseData,\r\n          // The addExpense function returns the ID, but we need the full object\r\n          id: expenseResult\r\n        },\r\n        participants\r\n      );\r\n      \r\n      // Add to Firestore\r\n      const splitExpenseData = {\r\n        ...newSplitExpense,\r\n        userId: currentUser.uid,\r\n        createdAt: new Date().toISOString()\r\n      };\r\n      \r\n      const docRef = await addDoc(collection(db, 'splitExpenses'), splitExpenseData);\r\n      \r\n      // Add the Firestore document ID\r\n      const splitExpenseWithId = {\r\n        ...splitExpenseData,\r\n        id: docRef.id\r\n      };\r\n      \r\n      // Add any new contacts to Firestore\r\n      const existingContactEmails = contacts.map(c => c.email).filter(Boolean);\r\n      \r\n      for (const participant of participants) {\r\n        if (participant.email && !existingContactEmails.includes(participant.email)) {\r\n          await addDoc(collection(db, 'contacts'), {\r\n            name: participant.name,\r\n            email: participant.email,\r\n            userId: currentUser.uid,\r\n            createdAt: new Date().toISOString()\r\n          });\r\n        }\r\n      }\r\n      \r\n      // Send email notifications to participants (except the creator)\r\n      const otherParticipants = participants.filter(p => \r\n        p.email && p.email !== currentUser.email\r\n      );\r\n      \r\n      if (otherParticipants.length > 0) {\r\n        console.log(`Sending split expense notifications to ${otherParticipants.length} participants`);\r\n        \r\n        // Create a queue to send emails sequentially to avoid rate limits\r\n        const sendEmailQueue = async () => {\r\n          for (let i = 0; i < otherParticipants.length; i++) {\r\n            const participant = otherParticipants[i];\r\n            \r\n            try {\r\n              // Track email status\r\n              setEmailStatus(prev => ({\r\n                ...prev,\r\n                [participant.id]: { sending: true }\r\n              }));\r\n              \r\n              // Send the email with minimal parameters\r\n              const result = await sendSplitExpenseEmail(\r\n                participant, \r\n                splitExpenseWithId, \r\n                currentUser\r\n              );\r\n              \r\n              console.log(`Email result for ${participant.name}:`, result);\r\n              \r\n              // Update email status\r\n              setEmailStatus(prev => ({\r\n                ...prev,\r\n                [participant.id]: { \r\n                  sent: result.success, \r\n                  error: result.success ? null : result.message \r\n                }\r\n              }));\r\n              \r\n              // Wait a bit between emails to avoid rate limiting\r\n              if (i < otherParticipants.length - 1) {\r\n                await new Promise(resolve => setTimeout(resolve, 1000));\r\n              }\r\n            } catch (error) {\r\n              console.error(`Failed to send split email to ${participant.name}:`, error);\r\n              \r\n              // Update email status with error\r\n              setEmailStatus(prev => ({\r\n                ...prev,\r\n                [participant.id]: { \r\n                  sent: false, \r\n                  error: error.message || 'Unknown error' \r\n                }\r\n              }));\r\n              \r\n              // Continue with the next participant even if this one fails\r\n              await new Promise(resolve => setTimeout(resolve, 500));\r\n            }\r\n          }\r\n          \r\n          // Clear email status after all emails have been processed (plus a buffer)\r\n          setTimeout(() => {\r\n            setEmailStatus({});\r\n          }, 10000);\r\n        };\r\n        \r\n        // Start the email queue\r\n        sendEmailQueue();\r\n      }\r\n      \r\n      return splitExpenseWithId;\r\n    } catch (error) {\r\n      console.error('Error creating split expense:', error.code, error.message);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Get a split expense by ID\r\n   * @param {string|number} id - Split expense ID\r\n   * @returns {Object} Split expense or null if not found\r\n   */\r\n  const getSplitExpense = (id) => {\r\n    return splitExpenses.find(expense => expense.id === id) || null;\r\n  };\r\n  \r\n  /**\r\n   * Update a participant's payment status\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @param {string} status - New status (paid, unpaid, declined)\r\n   * @param {string} paymentMethod - Method of payment\r\n   * @returns {boolean} Success status\r\n   */\r\n  const updatePaymentStatus = async (splitExpenseId, participantId, status, paymentMethod) => {\r\n    if (!currentUser) return false;\r\n    \r\n    try {\r\n      // Find the split expense\r\n      const splitExpense = splitExpenses.find(expense => expense.id === splitExpenseId);\r\n      if (!splitExpense) return false;\r\n      \r\n      // Update the participant\r\n      const updatedParticipants = splitExpense.participants.map(participant => {\r\n        if (participant.id !== participantId) return participant;\r\n        return updateParticipantStatus(participant, status, paymentMethod);\r\n      });\r\n      \r\n      // Recalculate the overall status\r\n      const updatedStatus = calculateSplitStatus({\r\n        ...splitExpense,\r\n        participants: updatedParticipants\r\n      });\r\n      \r\n      // Update in Firestore\r\n      const splitExpenseRef = doc(db, 'splitExpenses', splitExpenseId);\r\n      \r\n      await updateDoc(splitExpenseRef, {\r\n        participants: updatedParticipants,\r\n        status: updatedStatus,\r\n        updatedAt: new Date().toISOString()\r\n      });\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating payment status:', error.code, error.message);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Add a new contact\r\n   * @param {string} name - Contact name\r\n   * @param {string} email - Contact email\r\n   * @returns {Object} New contact or null if failed\r\n   */\r\n  const addContact = async (name, email) => {\r\n    if (!currentUser || !name.trim()) return null;\r\n    \r\n    try {\r\n      // Check if contact with this email already exists\r\n      if (email) {\r\n        const existingContactsQuery = query(\r\n          collection(db, 'contacts'),\r\n          where('userId', '==', currentUser.uid),\r\n          where('email', '==', email.trim())\r\n        );\r\n        \r\n        const existingContacts = await getDocs(existingContactsQuery);\r\n        if (!existingContacts.empty) {\r\n          return null; // Contact already exists\r\n        }\r\n      }\r\n      \r\n      // Create new contact object\r\n      const newContactData = {\r\n        name: name.trim(),\r\n        email: email?.trim() || '',\r\n        userId: currentUser.uid,\r\n        createdAt: new Date().toISOString()\r\n      };\r\n      \r\n      // Add to Firestore\r\n      const docRef = await addDoc(collection(db, 'contacts'), newContactData);\r\n      \r\n      const newContact = {\r\n        ...newContactData,\r\n        id: docRef.id\r\n      };\r\n      \r\n      return newContact;\r\n    } catch (error) {\r\n      console.error('Error adding contact:', error.code, error.message);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Delete a contact\r\n   * @param {string} contactId - Contact ID\r\n   * @returns {boolean} Success status\r\n   */\r\n  const deleteContact = async (contactId) => {\r\n    if (!currentUser) return false;\r\n    \r\n    try {\r\n      // Delete from Firestore\r\n      await deleteDoc(doc(db, 'contacts', contactId));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting contact:', error.code, error.message);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Get all split expenses\r\n   * @returns {Array} Array of split expenses\r\n   */\r\n  const getAllSplitExpenses = () => {\r\n    return splitExpenses;\r\n  };\r\n  \r\n  /**\r\n   * Get all contacts\r\n   * @returns {Array} Array of contacts\r\n   */\r\n  const getAllContacts = () => {\r\n    return contacts;\r\n  };\r\n  \r\n  /**\r\n   * Delete a split expense\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @returns {boolean} Success status\r\n   */\r\n  const deleteSplitExpense = async (splitExpenseId) => {\r\n    if (!currentUser) return false;\r\n    \r\n    try {\r\n      // Delete from Firestore\r\n      await deleteDoc(doc(db, 'splitExpenses', splitExpenseId));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting split expense:', error.code, error.message);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Remind a participant to pay\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @returns {boolean} Success status\r\n   */\r\n  const sendPaymentReminder = async (splitExpenseId, participantId) => {\r\n    try {\r\n      const splitExpense = getSplitExpense(splitExpenseId);\r\n      if (!splitExpense) return false;\r\n      \r\n      const participant = splitExpense.participants.find(p => p.id === participantId);\r\n      if (!participant || !participant.email) return false;\r\n      \r\n      // Set status to sending\r\n      setEmailStatus(prev => ({\r\n        ...prev,\r\n        [participantId]: { sending: true }\r\n      }));\r\n      \r\n      // Create complete email parameters\r\n      const emailParams = {\r\n        to_email: participant.email,\r\n        to_name: participant.name || 'Participant',\r\n        creator_name: currentUser.name || 'Group member',\r\n        expense_description: splitExpense.description || 'Split expense',\r\n        expense_category: splitExpense.category || 'Uncategorized',\r\n        expense_date: new Date(splitExpense.date || new Date()).toLocaleDateString(),\r\n        expense_amount: splitExpense.totalAmount.toFixed(2),\r\n        share_amount: participant.shareAmount.toFixed(2),\r\n        is_reminder: true,\r\n        reminder_message: `This is a friendly reminder that your payment of $${participant.shareAmount.toFixed(2)} for \"${splitExpense.description}\" is still pending.`,\r\n        // Essential parameters for EmailJS template\r\n        name: currentUser.name || 'FinTrack',\r\n        email: currentUser.email || '',\r\n        reply_to: currentUser.email || '',\r\n        subject: `Payment Reminder: ${splitExpense.description || 'Split expense'}`\r\n      };\r\n      \r\n      try {\r\n        // Send reminder email with explicit error handling\r\n        const result = await sendSplitExpenseEmail(\r\n          participant, \r\n          splitExpense, \r\n          currentUser, \r\n          true, \r\n          emailParams\r\n        );\r\n        \r\n        console.log(`Reminder email result for ${participant.name}:`, result);\r\n        \r\n        // Update email status\r\n        setEmailStatus(prev => ({\r\n          ...prev,\r\n          [participantId]: { \r\n            sent: result.success, \r\n            error: result.success ? null : result.message \r\n          }\r\n        }));\r\n        \r\n        // Log reminder in Firestore\r\n        if (result.success) {\r\n          const reminderLog = {\r\n            splitExpenseId,\r\n            participantId,\r\n            timestamp: new Date().toISOString(),\r\n            userId: currentUser.uid,\r\n            success: true\r\n          };\r\n          \r\n          await addDoc(collection(db, 'reminderLogs'), reminderLog);\r\n        }\r\n      } catch (error) {\r\n        console.error(`Failed to send reminder email to ${participant.name}:`, error);\r\n        \r\n        // Update email status with error\r\n        setEmailStatus(prev => ({\r\n          ...prev,\r\n          [participantId]: { \r\n            sent: false, \r\n            error: error.message || 'Failed to send email' \r\n          }\r\n        }));\r\n      }\r\n      \r\n      // Clear status after some time\r\n      setTimeout(() => {\r\n        setEmailStatus(prev => {\r\n          const newStatus = { ...prev };\r\n          delete newStatus[participantId];\r\n          return newStatus;\r\n        });\r\n      }, 10000);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error sending payment reminder:', error.code, error.message);\r\n      \r\n      // Make sure the sending status is cleared if there's an error\r\n      setEmailStatus(prev => ({\r\n        ...prev,\r\n        [participantId]: { \r\n          sent: false, \r\n          error: error.message || 'Unknown error occurred' \r\n        }\r\n      }));\r\n      \r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Create a participant from a contact\r\n   * @param {Object} contact - Contact object\r\n   * @returns {Object} Participant object\r\n   */\r\n  const createParticipantFromContact = (contact) => {\r\n    return createParticipant(contact.name, contact.email);\r\n  };\r\n  \r\n  /**\r\n   * Get the email status for a participant\r\n   * @param {string} participantId - Participant ID\r\n   * @returns {Object} Email status object or null\r\n   */\r\n  const getEmailStatus = (participantId) => {\r\n    return emailStatus[participantId] || null;\r\n  };\r\n  \r\n  return (\r\n    <SplitExpenseContext.Provider\r\n      value={{\r\n        loading,\r\n        createNewSplitExpense,\r\n        getSplitExpense,\r\n        updatePaymentStatus,\r\n        addContact,\r\n        deleteContact,\r\n        getAllSplitExpenses,\r\n        getAllContacts,\r\n        deleteSplitExpense,\r\n        sendPaymentReminder,\r\n        createParticipant,\r\n        createParticipantFromContact,\r\n        emailStatus,\r\n        getEmailStatus\r\n      }}\r\n    >\r\n      {children}\r\n    </SplitExpenseContext.Provider>\r\n  );\r\n};\r\n\r\nexport default SplitExpenseContext;"],"mappings":";;AAAA;AACA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,UAAU,QAAQ,OAAO;AAC7E,SAASC,WAAW,QAAQ,eAAe;AAC3C,SAASC,cAAc,QAAQ,kBAAkB;AACjD,SACEC,kBAAkB,EAClBC,iBAAiB,EACjBC,uBAAuB,EACvBC,oBAAoB,QACf,6BAA6B;AACpC,SAASC,qBAAqB,QAAQ,0BAA0B;AAChE;AACA,SAASC,EAAE,QAAQ,oBAAoB;AACvC,SACEC,UAAU,EACVC,MAAM,EACNC,GAAG,EACHC,SAAS,EACTC,SAAS,EACTC,KAAK,EACLC,KAAK,EACLC,OAAO,EACPC,UAAU,EACVC,MAAM,EACNC,MAAM,QACD,oBAAoB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE5B,OAAO,MAAMC,mBAAmB,gBAAGzB,aAAa,CAAC,CAAC;AAElD,OAAO,MAAM0B,oBAAoB,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EACpD,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAG7B,QAAQ,CAAC,EAAE,CAAC;EACtD,MAAM,CAAC8B,QAAQ,EAAEC,WAAW,CAAC,GAAG/B,QAAQ,CAAC,EAAE,CAAC;EAC5C,MAAM,CAACgC,OAAO,EAAEC,UAAU,CAAC,GAAGjC,QAAQ,CAAC,IAAI,CAAC;EAC5C,MAAM,CAACkC,WAAW,EAAEC,cAAc,CAAC,GAAGnC,QAAQ,CAAC,CAAC,CAAC,CAAC;EAElD,MAAM;IAAEoC;EAAY,CAAC,GAAGlC,UAAU,CAACC,WAAW,CAAC;EAC/C,MAAM;IAAEkC;EAAW,CAAC,GAAGnC,UAAU,CAACE,cAAc,CAAC;;EAEjD;EACAH,SAAS,CAAC,MAAM;IACd,IAAI,CAACmC,WAAW,EAAE;MAChBP,gBAAgB,CAAC,EAAE,CAAC;MACpBE,WAAW,CAAC,EAAE,CAAC;MACfE,UAAU,CAAC,KAAK,CAAC;MACjB;IACF;IAEAA,UAAU,CAAC,IAAI,CAAC;;IAEhB;IACA,MAAMK,kBAAkB,GAAGtB,KAAK,CAC9BL,UAAU,CAACD,EAAE,EAAE,eAAe,CAAC,EAC/BO,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEmB,WAAW,CAACG,GAAG,CACvC,CAAC;;IAED;IACA,MAAMC,WAAW,GAAGrB,UAAU,CAACmB,kBAAkB,EAAGG,QAAQ,IAAK;MAC/D,IAAI;QACF,MAAMC,iBAAiB,GAAGD,QAAQ,CAACE,IAAI,CAACC,GAAG,CAAC/B,GAAG,KAAK;UAClDgC,EAAE,EAAEhC,GAAG,CAACgC,EAAE;UACV,GAAGhC,GAAG,CAACiC,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;QACHjB,gBAAgB,CAACa,iBAAiB,CAAC;MACrC,CAAC,CAAC,OAAOK,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;QAC7DlB,gBAAgB,CAAC,EAAE,CAAC;MACtB;;MAEA;MACAoB,YAAY,CAAC,CAAC;IAChB,CAAC,EAAGF,KAAK,IAAK;MACZC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAACG,IAAI,EAAEH,KAAK,CAACI,OAAO,CAAC;MACzElB,UAAU,CAAC,KAAK,CAAC;IACnB,CAAC,CAAC;IAEF,OAAO,MAAMO,WAAW,CAAC,CAAC;EAC5B,CAAC,EAAE,CAACJ,WAAW,CAAC,CAAC;;EAEjB;EACA,MAAMa,YAAY,GAAG,MAAAA,CAAA,KAAY;IAC/B,IAAI,CAACb,WAAW,EAAE;IAElB,IAAI;MACF,MAAMgB,aAAa,GAAGpC,KAAK,CACzBL,UAAU,CAACD,EAAE,EAAE,UAAU,CAAC,EAC1BO,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEmB,WAAW,CAACG,GAAG,CACvC,CAAC;MAED,MAAMc,gBAAgB,GAAG,MAAMnC,OAAO,CAACkC,aAAa,CAAC;MACrD,MAAME,YAAY,GAAGD,gBAAgB,CAACV,IAAI,CAACC,GAAG,CAAC/B,GAAG,KAAK;QACrDgC,EAAE,EAAEhC,GAAG,CAACgC,EAAE;QACV,GAAGhC,GAAG,CAACiC,IAAI,CAAC;MACd,CAAC,CAAC,CAAC;MAEHf,WAAW,CAACuB,YAAY,CAAC;IAC3B,CAAC,CAAC,OAAOP,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAACG,IAAI,EAAEH,KAAK,CAACI,OAAO,CAAC;MACnEpB,WAAW,CAAC,EAAE,CAAC;IACjB,CAAC,SAAS;MACRE,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,MAAMsB,qBAAqB,GAAG,MAAAA,CAAOC,WAAW,EAAEC,YAAY,KAAK;IACjE,IAAI,CAACrB,WAAW,EAAE,OAAO,IAAI;IAE7B,IAAI;MACF;MACA,MAAMsB,kBAAkB,GAAGD,YAAY,CAACE,IAAI,CAACC,CAAC,IAC5CA,CAAC,CAACC,KAAK,KAAKzB,WAAW,CAACyB,KAAK,IAC7BD,CAAC,CAACE,IAAI,KAAK1B,WAAW,CAAC0B,IACzB,CAAC;;MAED;MACA,MAAMC,SAAS,GAAG,CAAAL,kBAAkB,aAAlBA,kBAAkB,uBAAlBA,kBAAkB,CAAEM,WAAW,MAC/BP,YAAY,CAACQ,MAAM,GAAG,CAAC,GAAGR,YAAY,CAAC,CAAC,CAAC,CAACO,WAAW,GAAG,CAAC,CAAC;;MAE5E;MACA,MAAME,aAAa,GAAG,MAAM7B,UAAU,CAAC;QACrC,GAAGmB,WAAW;QACd;QACAW,OAAO,EAAE,IAAI;QACb;QACAJ,SAAS,EAAEA,SAAS;QACpB;QACAK,gBAAgB,EAAEX,YAAY,CAACQ,MAAM;QACrC;QACAI,KAAK,EAAEb,WAAW,CAACa,KAAK,IAAI,cAAcZ,YAAY,CAACQ,MAAM;MAC/D,CAAC,CAAC;MAEF,IAAI,CAACC,aAAa,EAAE;QAClB,MAAM,IAAII,KAAK,CAAC,+BAA+B,CAAC;MAClD;;MAEA;MACA,MAAMC,eAAe,GAAGlE,kBAAkB,CACxC;QACE,GAAGmD,WAAW;QACd;QACAX,EAAE,EAAEqB;MACN,CAAC,EACDT,YACF,CAAC;;MAED;MACA,MAAMe,gBAAgB,GAAG;QACvB,GAAGD,eAAe;QAClBE,MAAM,EAAErC,WAAW,CAACG,GAAG;QACvBmC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;MAED,MAAMC,MAAM,GAAG,MAAMjE,MAAM,CAACD,UAAU,CAACD,EAAE,EAAE,eAAe,CAAC,EAAE8D,gBAAgB,CAAC;;MAE9E;MACA,MAAMM,kBAAkB,GAAG;QACzB,GAAGN,gBAAgB;QACnB3B,EAAE,EAAEgC,MAAM,CAAChC;MACb,CAAC;;MAED;MACA,MAAMkC,qBAAqB,GAAGjD,QAAQ,CAACc,GAAG,CAACoC,CAAC,IAAIA,CAAC,CAACnB,KAAK,CAAC,CAACoB,MAAM,CAACC,OAAO,CAAC;MAExE,KAAK,MAAMC,WAAW,IAAI1B,YAAY,EAAE;QACtC,IAAI0B,WAAW,CAACtB,KAAK,IAAI,CAACkB,qBAAqB,CAACK,QAAQ,CAACD,WAAW,CAACtB,KAAK,CAAC,EAAE;UAC3E,MAAMjD,MAAM,CAACD,UAAU,CAACD,EAAE,EAAE,UAAU,CAAC,EAAE;YACvCoD,IAAI,EAAEqB,WAAW,CAACrB,IAAI;YACtBD,KAAK,EAAEsB,WAAW,CAACtB,KAAK;YACxBY,MAAM,EAAErC,WAAW,CAACG,GAAG;YACvBmC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;UACpC,CAAC,CAAC;QACJ;MACF;;MAEA;MACA,MAAMS,iBAAiB,GAAG5B,YAAY,CAACwB,MAAM,CAACrB,CAAC,IAC7CA,CAAC,CAACC,KAAK,IAAID,CAAC,CAACC,KAAK,KAAKzB,WAAW,CAACyB,KACrC,CAAC;MAED,IAAIwB,iBAAiB,CAACpB,MAAM,GAAG,CAAC,EAAE;QAChCjB,OAAO,CAACsC,GAAG,CAAC,0CAA0CD,iBAAiB,CAACpB,MAAM,eAAe,CAAC;;QAE9F;QACA,MAAMsB,cAAc,GAAG,MAAAA,CAAA,KAAY;UACjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,iBAAiB,CAACpB,MAAM,EAAEuB,CAAC,EAAE,EAAE;YACjD,MAAML,WAAW,GAAGE,iBAAiB,CAACG,CAAC,CAAC;YAExC,IAAI;cACF;cACArD,cAAc,CAACsD,IAAI,KAAK;gBACtB,GAAGA,IAAI;gBACP,CAACN,WAAW,CAACtC,EAAE,GAAG;kBAAE6C,OAAO,EAAE;gBAAK;cACpC,CAAC,CAAC,CAAC;;cAEH;cACA,MAAMC,MAAM,GAAG,MAAMlF,qBAAqB,CACxC0E,WAAW,EACXL,kBAAkB,EAClB1C,WACF,CAAC;cAEDY,OAAO,CAACsC,GAAG,CAAC,oBAAoBH,WAAW,CAACrB,IAAI,GAAG,EAAE6B,MAAM,CAAC;;cAE5D;cACAxD,cAAc,CAACsD,IAAI,KAAK;gBACtB,GAAGA,IAAI;gBACP,CAACN,WAAW,CAACtC,EAAE,GAAG;kBAChB+C,IAAI,EAAED,MAAM,CAACE,OAAO;kBACpB9C,KAAK,EAAE4C,MAAM,CAACE,OAAO,GAAG,IAAI,GAAGF,MAAM,CAACxC;gBACxC;cACF,CAAC,CAAC,CAAC;;cAEH;cACA,IAAIqC,CAAC,GAAGH,iBAAiB,CAACpB,MAAM,GAAG,CAAC,EAAE;gBACpC,MAAM,IAAI6B,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;cACzD;YACF,CAAC,CAAC,OAAOhD,KAAK,EAAE;cACdC,OAAO,CAACD,KAAK,CAAC,iCAAiCoC,WAAW,CAACrB,IAAI,GAAG,EAAEf,KAAK,CAAC;;cAE1E;cACAZ,cAAc,CAACsD,IAAI,KAAK;gBACtB,GAAGA,IAAI;gBACP,CAACN,WAAW,CAACtC,EAAE,GAAG;kBAChB+C,IAAI,EAAE,KAAK;kBACX7C,KAAK,EAAEA,KAAK,CAACI,OAAO,IAAI;gBAC1B;cACF,CAAC,CAAC,CAAC;;cAEH;cACA,MAAM,IAAI2C,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;YACxD;UACF;;UAEA;UACAC,UAAU,CAAC,MAAM;YACf7D,cAAc,CAAC,CAAC,CAAC,CAAC;UACpB,CAAC,EAAE,KAAK,CAAC;QACX,CAAC;;QAED;QACAoD,cAAc,CAAC,CAAC;MAClB;MAEA,OAAOT,kBAAkB;IAC3B,CAAC,CAAC,OAAO/B,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAACG,IAAI,EAAEH,KAAK,CAACI,OAAO,CAAC;MACzE,OAAO,IAAI;IACb;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,MAAM8C,eAAe,GAAIpD,EAAE,IAAK;IAC9B,OAAOjB,aAAa,CAAC+B,IAAI,CAACuC,OAAO,IAAIA,OAAO,CAACrD,EAAE,KAAKA,EAAE,CAAC,IAAI,IAAI;EACjE,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMsD,mBAAmB,GAAG,MAAAA,CAAOC,cAAc,EAAEC,aAAa,EAAEC,MAAM,EAAEC,aAAa,KAAK;IAC1F,IAAI,CAACnE,WAAW,EAAE,OAAO,KAAK;IAE9B,IAAI;MACF;MACA,MAAMoE,YAAY,GAAG5E,aAAa,CAAC+B,IAAI,CAACuC,OAAO,IAAIA,OAAO,CAACrD,EAAE,KAAKuD,cAAc,CAAC;MACjF,IAAI,CAACI,YAAY,EAAE,OAAO,KAAK;;MAE/B;MACA,MAAMC,mBAAmB,GAAGD,YAAY,CAAC/C,YAAY,CAACb,GAAG,CAACuC,WAAW,IAAI;QACvE,IAAIA,WAAW,CAACtC,EAAE,KAAKwD,aAAa,EAAE,OAAOlB,WAAW;QACxD,OAAO5E,uBAAuB,CAAC4E,WAAW,EAAEmB,MAAM,EAAEC,aAAa,CAAC;MACpE,CAAC,CAAC;;MAEF;MACA,MAAMG,aAAa,GAAGlG,oBAAoB,CAAC;QACzC,GAAGgG,YAAY;QACf/C,YAAY,EAAEgD;MAChB,CAAC,CAAC;;MAEF;MACA,MAAME,eAAe,GAAG9F,GAAG,CAACH,EAAE,EAAE,eAAe,EAAE0F,cAAc,CAAC;MAEhE,MAAMrF,SAAS,CAAC4F,eAAe,EAAE;QAC/BlD,YAAY,EAAEgD,mBAAmB;QACjCH,MAAM,EAAEI,aAAa;QACrBE,SAAS,EAAE,IAAIjC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC,CAAC;MAEF,OAAO,IAAI;IACb,CAAC,CAAC,OAAO7B,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAACG,IAAI,EAAEH,KAAK,CAACI,OAAO,CAAC;MAC1E,OAAO,KAAK;IACd;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,MAAM0D,UAAU,GAAG,MAAAA,CAAO/C,IAAI,EAAED,KAAK,KAAK;IACxC,IAAI,CAACzB,WAAW,IAAI,CAAC0B,IAAI,CAACgD,IAAI,CAAC,CAAC,EAAE,OAAO,IAAI;IAE7C,IAAI;MACF;MACA,IAAIjD,KAAK,EAAE;QACT,MAAMkD,qBAAqB,GAAG/F,KAAK,CACjCL,UAAU,CAACD,EAAE,EAAE,UAAU,CAAC,EAC1BO,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEmB,WAAW,CAACG,GAAG,CAAC,EACtCtB,KAAK,CAAC,OAAO,EAAE,IAAI,EAAE4C,KAAK,CAACiD,IAAI,CAAC,CAAC,CACnC,CAAC;QAED,MAAME,gBAAgB,GAAG,MAAM9F,OAAO,CAAC6F,qBAAqB,CAAC;QAC7D,IAAI,CAACC,gBAAgB,CAACC,KAAK,EAAE;UAC3B,OAAO,IAAI,CAAC,CAAC;QACf;MACF;;MAEA;MACA,MAAMC,cAAc,GAAG;QACrBpD,IAAI,EAAEA,IAAI,CAACgD,IAAI,CAAC,CAAC;QACjBjD,KAAK,EAAE,CAAAA,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEiD,IAAI,CAAC,CAAC,KAAI,EAAE;QAC1BrC,MAAM,EAAErC,WAAW,CAACG,GAAG;QACvBmC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;;MAED;MACA,MAAMC,MAAM,GAAG,MAAMjE,MAAM,CAACD,UAAU,CAACD,EAAE,EAAE,UAAU,CAAC,EAAEwG,cAAc,CAAC;MAEvE,MAAMC,UAAU,GAAG;QACjB,GAAGD,cAAc;QACjBrE,EAAE,EAAEgC,MAAM,CAAChC;MACb,CAAC;MAED,OAAOsE,UAAU;IACnB,CAAC,CAAC,OAAOpE,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAACG,IAAI,EAAEH,KAAK,CAACI,OAAO,CAAC;MACjE,OAAO,IAAI;IACb;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,MAAMiE,aAAa,GAAG,MAAOC,SAAS,IAAK;IACzC,IAAI,CAACjF,WAAW,EAAE,OAAO,KAAK;IAE9B,IAAI;MACF;MACA,MAAMtB,SAAS,CAACD,GAAG,CAACH,EAAE,EAAE,UAAU,EAAE2G,SAAS,CAAC,CAAC;MAC/C,OAAO,IAAI;IACb,CAAC,CAAC,OAAOtE,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAACG,IAAI,EAAEH,KAAK,CAACI,OAAO,CAAC;MACnE,OAAO,KAAK;IACd;EACF,CAAC;;EAED;AACF;AACA;AACA;EACE,MAAMmE,mBAAmB,GAAGA,CAAA,KAAM;IAChC,OAAO1F,aAAa;EACtB,CAAC;;EAED;AACF;AACA;AACA;EACE,MAAM2F,cAAc,GAAGA,CAAA,KAAM;IAC3B,OAAOzF,QAAQ;EACjB,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,MAAM0F,kBAAkB,GAAG,MAAOpB,cAAc,IAAK;IACnD,IAAI,CAAChE,WAAW,EAAE,OAAO,KAAK;IAE9B,IAAI;MACF;MACA,MAAMtB,SAAS,CAACD,GAAG,CAACH,EAAE,EAAE,eAAe,EAAE0F,cAAc,CAAC,CAAC;MACzD,OAAO,IAAI;IACb,CAAC,CAAC,OAAOrD,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAACG,IAAI,EAAEH,KAAK,CAACI,OAAO,CAAC;MACzE,OAAO,KAAK;IACd;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,MAAMsE,mBAAmB,GAAG,MAAAA,CAAOrB,cAAc,EAAEC,aAAa,KAAK;IACnE,IAAI;MACF,MAAMG,YAAY,GAAGP,eAAe,CAACG,cAAc,CAAC;MACpD,IAAI,CAACI,YAAY,EAAE,OAAO,KAAK;MAE/B,MAAMrB,WAAW,GAAGqB,YAAY,CAAC/C,YAAY,CAACE,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACf,EAAE,KAAKwD,aAAa,CAAC;MAC/E,IAAI,CAAClB,WAAW,IAAI,CAACA,WAAW,CAACtB,KAAK,EAAE,OAAO,KAAK;;MAEpD;MACA1B,cAAc,CAACsD,IAAI,KAAK;QACtB,GAAGA,IAAI;QACP,CAACY,aAAa,GAAG;UAAEX,OAAO,EAAE;QAAK;MACnC,CAAC,CAAC,CAAC;;MAEH;MACA,MAAMgC,WAAW,GAAG;QAClBC,QAAQ,EAAExC,WAAW,CAACtB,KAAK;QAC3B+D,OAAO,EAAEzC,WAAW,CAACrB,IAAI,IAAI,aAAa;QAC1C+D,YAAY,EAAEzF,WAAW,CAAC0B,IAAI,IAAI,cAAc;QAChDgE,mBAAmB,EAAEtB,YAAY,CAACuB,WAAW,IAAI,eAAe;QAChEC,gBAAgB,EAAExB,YAAY,CAACyB,QAAQ,IAAI,eAAe;QAC1DC,YAAY,EAAE,IAAIvD,IAAI,CAAC6B,YAAY,CAAC2B,IAAI,IAAI,IAAIxD,IAAI,CAAC,CAAC,CAAC,CAACyD,kBAAkB,CAAC,CAAC;QAC5EC,cAAc,EAAE7B,YAAY,CAAC8B,WAAW,CAACC,OAAO,CAAC,CAAC,CAAC;QACnDC,YAAY,EAAErD,WAAW,CAACnB,WAAW,CAACuE,OAAO,CAAC,CAAC,CAAC;QAChDE,WAAW,EAAE,IAAI;QACjBC,gBAAgB,EAAE,qDAAqDvD,WAAW,CAACnB,WAAW,CAACuE,OAAO,CAAC,CAAC,CAAC,SAAS/B,YAAY,CAACuB,WAAW,qBAAqB;QAC/J;QACAjE,IAAI,EAAE1B,WAAW,CAAC0B,IAAI,IAAI,UAAU;QACpCD,KAAK,EAAEzB,WAAW,CAACyB,KAAK,IAAI,EAAE;QAC9B8E,QAAQ,EAAEvG,WAAW,CAACyB,KAAK,IAAI,EAAE;QACjC+E,OAAO,EAAE,qBAAqBpC,YAAY,CAACuB,WAAW,IAAI,eAAe;MAC3E,CAAC;MAED,IAAI;QACF;QACA,MAAMpC,MAAM,GAAG,MAAMlF,qBAAqB,CACxC0E,WAAW,EACXqB,YAAY,EACZpE,WAAW,EACX,IAAI,EACJsF,WACF,CAAC;QAED1E,OAAO,CAACsC,GAAG,CAAC,6BAA6BH,WAAW,CAACrB,IAAI,GAAG,EAAE6B,MAAM,CAAC;;QAErE;QACAxD,cAAc,CAACsD,IAAI,KAAK;UACtB,GAAGA,IAAI;UACP,CAACY,aAAa,GAAG;YACfT,IAAI,EAAED,MAAM,CAACE,OAAO;YACpB9C,KAAK,EAAE4C,MAAM,CAACE,OAAO,GAAG,IAAI,GAAGF,MAAM,CAACxC;UACxC;QACF,CAAC,CAAC,CAAC;;QAEH;QACA,IAAIwC,MAAM,CAACE,OAAO,EAAE;UAClB,MAAMgD,WAAW,GAAG;YAClBzC,cAAc;YACdC,aAAa;YACbyC,SAAS,EAAE,IAAInE,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;YACnCH,MAAM,EAAErC,WAAW,CAACG,GAAG;YACvBsD,OAAO,EAAE;UACX,CAAC;UAED,MAAMjF,MAAM,CAACD,UAAU,CAACD,EAAE,EAAE,cAAc,CAAC,EAAEmI,WAAW,CAAC;QAC3D;MACF,CAAC,CAAC,OAAO9F,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,oCAAoCoC,WAAW,CAACrB,IAAI,GAAG,EAAEf,KAAK,CAAC;;QAE7E;QACAZ,cAAc,CAACsD,IAAI,KAAK;UACtB,GAAGA,IAAI;UACP,CAACY,aAAa,GAAG;YACfT,IAAI,EAAE,KAAK;YACX7C,KAAK,EAAEA,KAAK,CAACI,OAAO,IAAI;UAC1B;QACF,CAAC,CAAC,CAAC;MACL;;MAEA;MACA6C,UAAU,CAAC,MAAM;QACf7D,cAAc,CAACsD,IAAI,IAAI;UACrB,MAAMsD,SAAS,GAAG;YAAE,GAAGtD;UAAK,CAAC;UAC7B,OAAOsD,SAAS,CAAC1C,aAAa,CAAC;UAC/B,OAAO0C,SAAS;QAClB,CAAC,CAAC;MACJ,CAAC,EAAE,KAAK,CAAC;MAET,OAAO,IAAI;IACb,CAAC,CAAC,OAAOhG,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAACG,IAAI,EAAEH,KAAK,CAACI,OAAO,CAAC;;MAE3E;MACAhB,cAAc,CAACsD,IAAI,KAAK;QACtB,GAAGA,IAAI;QACP,CAACY,aAAa,GAAG;UACfT,IAAI,EAAE,KAAK;UACX7C,KAAK,EAAEA,KAAK,CAACI,OAAO,IAAI;QAC1B;MACF,CAAC,CAAC,CAAC;MAEH,OAAO,KAAK;IACd;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,MAAM6F,4BAA4B,GAAIC,OAAO,IAAK;IAChD,OAAO3I,iBAAiB,CAAC2I,OAAO,CAACnF,IAAI,EAAEmF,OAAO,CAACpF,KAAK,CAAC;EACvD,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,MAAMqF,cAAc,GAAI7C,aAAa,IAAK;IACxC,OAAOnE,WAAW,CAACmE,aAAa,CAAC,IAAI,IAAI;EAC3C,CAAC;EAED,oBACE9E,OAAA,CAACC,mBAAmB,CAAC2H,QAAQ;IAC3BC,KAAK,EAAE;MACLpH,OAAO;MACPuB,qBAAqB;MACrB0C,eAAe;MACfE,mBAAmB;MACnBU,UAAU;MACVO,aAAa;MACbE,mBAAmB;MACnBC,cAAc;MACdC,kBAAkB;MAClBC,mBAAmB;MACnBnH,iBAAiB;MACjB0I,4BAA4B;MAC5B9G,WAAW;MACXgH;IACF,CAAE;IAAAxH,QAAA,EAEDA;EAAQ;IAAA2H,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACmB,CAAC;AAEnC,CAAC;AAAC7H,EAAA,CAjhBWF,oBAAoB;AAAAgI,EAAA,GAApBhI,oBAAoB;AAmhBjC,eAAeD,mBAAmB;AAAC,IAAAiI,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}