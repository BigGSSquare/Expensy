{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\tejit\\\\OneDrive\\\\Desktop\\\\expence tracker final\\\\expence-tracker\\\\src\\\\context\\\\ExpenseContext.js\",\n  _s = $RefreshSig$();\n// src/context/ExpenseContext.js\nimport React, { createContext, useState, useEffect, useContext } from 'react';\nimport { AuthContext } from './AuthContext';\nimport { sendBudgetAlertEmail } from '../services/EmailService';\nimport { scanReceiptImage, parseReceiptData } from '../services/ReceiptScanningService';\n// Add Firebase imports\nimport { db, storage } from '../config/firebase';\nimport { collection, addDoc, doc, deleteDoc, updateDoc, query, where, getDocs, onSnapshot, getDoc, setDoc, limit } from 'firebase/firestore';\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ExpenseContext = /*#__PURE__*/createContext();\nexport const ExpenseProvider = ({\n  children\n}) => {\n  _s();\n  const [expenses, setExpenses] = useState([]);\n  const [incomes, setIncomes] = useState([]);\n  const [budgets, setBudgets] = useState({});\n  const [alerts, setAlerts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [emailStatus, setEmailStatus] = useState({\n    sent: false,\n    error: null\n  });\n  const [expenseCategories, setExpenseCategories] = useState([]);\n  const [incomeCategories, setIncomeCategories] = useState([]);\n  // Add new state for receipt scanning\n  const [receiptScanStatus, setReceiptScanStatus] = useState({\n    scanning: false,\n    error: null,\n    data: null\n  });\n  // Track receipt scan history\n  const [receiptScans, setReceiptScans] = useState([]);\n  const {\n    currentUser\n  } = useContext(AuthContext);\n\n  // Default categories if none are found\n  const DEFAULT_EXPENSE_CATEGORIES = ['Food', 'Housing', 'Transportation', 'Entertainment', 'Utilities', 'Healthcare', 'Shopping', 'Personal Care', 'Education', 'Other'];\n  const DEFAULT_INCOME_CATEGORIES = ['Salary', 'Freelance', 'Investment', 'Gift', 'Business', 'Side Hustle', 'Rental', 'Other'];\n\n  // Load expenses from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setExpenses([]);\n      setLoading(false);\n      return;\n    }\n    setLoading(true);\n\n    // Query Firestore for expenses\n    const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(expensesQuery, snapshot => {\n      const expensesList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setExpenses(expensesList);\n      setLoading(false);\n    }, error => {\n      console.error(\"Error getting expenses:\", error);\n      setLoading(false);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Load incomes from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setIncomes([]);\n      return;\n    }\n\n    // Query Firestore for incomes\n    const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(incomesQuery, snapshot => {\n      const incomesList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setIncomes(incomesList);\n    }, error => {\n      console.error(\"Error getting incomes:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Clear email status after some time\n  useEffect(() => {\n    if (emailStatus.sent || emailStatus.error) {\n      const timer = setTimeout(() => {\n        setEmailStatus({\n          sent: false,\n          error: null\n        });\n      }, 5000);\n      return () => clearTimeout(timer);\n    }\n  }, [emailStatus]);\n\n  // Clear receipt scan data after processing\n  useEffect(() => {\n    if (receiptScanStatus.data && !receiptScanStatus.scanning) {\n      const timer = setTimeout(() => {\n        setReceiptScanStatus(prevState => ({\n          ...prevState,\n          data: null\n        }));\n      }, 30000); // Give user 30 seconds to review before clearing\n\n      return () => clearTimeout(timer);\n    }\n  }, [receiptScanStatus]);\n\n  // Add a new expense with validation\n  // Updated addExpense function for ExpenseContext.js\n  // Fix in ExpenseContext.js\n  const addExpense = async expense => {\n    if (!currentUser) {\n      console.error('Cannot add expense: No authenticated user');\n      return false;\n    }\n    try {\n      // Ensure expense has all required fields\n      const newExpense = {\n        category: expense.category || 'Other',\n        amount: parseFloat(expense.amount) || 0,\n        date: expense.date || new Date().toISOString().slice(0, 10),\n        description: expense.description || '',\n        userId: currentUser.uid,\n        // Make sure this is always set\n        createdAt: new Date().toISOString(),\n        // Additional fields\n        isSplit: expense.isSplit || false,\n        userShare: expense.userShare || parseFloat(expense.amount) || 0\n      };\n\n      // Log for debugging\n      console.log('Adding expense to Firestore:', newExpense);\n\n      // Add to Firestore with error handling\n      try {\n        const docRef = await addDoc(collection(db, 'expenses'), newExpense);\n        console.log('Expense added with ID:', docRef.id);\n        return docRef.id;\n      } catch (firestoreError) {\n        console.error('Firestore error adding expense:', firestoreError);\n        return false;\n      }\n    } catch (error) {\n      console.error('Error adding expense:', error);\n      return false;\n    }\n  };\n\n  // In ExpenseContext.js - scanReceipt function\n  const scanReceipt = async imageFile => {\n    if (!currentUser) {\n      setReceiptScanStatus({\n        scanning: false,\n        error: 'User not logged in',\n        data: null\n      });\n      return {\n        success: false,\n        error: 'User not logged in'\n      };\n    }\n    if (!imageFile) {\n      setReceiptScanStatus({\n        scanning: false,\n        error: 'No image provided',\n        data: null\n      });\n      return {\n        success: false,\n        error: 'No image provided'\n      };\n    }\n    try {\n      // Set scanning status first\n      setReceiptScanStatus({\n        scanning: true,\n        error: null,\n        data: null\n      });\n      console.log('Processing receipt image:', imageFile.name);\n\n      // Generate a temporary URL for the uploaded image\n      const imageUrl = URL.createObjectURL(imageFile);\n\n      // Instead of returning hardcoded mock data, return empty fields for user to fill\n      const extractedData = {\n        // Empty or default values\n        merchantName: \"\",\n        amount: \"\",\n        date: new Date().toISOString().slice(0, 10),\n        // Default to today\n        receiptNumber: `REC-${Math.floor(Math.random() * 10000)}`,\n        items: [],\n        confidence: 1.0,\n        taxAmount: 0,\n        currencyCode: 'USD',\n        imageUrl: imageUrl,\n        success: true\n      };\n      console.log('Ready for user input with receipt image');\n\n      // Update the receipt scan status with the empty fields for user input\n      setReceiptScanStatus({\n        scanning: false,\n        error: null,\n        data: {\n          amount: \"\",\n          description: \"\",\n          category: \"Food\",\n          // Default category\n          date: extractedData.date,\n          fromReceipt: true,\n          receiptImageUrl: imageUrl,\n          notes: \"\"\n        }\n      });\n      return {\n        success: true,\n        data: extractedData,\n        imageUrl: imageUrl\n      };\n    } catch (error) {\n      console.error('Error scanning receipt:', error);\n      setReceiptScanStatus({\n        scanning: false,\n        error: error.message || 'Error scanning receipt',\n        data: null\n      });\n      return {\n        success: false,\n        error: error.message || 'Error scanning receipt'\n      };\n    }\n  };\n\n  // Function to add the expense from a scanned receipt\n  const addExpenseFromReceipt = async (expenseData, modifications = {}) => {\n    if (!currentUser) return false;\n    try {\n      // Combine scanned data with any user modifications\n      const finalExpenseData = {\n        ...expenseData,\n        ...modifications,\n        fromReceipt: true\n      };\n\n      // Use the existing addExpense function\n      const result = await addExpense(finalExpenseData);\n      if (result && finalExpenseData.receiptScanId) {\n        // Update the scan record status in Firestore\n        const scanRef = doc(db, 'receiptScans', String(finalExpenseData.receiptScanId));\n        await updateDoc(scanRef, {\n          status: 'applied'\n        });\n\n        // Clear the scanned data after successful addition\n        setReceiptScanStatus(prevState => ({\n          ...prevState,\n          data: null\n        }));\n      }\n      return result;\n    } catch (error) {\n      console.error('Error adding expense from receipt:', error);\n      return false;\n    }\n  };\n\n  // Function to reject a scanned receipt\n  const rejectScannedReceipt = async scanId => {\n    if (!scanId) return false;\n    try {\n      var _receiptScanStatus$da;\n      // Update the scan record status in Firestore\n      const scanRef = doc(db, 'receiptScans', String(scanId));\n      await updateDoc(scanRef, {\n        status: 'rejected'\n      });\n\n      // Clear any pending scan data with this ID\n      if (((_receiptScanStatus$da = receiptScanStatus.data) === null || _receiptScanStatus$da === void 0 ? void 0 : _receiptScanStatus$da.receiptScanId) === scanId) {\n        setReceiptScanStatus({\n          scanning: false,\n          error: null,\n          data: null\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error('Error rejecting scanned receipt:', error);\n      return false;\n    }\n  };\n\n  // Helper function to map vendor names to appropriate categories\n  const mapVendorToCategory = vendorName => {\n    const vendorNameLower = vendorName.toLowerCase();\n\n    // Simple mapping logic - can be expanded based on common vendors\n    if (!vendorName) return 'Other';\n    const categoryMappings = {\n      'restaurant': 'Food',\n      'cafÃ©': 'Food',\n      'cafe': 'Food',\n      'grocery': 'Food',\n      'supermarket': 'Food',\n      'market': 'Food',\n      'gas': 'Transportation',\n      'fuel': 'Transportation',\n      'uber': 'Transportation',\n      'lyft': 'Transportation',\n      'taxi': 'Transportation',\n      'pharmacy': 'Healthcare',\n      'drug': 'Healthcare',\n      'doctor': 'Healthcare',\n      'clinic': 'Healthcare',\n      'hospital': 'Healthcare',\n      'rent': 'Housing',\n      'mortgage': 'Housing',\n      'netflix': 'Entertainment',\n      'spotify': 'Entertainment',\n      'cinema': 'Entertainment',\n      'movie': 'Entertainment',\n      'theater': 'Entertainment',\n      'amazon': 'Shopping',\n      'walmart': 'Shopping',\n      'target': 'Shopping',\n      'utility': 'Utilities',\n      'electric': 'Utilities',\n      'water': 'Utilities',\n      'gas bill': 'Utilities',\n      'phone': 'Utilities',\n      'internet': 'Utilities',\n      'school': 'Education',\n      'college': 'Education',\n      'university': 'Education',\n      'tuition': 'Education',\n      'book': 'Education',\n      'haircut': 'Personal Care',\n      'salon': 'Personal Care',\n      'spa': 'Personal Care',\n      'gym': 'Personal Care'\n    };\n    for (const [keyword, category] of Object.entries(categoryMappings)) {\n      if (vendorNameLower.includes(keyword)) {\n        return category;\n      }\n    }\n    return 'Other';\n  };\n\n  // Add a new income with validation\n  const addIncome = async income => {\n    if (!currentUser) {\n      console.error('Cannot add income: No authenticated user');\n      return false;\n    }\n    try {\n      // Log for debugging\n      console.log('Adding income with data:', income);\n\n      // Validate income data\n      if (!income.source) {\n        console.error('Missing source in income');\n        return false;\n      }\n      const amount = parseFloat(income.amount);\n      if (isNaN(amount) || amount <= 0) {\n        console.error('Invalid income amount:', income.amount);\n        return false;\n      }\n\n      // Create new income object\n      const newIncome = {\n        source: income.source,\n        amount: amount,\n        date: income.date || new Date().toISOString().slice(0, 10),\n        description: income.description || '',\n        userId: currentUser.uid,\n        createdAt: new Date().toISOString()\n      };\n      console.log('Prepared income object for Firestore:', newIncome);\n\n      // Add to Firestore with explicit error handling\n      try {\n        const docRef = await addDoc(collection(db, 'incomes'), newIncome);\n        console.log('Income added successfully with ID:', docRef.id);\n        return docRef.id;\n      } catch (firestoreError) {\n        console.error('Firestore error adding income:', firestoreError);\n        throw firestoreError; // Rethrow to be caught by outer try/catch\n      }\n    } catch (error) {\n      console.error('Error adding income:', error);\n      return false;\n    }\n  };\n\n  // Delete an expense\n  const deleteExpense = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      // Get the expense before deleting it (to check for receipt info)\n      const expenseRef = doc(db, 'expenses', id);\n      const expenseSnap = await getDoc(expenseRef);\n      if (expenseSnap.exists()) {\n        const expenseData = expenseSnap.data();\n\n        // Delete the expense document\n        await deleteDoc(expenseRef);\n\n        // If this was a receipt-based expense, update the scan record\n        if (expenseData.receiptScanId) {\n          const scanRef = doc(db, 'receiptScans', String(expenseData.receiptScanId));\n          const scanSnap = await getDoc(scanRef);\n          if (scanSnap.exists()) {\n            await updateDoc(scanRef, {\n              status: 'rejected'\n            });\n          }\n        }\n      } else {\n        // Document not found\n        console.error('Expense not found');\n        return false;\n      }\n      return true;\n    } catch (error) {\n      console.error('Error deleting expense:', error);\n      return false;\n    }\n  };\n\n  // Delete an income\n  const deleteIncome = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      await deleteDoc(doc(db, 'incomes', id));\n      return true;\n    } catch (error) {\n      console.error('Error deleting income:', error);\n      return false;\n    }\n  };\n\n  // Update budget settings\n  const updateBudget = async (category, amount) => {\n    if (!currentUser || !category || category.trim() === '' || isNaN(parseFloat(amount))) {\n      return false;\n    }\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        // Update existing budgets document\n        await updateDoc(budgetRef, {\n          [category]: parseFloat(amount)\n        });\n      } else {\n        // Create new budgets document\n        await setDoc(budgetRef, {\n          [category]: parseFloat(amount)\n        });\n      }\n\n      // Update local state\n      setBudgets(prevBudgets => ({\n        ...prevBudgets,\n        [category]: parseFloat(amount)\n      }));\n      return true;\n    } catch (error) {\n      console.error('Error updating budget:', error);\n      return false;\n    }\n  };\n\n  // Delete a budget\n  const deleteBudget = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n\n        // Remove the category from the budgets\n        if (currentBudgets[category] !== undefined) {\n          delete currentBudgets[category];\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error deleting budget:', error);\n      return false;\n    }\n  };\n\n  // Check if adding this expense exceeds the budget\n  const checkBudgetAlerts = async (newExpense, allExpenses = expenses) => {\n    if (!currentUser) return; // Don't process if no user is logged in\n    if (!newExpense || !newExpense.category) return;\n    const {\n      category\n    } = newExpense;\n\n    // Get budgets from Firestore\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (!budgetDoc.exists()) return;\n      const budgets = budgetDoc.data();\n\n      // Check if there's a budget for this category\n      if (budgets[category]) {\n        // Get current month expenses for this category\n        const currentDate = new Date();\n        const currentMonth = currentDate.getMonth();\n        const currentYear = currentDate.getFullYear();\n        const monthlyExpenses = allExpenses.filter(expense => {\n          if (!expense.date) return false;\n          try {\n            const expenseDate = new Date(expense.date);\n            return expenseDate.getMonth() === currentMonth && expenseDate.getFullYear() === currentYear && expense.category === category && expense.userId === currentUser.uid;\n          } catch (e) {\n            console.error('Invalid date format:', expense.date);\n            return false;\n          }\n        });\n        const totalSpent = monthlyExpenses.reduce((sum, expense) => {\n          const amount = parseFloat(expense.amount);\n          return sum + (isNaN(amount) ? 0 : amount);\n        }, 0);\n        const budgetAmount = parseFloat(budgets[category]);\n        if (!isNaN(budgetAmount) && totalSpent > budgetAmount) {\n          var _currentUser$preferen;\n          // Create new alert\n          const newAlert = {\n            message: `Budget alert: You've exceeded your ${category} budget of $${budgetAmount.toFixed(2)}`,\n            category: category,\n            read: false,\n            date: new Date().toISOString(),\n            userId: currentUser.uid\n          };\n\n          // Add to Firestore\n          const alertRef = await addDoc(collection(db, 'alerts'), newAlert);\n\n          // Send email alert if user has enabled email notifications\n          if ((currentUser === null || currentUser === void 0 ? void 0 : (_currentUser$preferen = currentUser.preferences) === null || _currentUser$preferen === void 0 ? void 0 : _currentUser$preferen.emailNotifications) !== false) {\n            if (currentUser.email) {\n              sendBudgetAlertEmail(currentUser, category, budgetAmount, totalSpent).then(result => {\n                setEmailStatus({\n                  sent: result.success,\n                  error: result.success ? null : result.message\n                });\n              }).catch(error => {\n                setEmailStatus({\n                  sent: false,\n                  error: error.message || 'Error sending email'\n                });\n              });\n            } else {\n              setEmailStatus({\n                sent: false,\n                error: \"No email address found for user\"\n              });\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error checking budget alerts:', error);\n    }\n  };\n\n  // Mark an alert as read\n  const markAlertAsRead = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      const alertRef = doc(db, 'alerts', id);\n      await updateDoc(alertRef, {\n        read: true\n      });\n      return true;\n    } catch (error) {\n      console.error('Error marking alert as read:', error);\n      return false;\n    }\n  };\n\n  // Delete an alert\n  const deleteAlert = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      await deleteDoc(doc(db, 'alerts', id));\n      return true;\n    } catch (error) {\n      console.error('Error deleting alert:', error);\n      return false;\n    }\n  };\n\n  // Add a new expense category\n  const addExpenseCategory = async category => {\n    if (!currentUser || !category || category.trim() === '') return false;\n    try {\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      let updatedCategories;\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n\n        // Check if category already exists\n        if (currentCategories.includes(category)) {\n          return false;\n        }\n        updatedCategories = [...currentCategories, category];\n      } else {\n        updatedCategories = [...DEFAULT_EXPENSE_CATEGORIES, category];\n      }\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setExpenseCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error adding expense category:', error);\n      return false;\n    }\n  };\n\n  // Delete an expense category\n  const deleteExpenseCategory = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      // Don't delete if there are expenses using this category\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('category', '==', category), limit(1));\n      const expensesSnap = await getDocs(expensesQuery);\n      if (!expensesSnap.empty) {\n        return {\n          success: false,\n          reason: 'Category in use by existing expenses'\n        };\n      }\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\n\n        // Update Firestore\n        await setDoc(categoriesRef, {\n          categories: updatedCategories\n        });\n\n        // Update local state\n        setExpenseCategories(updatedCategories);\n      }\n\n      // Also remove any budgets for this category\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n        if (currentBudgets[category] !== undefined) {\n          delete currentBudgets[category];\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error deleting expense category:', error);\n      return {\n        success: false,\n        reason: error.message\n      };\n    }\n  };\n\n  // Edit an expense category\n  const editExpenseCategory = async (oldCategory, newCategory) => {\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\n    try {\n      // Don't allow editing the \"Other\" category\n      if (oldCategory === 'Other') return false;\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (!categoriesDoc.exists()) return false;\n      const currentCategories = categoriesDoc.data().categories || [];\n\n      // Check if the new category name already exists\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\n\n      // Check if the category is in use\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('category', '==', oldCategory), limit(1));\n      const expensesSnap = await getDocs(expensesQuery);\n      if (!expensesSnap.empty) return false;\n\n      // Update categories\n      const updatedCategories = currentCategories.map(cat => cat === oldCategory ? newCategory : cat);\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setExpenseCategories(updatedCategories);\n\n      // Update any budget for this category\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n        if (currentBudgets[oldCategory] !== undefined) {\n          const budgetAmount = currentBudgets[oldCategory];\n          delete currentBudgets[oldCategory];\n          currentBudgets[newCategory] = budgetAmount;\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error editing expense category:', error);\n      return false;\n    }\n  };\n\n  // Add a new income category\n  const addIncomeCategory = async category => {\n    if (!currentUser || !category || category.trim() === '') return false;\n    try {\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      let updatedCategories;\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n\n        // Check if category already exists\n        if (currentCategories.includes(category)) {\n          return false;\n        }\n        updatedCategories = [...currentCategories, category];\n      } else {\n        updatedCategories = [...DEFAULT_INCOME_CATEGORIES, category];\n      }\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setIncomeCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error adding income category:', error);\n      return false;\n    }\n  };\n\n  // Delete an income category\n  const deleteIncomeCategory = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      // Don't delete if there are incomes using this category\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid), where('source', '==', category), limit(1));\n      const incomesSnap = await getDocs(incomesQuery);\n      if (!incomesSnap.empty) {\n        return {\n          success: false,\n          reason: 'Category in use by existing incomes'\n        };\n      }\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\n\n        // Update Firestore\n        await setDoc(categoriesRef, {\n          categories: updatedCategories\n        });\n\n        // Update local state\n        setIncomeCategories(updatedCategories);\n      }\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error deleting income category:', error);\n      return {\n        success: false,\n        reason: error.message\n      };\n    }\n  };\n\n  // Edit an income category\n  const editIncomeCategory = async (oldCategory, newCategory) => {\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\n    try {\n      // Don't allow editing the \"Other\" category\n      if (oldCategory === 'Other') return false;\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (!categoriesDoc.exists()) return false;\n      const currentCategories = categoriesDoc.data().categories || [];\n\n      // Check if the new category name already exists\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\n\n      // Check if the category is in use\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid), where('source', '==', oldCategory), limit(1));\n      const incomesSnap = await getDocs(incomesQuery);\n      if (!incomesSnap.empty) return false;\n\n      // Update categories\n      const updatedCategories = currentCategories.map(cat => cat === oldCategory ? newCategory : cat);\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setIncomeCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error editing income category:', error);\n      return false;\n    }\n  };\n\n  // Get expenses for a specific month\n  const getMonthlyExpenses = (month, year) => {\n    if (!currentUser) return [];\n    const targetDate = new Date(year, month);\n    const targetMonth = targetDate.getMonth();\n    const targetYear = targetDate.getFullYear();\n    return expenses.filter(expense => {\n      if (!expense.date) return false;\n      try {\n        const expenseDate = new Date(expense.date);\n        return expenseDate.getMonth() === targetMonth && expenseDate.getFullYear() === targetYear && expense.userId === currentUser.uid;\n      } catch (e) {\n        return false;\n      }\n    });\n  };\n\n  // Get incomes for a specific month\n  const getMonthlyIncomes = (month, year) => {\n    if (!currentUser) return [];\n    const targetDate = new Date(year, month);\n    const targetMonth = targetDate.getMonth();\n    const targetYear = targetDate.getFullYear();\n    return incomes.filter(income => {\n      if (!income.date) return false;\n      try {\n        const incomeDate = new Date(income.date);\n        return incomeDate.getMonth() === targetMonth && incomeDate.getFullYear() === targetYear && income.userId === currentUser.uid;\n      } catch (e) {\n        return false;\n      }\n    });\n  };\n\n  // Get historical receipt scans\n  const getReceiptScans = async () => {\n    if (!currentUser) return [];\n    try {\n      const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n      const scansSnap = await getDocs(scansQuery);\n      return scansSnap.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error getting receipt scans:', error);\n      return [];\n    }\n  };\n\n  // Update an existing expense\n  const updateExpense = async (id, updatedData) => {\n    if (!currentUser || !id) return false;\n    try {\n      const expenseRef = doc(db, 'expenses', id);\n      await updateDoc(expenseRef, updatedData);\n      return true;\n    } catch (error) {\n      console.error('Error updating expense:', error);\n      return false;\n    }\n  };\n\n  // Update an existing income\n  const updateIncome = async (id, updatedData) => {\n    if (!currentUser || !id) return false;\n    try {\n      const incomeRef = doc(db, 'incomes', id);\n      await updateDoc(incomeRef, updatedData);\n      return true;\n    } catch (error) {\n      console.error('Error updating income:', error);\n      return false;\n    }\n  };\n\n  // Export data for backups\n  const exportData = async () => {\n    if (!currentUser) return null;\n    try {\n      // Get all current user data\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid));\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid));\n      const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n      const [expensesSnap, incomesSnap, scansSnap, categoriesSnap, budgetsSnap] = await Promise.all([getDocs(expensesQuery), getDocs(incomesQuery), getDocs(scansQuery), getDoc(doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories')), getDoc(doc(db, 'users', currentUser.uid, 'settings', 'budgets'))]);\n      const exportData = {\n        expenses: expensesSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        incomes: incomesSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        receiptScans: scansSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        expenseCategories: categoriesSnap.exists() ? categoriesSnap.data().categories : DEFAULT_EXPENSE_CATEGORIES,\n        incomeCategories: incomeCategories,\n        budgets: budgetsSnap.exists() ? budgetsSnap.data() : {},\n        exportDate: new Date().toISOString(),\n        userId: currentUser.uid\n      };\n      return exportData;\n    } catch (error) {\n      console.error('Error exporting data:', error);\n      return null;\n    }\n  };\n\n  // Import data from backups\n  const importData = async data => {\n    if (!currentUser || !data) return false;\n    try {\n      // Validate data structure\n      if (!data.expenses || !data.incomes || !data.budgets || !data.expenseCategories || !data.incomeCategories) {\n        console.error('Invalid import data structure');\n        return false;\n      }\n\n      // Begin batch operations\n      const batch = db.batch();\n\n      // Update expense categories\n      const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      batch.set(expenseCategoriesRef, {\n        categories: data.expenseCategories\n      });\n\n      // Update income categories\n      const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      batch.set(incomeCategoriesRef, {\n        categories: data.incomeCategories\n      });\n\n      // Update budgets\n      const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      batch.set(budgetsRef, data.budgets);\n\n      // Commit the batch\n      await batch.commit();\n\n      // Update local state\n      setExpenseCategories(data.expenseCategories);\n      setIncomeCategories(data.incomeCategories);\n      setBudgets(data.budgets);\n\n      // Handle expense and income imports separately (may be too many for a single batch)\n      for (const expense of data.expenses) {\n        try {\n          const {\n            id,\n            ...expenseData\n          } = expense;\n          expenseData.userId = currentUser.uid; // Ensure correct user ID\n          await addDoc(collection(db, 'expenses'), expenseData);\n        } catch (e) {\n          console.error('Error importing expense:', e);\n          // Continue with other imports\n        }\n      }\n      for (const income of data.incomes) {\n        try {\n          const {\n            id,\n            ...incomeData\n          } = income;\n          incomeData.userId = currentUser.uid; // Ensure correct user ID\n          await addDoc(collection(db, 'incomes'), incomeData);\n        } catch (e) {\n          console.error('Error importing income:', e);\n          // Continue with other imports\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error importing data:', error);\n      return false;\n    }\n  };\n\n  // Get spending insights\n  const getSpendingInsights = async (months = 3) => {\n    if (!currentUser || months < 1) return null;\n    try {\n      const currentDate = new Date();\n      const insights = {\n        topCategories: [],\n        monthlyTotals: [],\n        yearlyComparison: {},\n        receiptUsage: {\n          total: 0,\n          percentage: 0\n        }\n      };\n\n      // Get relevant expenses from Firestore\n      const startDate = new Date();\n      startDate.setMonth(startDate.getMonth() - months);\n\n      // Format for Firestore query\n      const startDateString = startDate.toISOString();\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('date', '>=', startDateString));\n      const expensesSnap = await getDocs(expensesQuery);\n      const relevantExpenses = expensesSnap.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n\n      // Calculate top spending categories\n      const categoryTotals = {};\n      relevantExpenses.forEach(expense => {\n        const {\n          category,\n          amount\n        } = expense;\n        if (!category) return;\n        categoryTotals[category] = (categoryTotals[category] || 0) + parseFloat(amount || 0);\n      });\n      insights.topCategories = Object.entries(categoryTotals).map(([category, total]) => ({\n        category,\n        total\n      })).sort((a, b) => b.total - a.total).slice(0, 5); // Get top 5\n\n      // Calculate monthly totals\n      const monthlyData = {};\n      relevantExpenses.forEach(expense => {\n        if (!expense.date) return;\n        const expenseDate = new Date(expense.date);\n        const monthYear = `${expenseDate.getFullYear()}-${expenseDate.getMonth() + 1}`;\n        if (!monthlyData[monthYear]) {\n          monthlyData[monthYear] = {\n            month: expenseDate.getMonth(),\n            year: expenseDate.getFullYear(),\n            total: 0,\n            label: expenseDate.toLocaleString('default', {\n              month: 'short',\n              year: 'numeric'\n            })\n          };\n        }\n        monthlyData[monthYear].total += parseFloat(expense.amount || 0);\n      });\n      insights.monthlyTotals = Object.values(monthlyData).sort((a, b) => {\n        if (a.year !== b.year) return a.year - b.year;\n        return a.month - b.month;\n      });\n\n      // Calculate receipt usage statistics\n      const receiptsCount = relevantExpenses.filter(expense => expense.fromReceipt).length;\n      insights.receiptUsage = {\n        total: receiptsCount,\n        percentage: relevantExpenses.length > 0 ? receiptsCount / relevantExpenses.length * 100 : 0\n      };\n      return insights;\n    } catch (error) {\n      console.error('Error generating spending insights:', error);\n      return null;\n    }\n  };\n\n  // Load categories and other settings from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setExpenseCategories([]);\n      setIncomeCategories([]);\n      setBudgets({});\n      return;\n    }\n\n    // Load categories and budgets\n    const fetchSettings = async () => {\n      try {\n        // Get expense categories\n        const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n        const expenseCategoriesDoc = await getDoc(expenseCategoriesRef);\n        if (expenseCategoriesDoc.exists()) {\n          setExpenseCategories(expenseCategoriesDoc.data().categories || DEFAULT_EXPENSE_CATEGORIES);\n        } else {\n          // Create default categories if none exist\n          await setDoc(expenseCategoriesRef, {\n            categories: DEFAULT_EXPENSE_CATEGORIES\n          });\n          setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\n        }\n\n        // Get income categories\n        const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n        const incomeCategoriesDoc = await getDoc(incomeCategoriesRef);\n        if (incomeCategoriesDoc.exists()) {\n          setIncomeCategories(incomeCategoriesDoc.data().categories || DEFAULT_INCOME_CATEGORIES);\n        } else {\n          // Create default categories if none exist\n          await setDoc(incomeCategoriesRef, {\n            categories: DEFAULT_INCOME_CATEGORIES\n          });\n          setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\n        }\n\n        // Get budgets\n        const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n        const budgetsDoc = await getDoc(budgetsRef);\n        if (budgetsDoc.exists()) {\n          setBudgets(budgetsDoc.data());\n        }\n      } catch (error) {\n        console.error('Error loading settings:', error);\n        setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\n        setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\n      }\n    };\n    fetchSettings();\n  }, [currentUser]);\n\n  // Load alerts from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setAlerts([]);\n      return;\n    }\n\n    // Query Firestore for alerts\n    const alertsQuery = query(collection(db, 'alerts'), where('userId', '==', currentUser.uid), where('read', '==', false));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(alertsQuery, snapshot => {\n      const alertsList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setAlerts(alertsList);\n    }, error => {\n      console.error(\"Error getting alerts:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Load receipt scans from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setReceiptScans([]);\n      return;\n    }\n\n    // Query Firestore for receipt scans\n    const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(scansQuery, snapshot => {\n      const scansList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setReceiptScans(scansList);\n    }, error => {\n      console.error(\"Error getting receipt scans:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n  return /*#__PURE__*/_jsxDEV(ExpenseContext.Provider, {\n    value: {\n      expenses,\n      incomes,\n      budgets,\n      alerts,\n      expenseCategories,\n      incomeCategories,\n      receiptScanStatus,\n      receiptScans,\n      emailStatus,\n      loading,\n      addExpense,\n      addIncome,\n      deleteExpense,\n      deleteIncome,\n      updateExpense,\n      updateIncome,\n      updateBudget,\n      deleteBudget,\n      markAlertAsRead,\n      deleteAlert,\n      addExpenseCategory,\n      deleteExpenseCategory,\n      editExpenseCategory,\n      addIncomeCategory,\n      deleteIncomeCategory,\n      editIncomeCategory,\n      scanReceipt,\n      addExpenseFromReceipt,\n      rejectScannedReceipt,\n      getMonthlyExpenses,\n      getMonthlyIncomes,\n      getReceiptScans,\n      exportData,\n      importData,\n      getSpendingInsights\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1368,\n    columnNumber: 5\n  }, this);\n};\n_s(ExpenseProvider, \"jN6mlIMGqoim1aOMvmQUTdySb1Y=\");\n_c = ExpenseProvider;\nvar _c;\n$RefreshReg$(_c, \"ExpenseProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","AuthContext","sendBudgetAlertEmail","scanReceiptImage","parseReceiptData","db","storage","collection","addDoc","doc","deleteDoc","updateDoc","query","where","getDocs","onSnapshot","getDoc","setDoc","limit","ref","uploadBytes","getDownloadURL","jsxDEV","_jsxDEV","ExpenseContext","ExpenseProvider","children","_s","expenses","setExpenses","incomes","setIncomes","budgets","setBudgets","alerts","setAlerts","loading","setLoading","emailStatus","setEmailStatus","sent","error","expenseCategories","setExpenseCategories","incomeCategories","setIncomeCategories","receiptScanStatus","setReceiptScanStatus","scanning","data","receiptScans","setReceiptScans","currentUser","DEFAULT_EXPENSE_CATEGORIES","DEFAULT_INCOME_CATEGORIES","expensesQuery","uid","unsubscribe","snapshot","expensesList","docs","map","id","console","incomesQuery","incomesList","timer","setTimeout","clearTimeout","prevState","addExpense","expense","newExpense","category","amount","parseFloat","date","Date","toISOString","slice","description","userId","createdAt","isSplit","userShare","log","docRef","firestoreError","scanReceipt","imageFile","success","name","imageUrl","URL","createObjectURL","extractedData","merchantName","receiptNumber","Math","floor","random","items","confidence","taxAmount","currencyCode","fromReceipt","receiptImageUrl","notes","message","addExpenseFromReceipt","expenseData","modifications","finalExpenseData","result","receiptScanId","scanRef","String","status","rejectScannedReceipt","scanId","_receiptScanStatus$da","mapVendorToCategory","vendorName","vendorNameLower","toLowerCase","categoryMappings","keyword","Object","entries","includes","addIncome","income","source","isNaN","newIncome","deleteExpense","expenseRef","expenseSnap","exists","scanSnap","deleteIncome","updateBudget","trim","budgetRef","budgetDoc","prevBudgets","deleteBudget","currentBudgets","undefined","checkBudgetAlerts","allExpenses","currentDate","currentMonth","getMonth","currentYear","getFullYear","monthlyExpenses","filter","expenseDate","e","totalSpent","reduce","sum","budgetAmount","_currentUser$preferen","newAlert","toFixed","read","alertRef","preferences","emailNotifications","email","then","catch","markAlertAsRead","deleteAlert","addExpenseCategory","categoriesRef","categoriesDoc","updatedCategories","currentCategories","categories","deleteExpenseCategory","expensesSnap","empty","reason","cat","editExpenseCategory","oldCategory","newCategory","addIncomeCategory","deleteIncomeCategory","incomesSnap","editIncomeCategory","getMonthlyExpenses","month","year","targetDate","targetMonth","targetYear","getMonthlyIncomes","incomeDate","getReceiptScans","scansQuery","scansSnap","updateExpense","updatedData","updateIncome","incomeRef","exportData","categoriesSnap","budgetsSnap","Promise","all","exportDate","importData","batch","expenseCategoriesRef","set","incomeCategoriesRef","budgetsRef","commit","incomeData","getSpendingInsights","months","insights","topCategories","monthlyTotals","yearlyComparison","receiptUsage","total","percentage","startDate","setMonth","startDateString","relevantExpenses","categoryTotals","forEach","sort","a","b","monthlyData","monthYear","label","toLocaleString","values","receiptsCount","length","fetchSettings","expenseCategoriesDoc","incomeCategoriesDoc","budgetsDoc","alertsQuery","alertsList","scansList","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/tejit/OneDrive/Desktop/expence tracker final/expence-tracker/src/context/ExpenseContext.js"],"sourcesContent":["// src/context/ExpenseContext.js\r\nimport React, { createContext, useState, useEffect, useContext } from 'react';\r\nimport { AuthContext } from './AuthContext';\r\nimport { sendBudgetAlertEmail } from '../services/EmailService';\r\nimport { scanReceiptImage, parseReceiptData } from '../services/ReceiptScanningService';\r\n// Add Firebase imports\r\nimport { db, storage } from '../config/firebase';\r\nimport { \r\n  collection, \r\n  addDoc, \r\n  doc, \r\n  deleteDoc, \r\n  updateDoc, \r\n  query, \r\n  where, \r\n  getDocs, \r\n  onSnapshot, \r\n  getDoc,\r\n  setDoc,\r\n  limit \r\n} from 'firebase/firestore';\r\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\r\n\r\nexport const ExpenseContext = createContext();\r\n\r\nexport const ExpenseProvider = ({ children }) => {\r\n  const [expenses, setExpenses] = useState([]);\r\n  const [incomes, setIncomes] = useState([]);\r\n  const [budgets, setBudgets] = useState({});\r\n  const [alerts, setAlerts] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [emailStatus, setEmailStatus] = useState({ sent: false, error: null });\r\n  const [expenseCategories, setExpenseCategories] = useState([]);\r\n  const [incomeCategories, setIncomeCategories] = useState([]);\r\n  // Add new state for receipt scanning\r\n  const [receiptScanStatus, setReceiptScanStatus] = useState({ \r\n    scanning: false, \r\n    error: null, \r\n    data: null \r\n  });\r\n  // Track receipt scan history\r\n  const [receiptScans, setReceiptScans] = useState([]);\r\n  \r\n  const { currentUser } = useContext(AuthContext);\r\n  \r\n  // Default categories if none are found\r\n  const DEFAULT_EXPENSE_CATEGORIES = [\r\n    'Food', 'Housing', 'Transportation', 'Entertainment', \r\n    'Utilities', 'Healthcare', 'Shopping', 'Personal Care', 'Education', 'Other'\r\n  ];\r\n  \r\n  const DEFAULT_INCOME_CATEGORIES = [\r\n    'Salary', 'Freelance', 'Investment', 'Gift', \r\n    'Business', 'Side Hustle', 'Rental', 'Other'\r\n  ];\r\n  \r\n  // Load expenses from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setExpenses([]);\r\n      setLoading(false);\r\n      return;\r\n    }\r\n    \r\n    setLoading(true);\r\n    \r\n    // Query Firestore for expenses\r\n    const expensesQuery = query(\r\n      collection(db, 'expenses'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(expensesQuery, (snapshot) => {\r\n      const expensesList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setExpenses(expensesList);\r\n      setLoading(false);\r\n    }, (error) => {\r\n      console.error(\"Error getting expenses:\", error);\r\n      setLoading(false);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Load incomes from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setIncomes([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for incomes\r\n    const incomesQuery = query(\r\n      collection(db, 'incomes'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(incomesQuery, (snapshot) => {\r\n      const incomesList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setIncomes(incomesList);\r\n    }, (error) => {\r\n      console.error(\"Error getting incomes:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Clear email status after some time\r\n  useEffect(() => {\r\n    if (emailStatus.sent || emailStatus.error) {\r\n      const timer = setTimeout(() => {\r\n        setEmailStatus({ sent: false, error: null });\r\n      }, 5000);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [emailStatus]);\r\n  \r\n  // Clear receipt scan data after processing\r\n  useEffect(() => {\r\n    if (receiptScanStatus.data && !receiptScanStatus.scanning) {\r\n      const timer = setTimeout(() => {\r\n        setReceiptScanStatus(prevState => ({\r\n          ...prevState, \r\n          data: null\r\n        }));\r\n      }, 30000); // Give user 30 seconds to review before clearing\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [receiptScanStatus]);\r\n  \r\n  // Add a new expense with validation\r\n  // Updated addExpense function for ExpenseContext.js\r\n  // Fix in ExpenseContext.js\r\n  const addExpense = async (expense) => {\r\n    if (!currentUser) {\r\n      console.error('Cannot add expense: No authenticated user');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      // Ensure expense has all required fields\r\n      const newExpense = {\r\n        category: expense.category || 'Other',\r\n        amount: parseFloat(expense.amount) || 0,\r\n        date: expense.date || new Date().toISOString().slice(0, 10),\r\n        description: expense.description || '',\r\n        userId: currentUser.uid, // Make sure this is always set\r\n        createdAt: new Date().toISOString(),\r\n        // Additional fields\r\n        isSplit: expense.isSplit || false,\r\n        userShare: expense.userShare || parseFloat(expense.amount) || 0,\r\n      };\r\n      \r\n      // Log for debugging\r\n      console.log('Adding expense to Firestore:', newExpense);\r\n      \r\n      // Add to Firestore with error handling\r\n      try {\r\n        const docRef = await addDoc(collection(db, 'expenses'), newExpense);\r\n        console.log('Expense added with ID:', docRef.id);\r\n        return docRef.id;\r\n      } catch (firestoreError) {\r\n        console.error('Firestore error adding expense:', firestoreError);\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error adding expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // In ExpenseContext.js - scanReceipt function\r\n  const scanReceipt = async (imageFile) => {\r\n    if (!currentUser) {\r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: 'User not logged in',\r\n        data: null\r\n      });\r\n      return { success: false, error: 'User not logged in' };\r\n    }\r\n    \r\n    if (!imageFile) {\r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: 'No image provided',\r\n        data: null\r\n      });\r\n      return { success: false, error: 'No image provided' };\r\n    }\r\n    \r\n    try {\r\n      // Set scanning status first\r\n      setReceiptScanStatus({\r\n        scanning: true,\r\n        error: null,\r\n        data: null\r\n      });\r\n      \r\n      console.log('Processing receipt image:', imageFile.name);\r\n      \r\n      // Generate a temporary URL for the uploaded image\r\n      const imageUrl = URL.createObjectURL(imageFile);\r\n      \r\n      // Instead of returning hardcoded mock data, return empty fields for user to fill\r\n      const extractedData = {\r\n        // Empty or default values\r\n        merchantName: \"\",\r\n        amount: \"\",\r\n        date: new Date().toISOString().slice(0, 10), // Default to today\r\n        receiptNumber: `REC-${Math.floor(Math.random() * 10000)}`,\r\n        items: [],\r\n        confidence: 1.0,\r\n        taxAmount: 0,\r\n        currencyCode: 'USD',\r\n        imageUrl: imageUrl,\r\n        success: true\r\n      };\r\n      \r\n      console.log('Ready for user input with receipt image');\r\n      \r\n      // Update the receipt scan status with the empty fields for user input\r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: null,\r\n        data: {\r\n          amount: \"\",\r\n          description: \"\",\r\n          category: \"Food\", // Default category\r\n          date: extractedData.date,\r\n          fromReceipt: true,\r\n          receiptImageUrl: imageUrl,\r\n          notes: \"\"\r\n        }\r\n      });\r\n      \r\n      return {\r\n        success: true,\r\n        data: extractedData,\r\n        imageUrl: imageUrl\r\n      };\r\n    } catch (error) {\r\n      console.error('Error scanning receipt:', error);\r\n      \r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: error.message || 'Error scanning receipt',\r\n        data: null\r\n      });\r\n      \r\n      return {\r\n        success: false,\r\n        error: error.message || 'Error scanning receipt'\r\n      };\r\n    }\r\n  };\r\n  \r\n  // Function to add the expense from a scanned receipt\r\n  const addExpenseFromReceipt = async (expenseData, modifications = {}) => {\r\n    if (!currentUser) return false;\r\n    \r\n    try {\r\n      // Combine scanned data with any user modifications\r\n      const finalExpenseData = {\r\n        ...expenseData,\r\n        ...modifications,\r\n        fromReceipt: true\r\n      };\r\n      \r\n      // Use the existing addExpense function\r\n      const result = await addExpense(finalExpenseData);\r\n      \r\n      if (result && finalExpenseData.receiptScanId) {\r\n        // Update the scan record status in Firestore\r\n        const scanRef = doc(db, 'receiptScans', String(finalExpenseData.receiptScanId));\r\n        await updateDoc(scanRef, { status: 'applied' });\r\n        \r\n        // Clear the scanned data after successful addition\r\n        setReceiptScanStatus(prevState => ({\r\n          ...prevState,\r\n          data: null\r\n        }));\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('Error adding expense from receipt:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Function to reject a scanned receipt\r\n  const rejectScannedReceipt = async (scanId) => {\r\n    if (!scanId) return false;\r\n    \r\n    try {\r\n      // Update the scan record status in Firestore\r\n      const scanRef = doc(db, 'receiptScans', String(scanId));\r\n      await updateDoc(scanRef, { status: 'rejected' });\r\n      \r\n      // Clear any pending scan data with this ID\r\n      if (receiptScanStatus.data?.receiptScanId === scanId) {\r\n        setReceiptScanStatus({\r\n          scanning: false,\r\n          error: null,\r\n          data: null\r\n        });\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error rejecting scanned receipt:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Helper function to map vendor names to appropriate categories\r\n  const mapVendorToCategory = (vendorName) => {\r\n    const vendorNameLower = vendorName.toLowerCase();\r\n    \r\n    // Simple mapping logic - can be expanded based on common vendors\r\n    if (!vendorName) return 'Other';\r\n    \r\n    const categoryMappings = {\r\n      'restaurant': 'Food',\r\n      'cafÃ©': 'Food',\r\n      'cafe': 'Food',\r\n      'grocery': 'Food',\r\n      'supermarket': 'Food',\r\n      'market': 'Food',\r\n      'gas': 'Transportation',\r\n      'fuel': 'Transportation',\r\n      'uber': 'Transportation',\r\n      'lyft': 'Transportation',\r\n      'taxi': 'Transportation',\r\n      'pharmacy': 'Healthcare',\r\n      'drug': 'Healthcare',\r\n      'doctor': 'Healthcare',\r\n      'clinic': 'Healthcare',\r\n      'hospital': 'Healthcare',\r\n      'rent': 'Housing',\r\n      'mortgage': 'Housing',\r\n      'netflix': 'Entertainment',\r\n      'spotify': 'Entertainment',\r\n      'cinema': 'Entertainment',\r\n      'movie': 'Entertainment',\r\n      'theater': 'Entertainment',\r\n      'amazon': 'Shopping',\r\n      'walmart': 'Shopping',\r\n      'target': 'Shopping',\r\n      'utility': 'Utilities',\r\n      'electric': 'Utilities',\r\n      'water': 'Utilities',\r\n      'gas bill': 'Utilities',\r\n      'phone': 'Utilities',\r\n      'internet': 'Utilities',\r\n      'school': 'Education',\r\n      'college': 'Education',\r\n      'university': 'Education',\r\n      'tuition': 'Education',\r\n      'book': 'Education',\r\n      'haircut': 'Personal Care',\r\n      'salon': 'Personal Care',\r\n      'spa': 'Personal Care',\r\n      'gym': 'Personal Care'\r\n    };\r\n    \r\n    for (const [keyword, category] of Object.entries(categoryMappings)) {\r\n      if (vendorNameLower.includes(keyword)) {\r\n        return category;\r\n      }\r\n    }\r\n    \r\n    return 'Other';\r\n  };\r\n  \r\n  // Add a new income with validation\r\n  const addIncome = async (income) => {\r\n    if (!currentUser) {\r\n      console.error('Cannot add income: No authenticated user');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      // Log for debugging\r\n      console.log('Adding income with data:', income);\r\n      \r\n      // Validate income data\r\n      if (!income.source) {\r\n        console.error('Missing source in income');\r\n        return false;\r\n      }\r\n      \r\n      const amount = parseFloat(income.amount);\r\n      if (isNaN(amount) || amount <= 0) {\r\n        console.error('Invalid income amount:', income.amount);\r\n        return false;\r\n      }\r\n      \r\n      // Create new income object\r\n      const newIncome = {\r\n        source: income.source,\r\n        amount: amount,\r\n        date: income.date || new Date().toISOString().slice(0, 10),\r\n        description: income.description || '',\r\n        userId: currentUser.uid,\r\n        createdAt: new Date().toISOString()\r\n      };\r\n      \r\n      console.log('Prepared income object for Firestore:', newIncome);\r\n      \r\n      // Add to Firestore with explicit error handling\r\n      try {\r\n        const docRef = await addDoc(collection(db, 'incomes'), newIncome);\r\n        console.log('Income added successfully with ID:', docRef.id);\r\n        return docRef.id;\r\n      } catch (firestoreError) {\r\n        console.error('Firestore error adding income:', firestoreError);\r\n        throw firestoreError; // Rethrow to be caught by outer try/catch\r\n      }\r\n    } catch (error) {\r\n      console.error('Error adding income:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an expense\r\n  const deleteExpense = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      // Get the expense before deleting it (to check for receipt info)\r\n      const expenseRef = doc(db, 'expenses', id);\r\n      const expenseSnap = await getDoc(expenseRef);\r\n      \r\n      if (expenseSnap.exists()) {\r\n        const expenseData = expenseSnap.data();\r\n        \r\n        // Delete the expense document\r\n        await deleteDoc(expenseRef);\r\n        \r\n        // If this was a receipt-based expense, update the scan record\r\n        if (expenseData.receiptScanId) {\r\n          const scanRef = doc(db, 'receiptScans', String(expenseData.receiptScanId));\r\n          const scanSnap = await getDoc(scanRef);\r\n          \r\n          if (scanSnap.exists()) {\r\n            await updateDoc(scanRef, { status: 'rejected' });\r\n          }\r\n        }\r\n      } else {\r\n        // Document not found\r\n        console.error('Expense not found');\r\n        return false;\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an income\r\n  const deleteIncome = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      await deleteDoc(doc(db, 'incomes', id));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting income:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Update budget settings\r\n  const updateBudget = async (category, amount) => {\r\n    if (!currentUser || !category || category.trim() === '' || isNaN(parseFloat(amount))) {\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        // Update existing budgets document\r\n        await updateDoc(budgetRef, {\r\n          [category]: parseFloat(amount)\r\n        });\r\n      } else {\r\n        // Create new budgets document\r\n        await setDoc(budgetRef, {\r\n          [category]: parseFloat(amount)\r\n        });\r\n      }\r\n      \r\n      // Update local state\r\n      setBudgets(prevBudgets => ({\r\n        ...prevBudgets,\r\n        [category]: parseFloat(amount)\r\n      }));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating budget:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete a budget\r\n  const deleteBudget = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        // Remove the category from the budgets\r\n        if (currentBudgets[category] !== undefined) {\r\n          delete currentBudgets[category];\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting budget:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Check if adding this expense exceeds the budget\r\n  const checkBudgetAlerts = async (newExpense, allExpenses = expenses) => {\r\n    if (!currentUser) return; // Don't process if no user is logged in\r\n    if (!newExpense || !newExpense.category) return;\r\n    \r\n    const { category } = newExpense;\r\n    \r\n    // Get budgets from Firestore\r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (!budgetDoc.exists()) return;\r\n      \r\n      const budgets = budgetDoc.data();\r\n      \r\n      // Check if there's a budget for this category\r\n      if (budgets[category]) {\r\n        // Get current month expenses for this category\r\n        const currentDate = new Date();\r\n        const currentMonth = currentDate.getMonth();\r\n        const currentYear = currentDate.getFullYear();\r\n        \r\n        const monthlyExpenses = allExpenses.filter(expense => {\r\n          if (!expense.date) return false;\r\n          \r\n          try {\r\n            const expenseDate = new Date(expense.date);\r\n            return expenseDate.getMonth() === currentMonth && \r\n                  expenseDate.getFullYear() === currentYear &&\r\n                  expense.category === category &&\r\n                  expense.userId === currentUser.uid;\r\n          } catch (e) {\r\n            console.error('Invalid date format:', expense.date);\r\n            return false;\r\n          }\r\n        });\r\n        \r\n        const totalSpent = monthlyExpenses.reduce((sum, expense) => {\r\n          const amount = parseFloat(expense.amount);\r\n          return sum + (isNaN(amount) ? 0 : amount);\r\n        }, 0);\r\n        \r\n        const budgetAmount = parseFloat(budgets[category]);\r\n        \r\n        if (!isNaN(budgetAmount) && totalSpent > budgetAmount) {\r\n          // Create new alert\r\n          const newAlert = {\r\n            message: `Budget alert: You've exceeded your ${category} budget of $${budgetAmount.toFixed(2)}`,\r\n            category: category,\r\n            read: false,\r\n            date: new Date().toISOString(),\r\n            userId: currentUser.uid\r\n          };\r\n          \r\n          // Add to Firestore\r\n          const alertRef = await addDoc(collection(db, 'alerts'), newAlert);\r\n          \r\n          // Send email alert if user has enabled email notifications\r\n          if (currentUser?.preferences?.emailNotifications !== false) {\r\n            if (currentUser.email) {\r\n              sendBudgetAlertEmail(\r\n                currentUser,\r\n                category,\r\n                budgetAmount,\r\n                totalSpent\r\n              ).then(result => {\r\n                setEmailStatus({ \r\n                  sent: result.success, \r\n                  error: result.success ? null : result.message \r\n                });\r\n              }).catch(error => {\r\n                setEmailStatus({ \r\n                  sent: false, \r\n                  error: error.message || 'Error sending email'\r\n                });\r\n              });\r\n            } else {\r\n              setEmailStatus({ \r\n                sent: false, \r\n                error: \"No email address found for user\"\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error checking budget alerts:', error);\r\n    }\r\n  };\r\n  \r\n  // Mark an alert as read\r\n  const markAlertAsRead = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const alertRef = doc(db, 'alerts', id);\r\n      await updateDoc(alertRef, { read: true });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error marking alert as read:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an alert\r\n  const deleteAlert = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      await deleteDoc(doc(db, 'alerts', id));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting alert:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Add a new expense category\r\n  const addExpenseCategory = async (category) => {\r\n    if (!currentUser || !category || category.trim() === '') return false;\r\n    \r\n    try {\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      let updatedCategories;\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        \r\n        // Check if category already exists\r\n        if (currentCategories.includes(category)) {\r\n          return false;\r\n        }\r\n        \r\n        updatedCategories = [...currentCategories, category];\r\n      } else {\r\n        updatedCategories = [...DEFAULT_EXPENSE_CATEGORIES, category];\r\n      }\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setExpenseCategories(updatedCategories);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error adding expense category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an expense category\r\n  const deleteExpenseCategory = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      // Don't delete if there are expenses using this category\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('category', '==', category),\r\n        limit(1)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      if (!expensesSnap.empty) {\r\n        return { success: false, reason: 'Category in use by existing expenses' };\r\n      }\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\r\n        \r\n        // Update Firestore\r\n        await setDoc(categoriesRef, { categories: updatedCategories });\r\n        \r\n        // Update local state\r\n        setExpenseCategories(updatedCategories);\r\n      }\r\n      \r\n      // Also remove any budgets for this category\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        if (currentBudgets[category] !== undefined) {\r\n          delete currentBudgets[category];\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Error deleting expense category:', error);\r\n      return { success: false, reason: error.message };\r\n    }\r\n  };\r\n  \r\n  // Edit an expense category\r\n  const editExpenseCategory = async (oldCategory, newCategory) => {\r\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\r\n    \r\n    try {\r\n      // Don't allow editing the \"Other\" category\r\n      if (oldCategory === 'Other') return false;\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (!categoriesDoc.exists()) return false;\r\n      \r\n      const currentCategories = categoriesDoc.data().categories || [];\r\n      \r\n      // Check if the new category name already exists\r\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\r\n      \r\n      // Check if the category is in use\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('category', '==', oldCategory),\r\n        limit(1)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      if (!expensesSnap.empty) return false;\r\n      \r\n      // Update categories\r\n      const updatedCategories = currentCategories.map(cat => \r\n        cat === oldCategory ? newCategory : cat\r\n      );\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setExpenseCategories(updatedCategories);\r\n      \r\n      // Update any budget for this category\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        if (currentBudgets[oldCategory] !== undefined) {\r\n          const budgetAmount = currentBudgets[oldCategory];\r\n          delete currentBudgets[oldCategory];\r\n          currentBudgets[newCategory] = budgetAmount;\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error editing expense category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Add a new income category\r\n  const addIncomeCategory = async (category) => {\r\n    if (!currentUser || !category || category.trim() === '') return false;\r\n    \r\n    try {\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      let updatedCategories;\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        \r\n        // Check if category already exists\r\n        if (currentCategories.includes(category)) {\r\n          return false;\r\n        }\r\n        \r\n        updatedCategories = [...currentCategories, category];\r\n      } else {\r\n        updatedCategories = [...DEFAULT_INCOME_CATEGORIES, category];\r\n      }\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setIncomeCategories(updatedCategories);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error adding income category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an income category\r\n  const deleteIncomeCategory = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      // Don't delete if there are incomes using this category\r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('source', '==', category),\r\n        limit(1)\r\n      );\r\n      \r\n      const incomesSnap = await getDocs(incomesQuery);\r\n      \r\n      if (!incomesSnap.empty) {\r\n        return { success: false, reason: 'Category in use by existing incomes' };\r\n      }\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\r\n        \r\n        // Update Firestore\r\n        await setDoc(categoriesRef, { categories: updatedCategories });\r\n        \r\n        // Update local state\r\n        setIncomeCategories(updatedCategories);\r\n      }\r\n      \r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Error deleting income category:', error);\r\n      return { success: false, reason: error.message };\r\n    }\r\n  };\r\n  \r\n  // Edit an income category\r\n  const editIncomeCategory = async (oldCategory, newCategory) => {\r\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\r\n    \r\n    try {\r\n      // Don't allow editing the \"Other\" category\r\n      if (oldCategory === 'Other') return false;\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (!categoriesDoc.exists()) return false;\r\n      \r\n      const currentCategories = categoriesDoc.data().categories || [];\r\n      \r\n      // Check if the new category name already exists\r\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\r\n      \r\n      // Check if the category is in use\r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('source', '==', oldCategory),\r\n        limit(1)\r\n      );\r\n      \r\n      const incomesSnap = await getDocs(incomesQuery);\r\n      \r\n      if (!incomesSnap.empty) return false;\r\n      \r\n      // Update categories\r\n      const updatedCategories = currentCategories.map(cat => \r\n        cat === oldCategory ? newCategory : cat\r\n      );\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setIncomeCategories(updatedCategories);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error editing income category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Get expenses for a specific month\r\n  const getMonthlyExpenses = (month, year) => {\r\n    if (!currentUser) return [];\r\n    \r\n    const targetDate = new Date(year, month);\r\n    const targetMonth = targetDate.getMonth();\r\n    const targetYear = targetDate.getFullYear();\r\n    \r\n    return expenses.filter(expense => {\r\n      if (!expense.date) return false;\r\n      \r\n      try {\r\n        const expenseDate = new Date(expense.date);\r\n        return expenseDate.getMonth() === targetMonth && \r\n              expenseDate.getFullYear() === targetYear &&\r\n              expense.userId === currentUser.uid;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    });\r\n  };\r\n  \r\n  // Get incomes for a specific month\r\n  const getMonthlyIncomes = (month, year) => {\r\n    if (!currentUser) return [];\r\n    \r\n    const targetDate = new Date(year, month);\r\n    const targetMonth = targetDate.getMonth();\r\n    const targetYear = targetDate.getFullYear();\r\n    \r\n    return incomes.filter(income => {\r\n      if (!income.date) return false;\r\n      \r\n      try {\r\n        const incomeDate = new Date(income.date);\r\n        return incomeDate.getMonth() === targetMonth && \r\n              incomeDate.getFullYear() === targetYear &&\r\n              income.userId === currentUser.uid;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    });\r\n  };\r\n  \r\n  // Get historical receipt scans\r\n  const getReceiptScans = async () => {\r\n    if (!currentUser) return [];\r\n    \r\n    try {\r\n      const scansQuery = query(\r\n        collection(db, 'receiptScans'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const scansSnap = await getDocs(scansQuery);\r\n      \r\n      return scansSnap.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error getting receipt scans:', error);\r\n      return [];\r\n    }\r\n  };\r\n  \r\n  // Update an existing expense\r\n  const updateExpense = async (id, updatedData) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const expenseRef = doc(db, 'expenses', id);\r\n      await updateDoc(expenseRef, updatedData);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Update an existing income\r\n  const updateIncome = async (id, updatedData) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const incomeRef = doc(db, 'incomes', id);\r\n      await updateDoc(incomeRef, updatedData);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating income:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Export data for backups\r\n  const exportData = async () => {\r\n    if (!currentUser) return null;\r\n    \r\n    try {\r\n      // Get all current user data\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const scansQuery = query(\r\n        collection(db, 'receiptScans'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const [expensesSnap, incomesSnap, scansSnap, categoriesSnap, budgetsSnap] = await Promise.all([\r\n        getDocs(expensesQuery),\r\n        getDocs(incomesQuery),\r\n        getDocs(scansQuery),\r\n        getDoc(doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories')),\r\n        getDoc(doc(db, 'users', currentUser.uid, 'settings', 'budgets'))\r\n      ]);\r\n      \r\n      const exportData = {\r\n        expenses: expensesSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        incomes: incomesSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        receiptScans: scansSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        expenseCategories: categoriesSnap.exists() ? categoriesSnap.data().categories : DEFAULT_EXPENSE_CATEGORIES,\r\n        incomeCategories: incomeCategories,\r\n        budgets: budgetsSnap.exists() ? budgetsSnap.data() : {},\r\n        exportDate: new Date().toISOString(),\r\n        userId: currentUser.uid\r\n      };\r\n      \r\n      return exportData;\r\n    } catch (error) {\r\n      console.error('Error exporting data:', error);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  // Import data from backups\r\n  const importData = async (data) => {\r\n    if (!currentUser || !data) return false;\r\n    \r\n    try {\r\n      // Validate data structure\r\n      if (!data.expenses || !data.incomes || !data.budgets || \r\n          !data.expenseCategories || !data.incomeCategories) {\r\n        console.error('Invalid import data structure');\r\n        return false;\r\n      }\r\n      \r\n      // Begin batch operations\r\n      const batch = db.batch();\r\n      \r\n      // Update expense categories\r\n      const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      batch.set(expenseCategoriesRef, { categories: data.expenseCategories });\r\n      \r\n      // Update income categories\r\n      const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      batch.set(incomeCategoriesRef, { categories: data.incomeCategories });\r\n      \r\n      // Update budgets\r\n      const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      batch.set(budgetsRef, data.budgets);\r\n      \r\n      // Commit the batch\r\n      await batch.commit();\r\n      \r\n      // Update local state\r\n      setExpenseCategories(data.expenseCategories);\r\n      setIncomeCategories(data.incomeCategories);\r\n      setBudgets(data.budgets);\r\n      \r\n      // Handle expense and income imports separately (may be too many for a single batch)\r\n      for (const expense of data.expenses) {\r\n        try {\r\n          const { id, ...expenseData } = expense;\r\n          expenseData.userId = currentUser.uid; // Ensure correct user ID\r\n          await addDoc(collection(db, 'expenses'), expenseData);\r\n        } catch (e) {\r\n          console.error('Error importing expense:', e);\r\n          // Continue with other imports\r\n        }\r\n      }\r\n      \r\n      for (const income of data.incomes) {\r\n        try {\r\n          const { id, ...incomeData } = income;\r\n          incomeData.userId = currentUser.uid; // Ensure correct user ID\r\n          await addDoc(collection(db, 'incomes'), incomeData);\r\n        } catch (e) {\r\n          console.error('Error importing income:', e);\r\n          // Continue with other imports\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error importing data:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Get spending insights\r\n  const getSpendingInsights = async (months = 3) => {\r\n    if (!currentUser || months < 1) return null;\r\n    \r\n    try {\r\n      const currentDate = new Date();\r\n      const insights = {\r\n        topCategories: [],\r\n        monthlyTotals: [],\r\n        yearlyComparison: {},\r\n        receiptUsage: {\r\n          total: 0,\r\n          percentage: 0\r\n        }\r\n      };\r\n      \r\n      // Get relevant expenses from Firestore\r\n      const startDate = new Date();\r\n      startDate.setMonth(startDate.getMonth() - months);\r\n      \r\n      // Format for Firestore query\r\n      const startDateString = startDate.toISOString();\r\n      \r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('date', '>=', startDateString)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      const relevantExpenses = expensesSnap.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      \r\n      // Calculate top spending categories\r\n      const categoryTotals = {};\r\n      relevantExpenses.forEach(expense => {\r\n        const { category, amount } = expense;\r\n        if (!category) return;\r\n        \r\n        categoryTotals[category] = (categoryTotals[category] || 0) + parseFloat(amount || 0);\r\n      });\r\n      \r\n      insights.topCategories = Object.entries(categoryTotals)\r\n        .map(([category, total]) => ({ category, total }))\r\n        .sort((a, b) => b.total - a.total)\r\n        .slice(0, 5); // Get top 5\r\n      \r\n      // Calculate monthly totals\r\n      const monthlyData = {};\r\n      relevantExpenses.forEach(expense => {\r\n        if (!expense.date) return;\r\n        \r\n        const expenseDate = new Date(expense.date);\r\n        const monthYear = `${expenseDate.getFullYear()}-${expenseDate.getMonth()+1}`;\r\n        \r\n        if (!monthlyData[monthYear]) {\r\n          monthlyData[monthYear] = {\r\n            month: expenseDate.getMonth(),\r\n            year: expenseDate.getFullYear(),\r\n            total: 0,\r\n            label: expenseDate.toLocaleString('default', { month: 'short', year: 'numeric' })\r\n          };\r\n        }\r\n        \r\n        monthlyData[monthYear].total += parseFloat(expense.amount || 0);\r\n      });\r\n      \r\n      insights.monthlyTotals = Object.values(monthlyData)\r\n        .sort((a, b) => {\r\n          if (a.year !== b.year) return a.year - b.year;\r\n          return a.month - b.month;\r\n        });\r\n      \r\n      // Calculate receipt usage statistics\r\n      const receiptsCount = relevantExpenses.filter(expense => expense.fromReceipt).length;\r\n      insights.receiptUsage = {\r\n        total: receiptsCount,\r\n        percentage: relevantExpenses.length > 0 \r\n          ? (receiptsCount / relevantExpenses.length) * 100 \r\n          : 0\r\n      };\r\n      \r\n      return insights;\r\n    } catch (error) {\r\n      console.error('Error generating spending insights:', error);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  // Load categories and other settings from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setExpenseCategories([]);\r\n      setIncomeCategories([]);\r\n      setBudgets({});\r\n      return;\r\n    }\r\n    \r\n    // Load categories and budgets\r\n    const fetchSettings = async () => {\r\n      try {\r\n        // Get expense categories\r\n        const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n        const expenseCategoriesDoc = await getDoc(expenseCategoriesRef);\r\n        \r\n        if (expenseCategoriesDoc.exists()) {\r\n          setExpenseCategories(expenseCategoriesDoc.data().categories || DEFAULT_EXPENSE_CATEGORIES);\r\n        } else {\r\n          // Create default categories if none exist\r\n          await setDoc(expenseCategoriesRef, {\r\n            categories: DEFAULT_EXPENSE_CATEGORIES\r\n          });\r\n          setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\r\n        }\r\n        \r\n        // Get income categories\r\n        const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n        const incomeCategoriesDoc = await getDoc(incomeCategoriesRef);\r\n        \r\n        if (incomeCategoriesDoc.exists()) {\r\n          setIncomeCategories(incomeCategoriesDoc.data().categories || DEFAULT_INCOME_CATEGORIES);\r\n        } else {\r\n          // Create default categories if none exist\r\n          await setDoc(incomeCategoriesRef, {\r\n            categories: DEFAULT_INCOME_CATEGORIES\r\n          });\r\n          setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\r\n        }\r\n        \r\n        // Get budgets\r\n        const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n        const budgetsDoc = await getDoc(budgetsRef);\r\n        \r\n        if (budgetsDoc.exists()) {\r\n          setBudgets(budgetsDoc.data());\r\n        }\r\n      } catch (error) {\r\n        console.error('Error loading settings:', error);\r\n        setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\r\n        setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\r\n      }\r\n    };\r\n    \r\n    fetchSettings();\r\n  }, [currentUser]);\r\n  \r\n  // Load alerts from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setAlerts([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for alerts\r\n    const alertsQuery = query(\r\n      collection(db, 'alerts'),\r\n      where('userId', '==', currentUser.uid),\r\n      where('read', '==', false)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(alertsQuery, (snapshot) => {\r\n      const alertsList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setAlerts(alertsList);\r\n    }, (error) => {\r\n      console.error(\"Error getting alerts:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Load receipt scans from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setReceiptScans([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for receipt scans\r\n    const scansQuery = query(\r\n      collection(db, 'receiptScans'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(scansQuery, (snapshot) => {\r\n      const scansList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setReceiptScans(scansList);\r\n    }, (error) => {\r\n      console.error(\"Error getting receipt scans:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  return (\r\n    <ExpenseContext.Provider value={{\r\n      expenses,\r\n      incomes,\r\n      budgets,\r\n      alerts,\r\n      expenseCategories,\r\n      incomeCategories,\r\n      receiptScanStatus,\r\n      receiptScans,\r\n      emailStatus,\r\n      loading,\r\n      addExpense,\r\n      addIncome,\r\n      deleteExpense,\r\n      deleteIncome,\r\n      updateExpense,\r\n      updateIncome,\r\n      updateBudget,\r\n      deleteBudget,\r\n      markAlertAsRead,\r\n      deleteAlert,\r\n      addExpenseCategory,\r\n      deleteExpenseCategory,\r\n      editExpenseCategory,\r\n      addIncomeCategory,\r\n      deleteIncomeCategory,\r\n      editIncomeCategory,\r\n      scanReceipt,\r\n      addExpenseFromReceipt,\r\n      rejectScannedReceipt,\r\n      getMonthlyExpenses,\r\n      getMonthlyIncomes,\r\n      getReceiptScans,\r\n      exportData,\r\n      importData,\r\n      getSpendingInsights\r\n    }}>\r\n      {children}\r\n    </ExpenseContext.Provider>\r\n  );\r\n};"],"mappings":";;AAAA;AACA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,UAAU,QAAQ,OAAO;AAC7E,SAASC,WAAW,QAAQ,eAAe;AAC3C,SAASC,oBAAoB,QAAQ,0BAA0B;AAC/D,SAASC,gBAAgB,EAAEC,gBAAgB,QAAQ,oCAAoC;AACvF;AACA,SAASC,EAAE,EAAEC,OAAO,QAAQ,oBAAoB;AAChD,SACEC,UAAU,EACVC,MAAM,EACNC,GAAG,EACHC,SAAS,EACTC,SAAS,EACTC,KAAK,EACLC,KAAK,EACLC,OAAO,EACPC,UAAU,EACVC,MAAM,EACNC,MAAM,EACNC,KAAK,QACA,oBAAoB;AAC3B,SAASC,GAAG,EAAEC,WAAW,EAAEC,cAAc,QAAQ,kBAAkB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEpE,OAAO,MAAMC,cAAc,gBAAG3B,aAAa,CAAC,CAAC;AAE7C,OAAO,MAAM4B,eAAe,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EAC/C,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAG/B,QAAQ,CAAC,EAAE,CAAC;EAC5C,MAAM,CAACgC,OAAO,EAAEC,UAAU,CAAC,GAAGjC,QAAQ,CAAC,EAAE,CAAC;EAC1C,MAAM,CAACkC,OAAO,EAAEC,UAAU,CAAC,GAAGnC,QAAQ,CAAC,CAAC,CAAC,CAAC;EAC1C,MAAM,CAACoC,MAAM,EAAEC,SAAS,CAAC,GAAGrC,QAAQ,CAAC,EAAE,CAAC;EACxC,MAAM,CAACsC,OAAO,EAAEC,UAAU,CAAC,GAAGvC,QAAQ,CAAC,IAAI,CAAC;EAC5C,MAAM,CAACwC,WAAW,EAAEC,cAAc,CAAC,GAAGzC,QAAQ,CAAC;IAAE0C,IAAI,EAAE,KAAK;IAAEC,KAAK,EAAE;EAAK,CAAC,CAAC;EAC5E,MAAM,CAACC,iBAAiB,EAAEC,oBAAoB,CAAC,GAAG7C,QAAQ,CAAC,EAAE,CAAC;EAC9D,MAAM,CAAC8C,gBAAgB,EAAEC,mBAAmB,CAAC,GAAG/C,QAAQ,CAAC,EAAE,CAAC;EAC5D;EACA,MAAM,CAACgD,iBAAiB,EAAEC,oBAAoB,CAAC,GAAGjD,QAAQ,CAAC;IACzDkD,QAAQ,EAAE,KAAK;IACfP,KAAK,EAAE,IAAI;IACXQ,IAAI,EAAE;EACR,CAAC,CAAC;EACF;EACA,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGrD,QAAQ,CAAC,EAAE,CAAC;EAEpD,MAAM;IAAEsD;EAAY,CAAC,GAAGpD,UAAU,CAACC,WAAW,CAAC;;EAE/C;EACA,MAAMoD,0BAA0B,GAAG,CACjC,MAAM,EAAE,SAAS,EAAE,gBAAgB,EAAE,eAAe,EACpD,WAAW,EAAE,YAAY,EAAE,UAAU,EAAE,eAAe,EAAE,WAAW,EAAE,OAAO,CAC7E;EAED,MAAMC,yBAAyB,GAAG,CAChC,QAAQ,EAAE,WAAW,EAAE,YAAY,EAAE,MAAM,EAC3C,UAAU,EAAE,aAAa,EAAE,QAAQ,EAAE,OAAO,CAC7C;;EAED;EACAvD,SAAS,CAAC,MAAM;IACd,IAAI,CAACqD,WAAW,EAAE;MAChBvB,WAAW,CAAC,EAAE,CAAC;MACfQ,UAAU,CAAC,KAAK,CAAC;MACjB;IACF;IAEAA,UAAU,CAAC,IAAI,CAAC;;IAEhB;IACA,MAAMkB,aAAa,GAAG3C,KAAK,CACzBL,UAAU,CAACF,EAAE,EAAE,UAAU,CAAC,EAC1BQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CACvC,CAAC;;IAED;IACA,MAAMC,WAAW,GAAG1C,UAAU,CAACwC,aAAa,EAAGG,QAAQ,IAAK;MAC1D,MAAMC,YAAY,GAAGD,QAAQ,CAACE,IAAI,CAACC,GAAG,CAACpD,GAAG,KAAK;QAC7CqD,EAAE,EAAErD,GAAG,CAACqD,EAAE;QACV,GAAGrD,GAAG,CAACwC,IAAI,CAAC;MACd,CAAC,CAAC,CAAC;MACHpB,WAAW,CAAC8B,YAAY,CAAC;MACzBtB,UAAU,CAAC,KAAK,CAAC;IACnB,CAAC,EAAGI,KAAK,IAAK;MACZsB,OAAO,CAACtB,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/CJ,UAAU,CAAC,KAAK,CAAC;IACnB,CAAC,CAAC;IAEF,OAAO,MAAMoB,WAAW,CAAC,CAAC;EAC5B,CAAC,EAAE,CAACL,WAAW,CAAC,CAAC;;EAEjB;EACArD,SAAS,CAAC,MAAM;IACd,IAAI,CAACqD,WAAW,EAAE;MAChBrB,UAAU,CAAC,EAAE,CAAC;MACd;IACF;;IAEA;IACA,MAAMiC,YAAY,GAAGpD,KAAK,CACxBL,UAAU,CAACF,EAAE,EAAE,SAAS,CAAC,EACzBQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CACvC,CAAC;;IAED;IACA,MAAMC,WAAW,GAAG1C,UAAU,CAACiD,YAAY,EAAGN,QAAQ,IAAK;MACzD,MAAMO,WAAW,GAAGP,QAAQ,CAACE,IAAI,CAACC,GAAG,CAACpD,GAAG,KAAK;QAC5CqD,EAAE,EAAErD,GAAG,CAACqD,EAAE;QACV,GAAGrD,GAAG,CAACwC,IAAI,CAAC;MACd,CAAC,CAAC,CAAC;MACHlB,UAAU,CAACkC,WAAW,CAAC;IACzB,CAAC,EAAGxB,KAAK,IAAK;MACZsB,OAAO,CAACtB,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;IAChD,CAAC,CAAC;IAEF,OAAO,MAAMgB,WAAW,CAAC,CAAC;EAC5B,CAAC,EAAE,CAACL,WAAW,CAAC,CAAC;;EAEjB;EACArD,SAAS,CAAC,MAAM;IACd,IAAIuC,WAAW,CAACE,IAAI,IAAIF,WAAW,CAACG,KAAK,EAAE;MACzC,MAAMyB,KAAK,GAAGC,UAAU,CAAC,MAAM;QAC7B5B,cAAc,CAAC;UAAEC,IAAI,EAAE,KAAK;UAAEC,KAAK,EAAE;QAAK,CAAC,CAAC;MAC9C,CAAC,EAAE,IAAI,CAAC;MAER,OAAO,MAAM2B,YAAY,CAACF,KAAK,CAAC;IAClC;EACF,CAAC,EAAE,CAAC5B,WAAW,CAAC,CAAC;;EAEjB;EACAvC,SAAS,CAAC,MAAM;IACd,IAAI+C,iBAAiB,CAACG,IAAI,IAAI,CAACH,iBAAiB,CAACE,QAAQ,EAAE;MACzD,MAAMkB,KAAK,GAAGC,UAAU,CAAC,MAAM;QAC7BpB,oBAAoB,CAACsB,SAAS,KAAK;UACjC,GAAGA,SAAS;UACZpB,IAAI,EAAE;QACR,CAAC,CAAC,CAAC;MACL,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;;MAEX,OAAO,MAAMmB,YAAY,CAACF,KAAK,CAAC;IAClC;EACF,CAAC,EAAE,CAACpB,iBAAiB,CAAC,CAAC;;EAEvB;EACA;EACA;EACA,MAAMwB,UAAU,GAAG,MAAOC,OAAO,IAAK;IACpC,IAAI,CAACnB,WAAW,EAAE;MAChBW,OAAO,CAACtB,KAAK,CAAC,2CAA2C,CAAC;MAC1D,OAAO,KAAK;IACd;IAEA,IAAI;MACF;MACA,MAAM+B,UAAU,GAAG;QACjBC,QAAQ,EAAEF,OAAO,CAACE,QAAQ,IAAI,OAAO;QACrCC,MAAM,EAAEC,UAAU,CAACJ,OAAO,CAACG,MAAM,CAAC,IAAI,CAAC;QACvCE,IAAI,EAAEL,OAAO,CAACK,IAAI,IAAI,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;QAC3DC,WAAW,EAAET,OAAO,CAACS,WAAW,IAAI,EAAE;QACtCC,MAAM,EAAE7B,WAAW,CAACI,GAAG;QAAE;QACzB0B,SAAS,EAAE,IAAIL,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QACnC;QACAK,OAAO,EAAEZ,OAAO,CAACY,OAAO,IAAI,KAAK;QACjCC,SAAS,EAAEb,OAAO,CAACa,SAAS,IAAIT,UAAU,CAACJ,OAAO,CAACG,MAAM,CAAC,IAAI;MAChE,CAAC;;MAED;MACAX,OAAO,CAACsB,GAAG,CAAC,8BAA8B,EAAEb,UAAU,CAAC;;MAEvD;MACA,IAAI;QACF,MAAMc,MAAM,GAAG,MAAM9E,MAAM,CAACD,UAAU,CAACF,EAAE,EAAE,UAAU,CAAC,EAAEmE,UAAU,CAAC;QACnET,OAAO,CAACsB,GAAG,CAAC,wBAAwB,EAAEC,MAAM,CAACxB,EAAE,CAAC;QAChD,OAAOwB,MAAM,CAACxB,EAAE;MAClB,CAAC,CAAC,OAAOyB,cAAc,EAAE;QACvBxB,OAAO,CAACtB,KAAK,CAAC,iCAAiC,EAAE8C,cAAc,CAAC;QAChE,OAAO,KAAK;MACd;IACF,CAAC,CAAC,OAAO9C,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC7C,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAM+C,WAAW,GAAG,MAAOC,SAAS,IAAK;IACvC,IAAI,CAACrC,WAAW,EAAE;MAChBL,oBAAoB,CAAC;QACnBC,QAAQ,EAAE,KAAK;QACfP,KAAK,EAAE,oBAAoB;QAC3BQ,IAAI,EAAE;MACR,CAAC,CAAC;MACF,OAAO;QAAEyC,OAAO,EAAE,KAAK;QAAEjD,KAAK,EAAE;MAAqB,CAAC;IACxD;IAEA,IAAI,CAACgD,SAAS,EAAE;MACd1C,oBAAoB,CAAC;QACnBC,QAAQ,EAAE,KAAK;QACfP,KAAK,EAAE,mBAAmB;QAC1BQ,IAAI,EAAE;MACR,CAAC,CAAC;MACF,OAAO;QAAEyC,OAAO,EAAE,KAAK;QAAEjD,KAAK,EAAE;MAAoB,CAAC;IACvD;IAEA,IAAI;MACF;MACAM,oBAAoB,CAAC;QACnBC,QAAQ,EAAE,IAAI;QACdP,KAAK,EAAE,IAAI;QACXQ,IAAI,EAAE;MACR,CAAC,CAAC;MAEFc,OAAO,CAACsB,GAAG,CAAC,2BAA2B,EAAEI,SAAS,CAACE,IAAI,CAAC;;MAExD;MACA,MAAMC,QAAQ,GAAGC,GAAG,CAACC,eAAe,CAACL,SAAS,CAAC;;MAE/C;MACA,MAAMM,aAAa,GAAG;QACpB;QACAC,YAAY,EAAE,EAAE;QAChBtB,MAAM,EAAE,EAAE;QACVE,IAAI,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;QAAE;QAC7CkB,aAAa,EAAE,OAAOC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,KAAK,CAAC,EAAE;QACzDC,KAAK,EAAE,EAAE;QACTC,UAAU,EAAE,GAAG;QACfC,SAAS,EAAE,CAAC;QACZC,YAAY,EAAE,KAAK;QACnBZ,QAAQ,EAAEA,QAAQ;QAClBF,OAAO,EAAE;MACX,CAAC;MAED3B,OAAO,CAACsB,GAAG,CAAC,yCAAyC,CAAC;;MAEtD;MACAtC,oBAAoB,CAAC;QACnBC,QAAQ,EAAE,KAAK;QACfP,KAAK,EAAE,IAAI;QACXQ,IAAI,EAAE;UACJyB,MAAM,EAAE,EAAE;UACVM,WAAW,EAAE,EAAE;UACfP,QAAQ,EAAE,MAAM;UAAE;UAClBG,IAAI,EAAEmB,aAAa,CAACnB,IAAI;UACxB6B,WAAW,EAAE,IAAI;UACjBC,eAAe,EAAEd,QAAQ;UACzBe,KAAK,EAAE;QACT;MACF,CAAC,CAAC;MAEF,OAAO;QACLjB,OAAO,EAAE,IAAI;QACbzC,IAAI,EAAE8C,aAAa;QACnBH,QAAQ,EAAEA;MACZ,CAAC;IACH,CAAC,CAAC,OAAOnD,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAE/CM,oBAAoB,CAAC;QACnBC,QAAQ,EAAE,KAAK;QACfP,KAAK,EAAEA,KAAK,CAACmE,OAAO,IAAI,wBAAwB;QAChD3D,IAAI,EAAE;MACR,CAAC,CAAC;MAEF,OAAO;QACLyC,OAAO,EAAE,KAAK;QACdjD,KAAK,EAAEA,KAAK,CAACmE,OAAO,IAAI;MAC1B,CAAC;IACH;EACF,CAAC;;EAED;EACA,MAAMC,qBAAqB,GAAG,MAAAA,CAAOC,WAAW,EAAEC,aAAa,GAAG,CAAC,CAAC,KAAK;IACvE,IAAI,CAAC3D,WAAW,EAAE,OAAO,KAAK;IAE9B,IAAI;MACF;MACA,MAAM4D,gBAAgB,GAAG;QACvB,GAAGF,WAAW;QACd,GAAGC,aAAa;QAChBN,WAAW,EAAE;MACf,CAAC;;MAED;MACA,MAAMQ,MAAM,GAAG,MAAM3C,UAAU,CAAC0C,gBAAgB,CAAC;MAEjD,IAAIC,MAAM,IAAID,gBAAgB,CAACE,aAAa,EAAE;QAC5C;QACA,MAAMC,OAAO,GAAG1G,GAAG,CAACJ,EAAE,EAAE,cAAc,EAAE+G,MAAM,CAACJ,gBAAgB,CAACE,aAAa,CAAC,CAAC;QAC/E,MAAMvG,SAAS,CAACwG,OAAO,EAAE;UAAEE,MAAM,EAAE;QAAU,CAAC,CAAC;;QAE/C;QACAtE,oBAAoB,CAACsB,SAAS,KAAK;UACjC,GAAGA,SAAS;UACZpB,IAAI,EAAE;QACR,CAAC,CAAC,CAAC;MACL;MAEA,OAAOgE,MAAM;IACf,CAAC,CAAC,OAAOxE,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;MAC1D,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAM6E,oBAAoB,GAAG,MAAOC,MAAM,IAAK;IAC7C,IAAI,CAACA,MAAM,EAAE,OAAO,KAAK;IAEzB,IAAI;MAAA,IAAAC,qBAAA;MACF;MACA,MAAML,OAAO,GAAG1G,GAAG,CAACJ,EAAE,EAAE,cAAc,EAAE+G,MAAM,CAACG,MAAM,CAAC,CAAC;MACvD,MAAM5G,SAAS,CAACwG,OAAO,EAAE;QAAEE,MAAM,EAAE;MAAW,CAAC,CAAC;;MAEhD;MACA,IAAI,EAAAG,qBAAA,GAAA1E,iBAAiB,CAACG,IAAI,cAAAuE,qBAAA,uBAAtBA,qBAAA,CAAwBN,aAAa,MAAKK,MAAM,EAAE;QACpDxE,oBAAoB,CAAC;UACnBC,QAAQ,EAAE,KAAK;UACfP,KAAK,EAAE,IAAI;UACXQ,IAAI,EAAE;QACR,CAAC,CAAC;MACJ;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAOR,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;MACxD,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMgF,mBAAmB,GAAIC,UAAU,IAAK;IAC1C,MAAMC,eAAe,GAAGD,UAAU,CAACE,WAAW,CAAC,CAAC;;IAEhD;IACA,IAAI,CAACF,UAAU,EAAE,OAAO,OAAO;IAE/B,MAAMG,gBAAgB,GAAG;MACvB,YAAY,EAAE,MAAM;MACpB,MAAM,EAAE,MAAM;MACd,MAAM,EAAE,MAAM;MACd,SAAS,EAAE,MAAM;MACjB,aAAa,EAAE,MAAM;MACrB,QAAQ,EAAE,MAAM;MAChB,KAAK,EAAE,gBAAgB;MACvB,MAAM,EAAE,gBAAgB;MACxB,MAAM,EAAE,gBAAgB;MACxB,MAAM,EAAE,gBAAgB;MACxB,MAAM,EAAE,gBAAgB;MACxB,UAAU,EAAE,YAAY;MACxB,MAAM,EAAE,YAAY;MACpB,QAAQ,EAAE,YAAY;MACtB,QAAQ,EAAE,YAAY;MACtB,UAAU,EAAE,YAAY;MACxB,MAAM,EAAE,SAAS;MACjB,UAAU,EAAE,SAAS;MACrB,SAAS,EAAE,eAAe;MAC1B,SAAS,EAAE,eAAe;MAC1B,QAAQ,EAAE,eAAe;MACzB,OAAO,EAAE,eAAe;MACxB,SAAS,EAAE,eAAe;MAC1B,QAAQ,EAAE,UAAU;MACpB,SAAS,EAAE,UAAU;MACrB,QAAQ,EAAE,UAAU;MACpB,SAAS,EAAE,WAAW;MACtB,UAAU,EAAE,WAAW;MACvB,OAAO,EAAE,WAAW;MACpB,UAAU,EAAE,WAAW;MACvB,OAAO,EAAE,WAAW;MACpB,UAAU,EAAE,WAAW;MACvB,QAAQ,EAAE,WAAW;MACrB,SAAS,EAAE,WAAW;MACtB,YAAY,EAAE,WAAW;MACzB,SAAS,EAAE,WAAW;MACtB,MAAM,EAAE,WAAW;MACnB,SAAS,EAAE,eAAe;MAC1B,OAAO,EAAE,eAAe;MACxB,KAAK,EAAE,eAAe;MACtB,KAAK,EAAE;IACT,CAAC;IAED,KAAK,MAAM,CAACC,OAAO,EAAErD,QAAQ,CAAC,IAAIsD,MAAM,CAACC,OAAO,CAACH,gBAAgB,CAAC,EAAE;MAClE,IAAIF,eAAe,CAACM,QAAQ,CAACH,OAAO,CAAC,EAAE;QACrC,OAAOrD,QAAQ;MACjB;IACF;IAEA,OAAO,OAAO;EAChB,CAAC;;EAED;EACA,MAAMyD,SAAS,GAAG,MAAOC,MAAM,IAAK;IAClC,IAAI,CAAC/E,WAAW,EAAE;MAChBW,OAAO,CAACtB,KAAK,CAAC,0CAA0C,CAAC;MACzD,OAAO,KAAK;IACd;IAEA,IAAI;MACF;MACAsB,OAAO,CAACsB,GAAG,CAAC,0BAA0B,EAAE8C,MAAM,CAAC;;MAE/C;MACA,IAAI,CAACA,MAAM,CAACC,MAAM,EAAE;QAClBrE,OAAO,CAACtB,KAAK,CAAC,0BAA0B,CAAC;QACzC,OAAO,KAAK;MACd;MAEA,MAAMiC,MAAM,GAAGC,UAAU,CAACwD,MAAM,CAACzD,MAAM,CAAC;MACxC,IAAI2D,KAAK,CAAC3D,MAAM,CAAC,IAAIA,MAAM,IAAI,CAAC,EAAE;QAChCX,OAAO,CAACtB,KAAK,CAAC,wBAAwB,EAAE0F,MAAM,CAACzD,MAAM,CAAC;QACtD,OAAO,KAAK;MACd;;MAEA;MACA,MAAM4D,SAAS,GAAG;QAChBF,MAAM,EAAED,MAAM,CAACC,MAAM;QACrB1D,MAAM,EAAEA,MAAM;QACdE,IAAI,EAAEuD,MAAM,CAACvD,IAAI,IAAI,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;QAC1DC,WAAW,EAAEmD,MAAM,CAACnD,WAAW,IAAI,EAAE;QACrCC,MAAM,EAAE7B,WAAW,CAACI,GAAG;QACvB0B,SAAS,EAAE,IAAIL,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;MAEDf,OAAO,CAACsB,GAAG,CAAC,uCAAuC,EAAEiD,SAAS,CAAC;;MAE/D;MACA,IAAI;QACF,MAAMhD,MAAM,GAAG,MAAM9E,MAAM,CAACD,UAAU,CAACF,EAAE,EAAE,SAAS,CAAC,EAAEiI,SAAS,CAAC;QACjEvE,OAAO,CAACsB,GAAG,CAAC,oCAAoC,EAAEC,MAAM,CAACxB,EAAE,CAAC;QAC5D,OAAOwB,MAAM,CAACxB,EAAE;MAClB,CAAC,CAAC,OAAOyB,cAAc,EAAE;QACvBxB,OAAO,CAACtB,KAAK,CAAC,gCAAgC,EAAE8C,cAAc,CAAC;QAC/D,MAAMA,cAAc,CAAC,CAAC;MACxB;IACF,CAAC,CAAC,OAAO9C,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;MAC5C,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAM8F,aAAa,GAAG,MAAOzE,EAAE,IAAK;IAClC,IAAI,CAACV,WAAW,IAAI,CAACU,EAAE,EAAE,OAAO,KAAK;IAErC,IAAI;MACF;MACA,MAAM0E,UAAU,GAAG/H,GAAG,CAACJ,EAAE,EAAE,UAAU,EAAEyD,EAAE,CAAC;MAC1C,MAAM2E,WAAW,GAAG,MAAMzH,MAAM,CAACwH,UAAU,CAAC;MAE5C,IAAIC,WAAW,CAACC,MAAM,CAAC,CAAC,EAAE;QACxB,MAAM5B,WAAW,GAAG2B,WAAW,CAACxF,IAAI,CAAC,CAAC;;QAEtC;QACA,MAAMvC,SAAS,CAAC8H,UAAU,CAAC;;QAE3B;QACA,IAAI1B,WAAW,CAACI,aAAa,EAAE;UAC7B,MAAMC,OAAO,GAAG1G,GAAG,CAACJ,EAAE,EAAE,cAAc,EAAE+G,MAAM,CAACN,WAAW,CAACI,aAAa,CAAC,CAAC;UAC1E,MAAMyB,QAAQ,GAAG,MAAM3H,MAAM,CAACmG,OAAO,CAAC;UAEtC,IAAIwB,QAAQ,CAACD,MAAM,CAAC,CAAC,EAAE;YACrB,MAAM/H,SAAS,CAACwG,OAAO,EAAE;cAAEE,MAAM,EAAE;YAAW,CAAC,CAAC;UAClD;QACF;MACF,CAAC,MAAM;QACL;QACAtD,OAAO,CAACtB,KAAK,CAAC,mBAAmB,CAAC;QAClC,OAAO,KAAK;MACd;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAOA,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/C,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMmG,YAAY,GAAG,MAAO9E,EAAE,IAAK;IACjC,IAAI,CAACV,WAAW,IAAI,CAACU,EAAE,EAAE,OAAO,KAAK;IAErC,IAAI;MACF,MAAMpD,SAAS,CAACD,GAAG,CAACJ,EAAE,EAAE,SAAS,EAAEyD,EAAE,CAAC,CAAC;MACvC,OAAO,IAAI;IACb,CAAC,CAAC,OAAOrB,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMoG,YAAY,GAAG,MAAAA,CAAOpE,QAAQ,EAAEC,MAAM,KAAK;IAC/C,IAAI,CAACtB,WAAW,IAAI,CAACqB,QAAQ,IAAIA,QAAQ,CAACqE,IAAI,CAAC,CAAC,KAAK,EAAE,IAAIT,KAAK,CAAC1D,UAAU,CAACD,MAAM,CAAC,CAAC,EAAE;MACpF,OAAO,KAAK;IACd;IAEA,IAAI;MACF,MAAMqE,SAAS,GAAGtI,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,SAAS,CAAC;MAC1E,MAAMwF,SAAS,GAAG,MAAMhI,MAAM,CAAC+H,SAAS,CAAC;MAEzC,IAAIC,SAAS,CAACN,MAAM,CAAC,CAAC,EAAE;QACtB;QACA,MAAM/H,SAAS,CAACoI,SAAS,EAAE;UACzB,CAACtE,QAAQ,GAAGE,UAAU,CAACD,MAAM;QAC/B,CAAC,CAAC;MACJ,CAAC,MAAM;QACL;QACA,MAAMzD,MAAM,CAAC8H,SAAS,EAAE;UACtB,CAACtE,QAAQ,GAAGE,UAAU,CAACD,MAAM;QAC/B,CAAC,CAAC;MACJ;;MAEA;MACAzC,UAAU,CAACgH,WAAW,KAAK;QACzB,GAAGA,WAAW;QACd,CAACxE,QAAQ,GAAGE,UAAU,CAACD,MAAM;MAC/B,CAAC,CAAC,CAAC;MACH,OAAO,IAAI;IACb,CAAC,CAAC,OAAOjC,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMyG,YAAY,GAAG,MAAOzE,QAAQ,IAAK;IACvC,IAAI,CAACrB,WAAW,IAAI,CAACqB,QAAQ,EAAE,OAAO,KAAK;IAE3C,IAAI;MACF,MAAMsE,SAAS,GAAGtI,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,SAAS,CAAC;MAC1E,MAAMwF,SAAS,GAAG,MAAMhI,MAAM,CAAC+H,SAAS,CAAC;MAEzC,IAAIC,SAAS,CAACN,MAAM,CAAC,CAAC,EAAE;QACtB,MAAMS,cAAc,GAAGH,SAAS,CAAC/F,IAAI,CAAC,CAAC;;QAEvC;QACA,IAAIkG,cAAc,CAAC1E,QAAQ,CAAC,KAAK2E,SAAS,EAAE;UAC1C,OAAOD,cAAc,CAAC1E,QAAQ,CAAC;;UAE/B;UACA,MAAMxD,MAAM,CAAC8H,SAAS,EAAEI,cAAc,CAAC;;UAEvC;UACAlH,UAAU,CAACkH,cAAc,CAAC;QAC5B;MACF;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAO1G,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAM4G,iBAAiB,GAAG,MAAAA,CAAO7E,UAAU,EAAE8E,WAAW,GAAG1H,QAAQ,KAAK;IACtE,IAAI,CAACwB,WAAW,EAAE,OAAO,CAAC;IAC1B,IAAI,CAACoB,UAAU,IAAI,CAACA,UAAU,CAACC,QAAQ,EAAE;IAEzC,MAAM;MAAEA;IAAS,CAAC,GAAGD,UAAU;;IAE/B;IACA,IAAI;MACF,MAAMuE,SAAS,GAAGtI,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,SAAS,CAAC;MAC1E,MAAMwF,SAAS,GAAG,MAAMhI,MAAM,CAAC+H,SAAS,CAAC;MAEzC,IAAI,CAACC,SAAS,CAACN,MAAM,CAAC,CAAC,EAAE;MAEzB,MAAM1G,OAAO,GAAGgH,SAAS,CAAC/F,IAAI,CAAC,CAAC;;MAEhC;MACA,IAAIjB,OAAO,CAACyC,QAAQ,CAAC,EAAE;QACrB;QACA,MAAM8E,WAAW,GAAG,IAAI1E,IAAI,CAAC,CAAC;QAC9B,MAAM2E,YAAY,GAAGD,WAAW,CAACE,QAAQ,CAAC,CAAC;QAC3C,MAAMC,WAAW,GAAGH,WAAW,CAACI,WAAW,CAAC,CAAC;QAE7C,MAAMC,eAAe,GAAGN,WAAW,CAACO,MAAM,CAACtF,OAAO,IAAI;UACpD,IAAI,CAACA,OAAO,CAACK,IAAI,EAAE,OAAO,KAAK;UAE/B,IAAI;YACF,MAAMkF,WAAW,GAAG,IAAIjF,IAAI,CAACN,OAAO,CAACK,IAAI,CAAC;YAC1C,OAAOkF,WAAW,CAACL,QAAQ,CAAC,CAAC,KAAKD,YAAY,IACxCM,WAAW,CAACH,WAAW,CAAC,CAAC,KAAKD,WAAW,IACzCnF,OAAO,CAACE,QAAQ,KAAKA,QAAQ,IAC7BF,OAAO,CAACU,MAAM,KAAK7B,WAAW,CAACI,GAAG;UAC1C,CAAC,CAAC,OAAOuG,CAAC,EAAE;YACVhG,OAAO,CAACtB,KAAK,CAAC,sBAAsB,EAAE8B,OAAO,CAACK,IAAI,CAAC;YACnD,OAAO,KAAK;UACd;QACF,CAAC,CAAC;QAEF,MAAMoF,UAAU,GAAGJ,eAAe,CAACK,MAAM,CAAC,CAACC,GAAG,EAAE3F,OAAO,KAAK;UAC1D,MAAMG,MAAM,GAAGC,UAAU,CAACJ,OAAO,CAACG,MAAM,CAAC;UACzC,OAAOwF,GAAG,IAAI7B,KAAK,CAAC3D,MAAM,CAAC,GAAG,CAAC,GAAGA,MAAM,CAAC;QAC3C,CAAC,EAAE,CAAC,CAAC;QAEL,MAAMyF,YAAY,GAAGxF,UAAU,CAAC3C,OAAO,CAACyC,QAAQ,CAAC,CAAC;QAElD,IAAI,CAAC4D,KAAK,CAAC8B,YAAY,CAAC,IAAIH,UAAU,GAAGG,YAAY,EAAE;UAAA,IAAAC,qBAAA;UACrD;UACA,MAAMC,QAAQ,GAAG;YACfzD,OAAO,EAAE,sCAAsCnC,QAAQ,eAAe0F,YAAY,CAACG,OAAO,CAAC,CAAC,CAAC,EAAE;YAC/F7F,QAAQ,EAAEA,QAAQ;YAClB8F,IAAI,EAAE,KAAK;YACX3F,IAAI,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;YAC9BG,MAAM,EAAE7B,WAAW,CAACI;UACtB,CAAC;;UAED;UACA,MAAMgH,QAAQ,GAAG,MAAMhK,MAAM,CAACD,UAAU,CAACF,EAAE,EAAE,QAAQ,CAAC,EAAEgK,QAAQ,CAAC;;UAEjE;UACA,IAAI,CAAAjH,WAAW,aAAXA,WAAW,wBAAAgH,qBAAA,GAAXhH,WAAW,CAAEqH,WAAW,cAAAL,qBAAA,uBAAxBA,qBAAA,CAA0BM,kBAAkB,MAAK,KAAK,EAAE;YAC1D,IAAItH,WAAW,CAACuH,KAAK,EAAE;cACrBzK,oBAAoB,CAClBkD,WAAW,EACXqB,QAAQ,EACR0F,YAAY,EACZH,UACF,CAAC,CAACY,IAAI,CAAC3D,MAAM,IAAI;gBACf1E,cAAc,CAAC;kBACbC,IAAI,EAAEyE,MAAM,CAACvB,OAAO;kBACpBjD,KAAK,EAAEwE,MAAM,CAACvB,OAAO,GAAG,IAAI,GAAGuB,MAAM,CAACL;gBACxC,CAAC,CAAC;cACJ,CAAC,CAAC,CAACiE,KAAK,CAACpI,KAAK,IAAI;gBAChBF,cAAc,CAAC;kBACbC,IAAI,EAAE,KAAK;kBACXC,KAAK,EAAEA,KAAK,CAACmE,OAAO,IAAI;gBAC1B,CAAC,CAAC;cACJ,CAAC,CAAC;YACJ,CAAC,MAAM;cACLrE,cAAc,CAAC;gBACbC,IAAI,EAAE,KAAK;gBACXC,KAAK,EAAE;cACT,CAAC,CAAC;YACJ;UACF;QACF;MACF;IACF,CAAC,CAAC,OAAOA,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;IACvD;EACF,CAAC;;EAED;EACA,MAAMqI,eAAe,GAAG,MAAOhH,EAAE,IAAK;IACpC,IAAI,CAACV,WAAW,IAAI,CAACU,EAAE,EAAE,OAAO,KAAK;IAErC,IAAI;MACF,MAAM0G,QAAQ,GAAG/J,GAAG,CAACJ,EAAE,EAAE,QAAQ,EAAEyD,EAAE,CAAC;MACtC,MAAMnD,SAAS,CAAC6J,QAAQ,EAAE;QAAED,IAAI,EAAE;MAAK,CAAC,CAAC;MACzC,OAAO,IAAI;IACb,CAAC,CAAC,OAAO9H,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMsI,WAAW,GAAG,MAAOjH,EAAE,IAAK;IAChC,IAAI,CAACV,WAAW,IAAI,CAACU,EAAE,EAAE,OAAO,KAAK;IAErC,IAAI;MACF,MAAMpD,SAAS,CAACD,GAAG,CAACJ,EAAE,EAAE,QAAQ,EAAEyD,EAAE,CAAC,CAAC;MACtC,OAAO,IAAI;IACb,CAAC,CAAC,OAAOrB,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC7C,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMuI,kBAAkB,GAAG,MAAOvG,QAAQ,IAAK;IAC7C,IAAI,CAACrB,WAAW,IAAI,CAACqB,QAAQ,IAAIA,QAAQ,CAACqE,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,OAAO,KAAK;IAErE,IAAI;MACF,MAAMmC,aAAa,GAAGxK,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,mBAAmB,CAAC;MACxF,MAAM0H,aAAa,GAAG,MAAMlK,MAAM,CAACiK,aAAa,CAAC;MAEjD,IAAIE,iBAAiB;MAErB,IAAID,aAAa,CAACxC,MAAM,CAAC,CAAC,EAAE;QAC1B,MAAM0C,iBAAiB,GAAGF,aAAa,CAACjI,IAAI,CAAC,CAAC,CAACoI,UAAU,IAAI,EAAE;;QAE/D;QACA,IAAID,iBAAiB,CAACnD,QAAQ,CAACxD,QAAQ,CAAC,EAAE;UACxC,OAAO,KAAK;QACd;QAEA0G,iBAAiB,GAAG,CAAC,GAAGC,iBAAiB,EAAE3G,QAAQ,CAAC;MACtD,CAAC,MAAM;QACL0G,iBAAiB,GAAG,CAAC,GAAG9H,0BAA0B,EAAEoB,QAAQ,CAAC;MAC/D;;MAEA;MACA,MAAMxD,MAAM,CAACgK,aAAa,EAAE;QAAEI,UAAU,EAAEF;MAAkB,CAAC,CAAC;;MAE9D;MACAxI,oBAAoB,CAACwI,iBAAiB,CAAC;MACvC,OAAO,IAAI;IACb,CAAC,CAAC,OAAO1I,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;MACtD,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAM6I,qBAAqB,GAAG,MAAO7G,QAAQ,IAAK;IAChD,IAAI,CAACrB,WAAW,IAAI,CAACqB,QAAQ,EAAE,OAAO,KAAK;IAE3C,IAAI;MACF;MACA,MAAMlB,aAAa,GAAG3C,KAAK,CACzBL,UAAU,CAACF,EAAE,EAAE,UAAU,CAAC,EAC1BQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CAAC,EACtC3C,KAAK,CAAC,UAAU,EAAE,IAAI,EAAE4D,QAAQ,CAAC,EACjCvD,KAAK,CAAC,CAAC,CACT,CAAC;MAED,MAAMqK,YAAY,GAAG,MAAMzK,OAAO,CAACyC,aAAa,CAAC;MAEjD,IAAI,CAACgI,YAAY,CAACC,KAAK,EAAE;QACvB,OAAO;UAAE9F,OAAO,EAAE,KAAK;UAAE+F,MAAM,EAAE;QAAuC,CAAC;MAC3E;;MAEA;MACA,MAAMR,aAAa,GAAGxK,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,mBAAmB,CAAC;MACxF,MAAM0H,aAAa,GAAG,MAAMlK,MAAM,CAACiK,aAAa,CAAC;MAEjD,IAAIC,aAAa,CAACxC,MAAM,CAAC,CAAC,EAAE;QAC1B,MAAM0C,iBAAiB,GAAGF,aAAa,CAACjI,IAAI,CAAC,CAAC,CAACoI,UAAU,IAAI,EAAE;QAC/D,MAAMF,iBAAiB,GAAGC,iBAAiB,CAACvB,MAAM,CAAC6B,GAAG,IAAIA,GAAG,KAAKjH,QAAQ,CAAC;;QAE3E;QACA,MAAMxD,MAAM,CAACgK,aAAa,EAAE;UAAEI,UAAU,EAAEF;QAAkB,CAAC,CAAC;;QAE9D;QACAxI,oBAAoB,CAACwI,iBAAiB,CAAC;MACzC;;MAEA;MACA,MAAMpC,SAAS,GAAGtI,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,SAAS,CAAC;MAC1E,MAAMwF,SAAS,GAAG,MAAMhI,MAAM,CAAC+H,SAAS,CAAC;MAEzC,IAAIC,SAAS,CAACN,MAAM,CAAC,CAAC,EAAE;QACtB,MAAMS,cAAc,GAAGH,SAAS,CAAC/F,IAAI,CAAC,CAAC;QAEvC,IAAIkG,cAAc,CAAC1E,QAAQ,CAAC,KAAK2E,SAAS,EAAE;UAC1C,OAAOD,cAAc,CAAC1E,QAAQ,CAAC;;UAE/B;UACA,MAAMxD,MAAM,CAAC8H,SAAS,EAAEI,cAAc,CAAC;;UAEvC;UACAlH,UAAU,CAACkH,cAAc,CAAC;QAC5B;MACF;MAEA,OAAO;QAAEzD,OAAO,EAAE;MAAK,CAAC;IAC1B,CAAC,CAAC,OAAOjD,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;MACxD,OAAO;QAAEiD,OAAO,EAAE,KAAK;QAAE+F,MAAM,EAAEhJ,KAAK,CAACmE;MAAQ,CAAC;IAClD;EACF,CAAC;;EAED;EACA,MAAM+E,mBAAmB,GAAG,MAAAA,CAAOC,WAAW,EAAEC,WAAW,KAAK;IAC9D,IAAI,CAACzI,WAAW,IAAI,CAACwI,WAAW,IAAI,CAACC,WAAW,IAAIA,WAAW,CAAC/C,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,OAAO,KAAK;IAE3F,IAAI;MACF;MACA,IAAI8C,WAAW,KAAK,OAAO,EAAE,OAAO,KAAK;;MAEzC;MACA,MAAMX,aAAa,GAAGxK,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,mBAAmB,CAAC;MACxF,MAAM0H,aAAa,GAAG,MAAMlK,MAAM,CAACiK,aAAa,CAAC;MAEjD,IAAI,CAACC,aAAa,CAACxC,MAAM,CAAC,CAAC,EAAE,OAAO,KAAK;MAEzC,MAAM0C,iBAAiB,GAAGF,aAAa,CAACjI,IAAI,CAAC,CAAC,CAACoI,UAAU,IAAI,EAAE;;MAE/D;MACA,IAAID,iBAAiB,CAACnD,QAAQ,CAAC4D,WAAW,CAAC,IAAIA,WAAW,KAAKD,WAAW,EAAE,OAAO,KAAK;;MAExF;MACA,MAAMrI,aAAa,GAAG3C,KAAK,CACzBL,UAAU,CAACF,EAAE,EAAE,UAAU,CAAC,EAC1BQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CAAC,EACtC3C,KAAK,CAAC,UAAU,EAAE,IAAI,EAAE+K,WAAW,CAAC,EACpC1K,KAAK,CAAC,CAAC,CACT,CAAC;MAED,MAAMqK,YAAY,GAAG,MAAMzK,OAAO,CAACyC,aAAa,CAAC;MAEjD,IAAI,CAACgI,YAAY,CAACC,KAAK,EAAE,OAAO,KAAK;;MAErC;MACA,MAAML,iBAAiB,GAAGC,iBAAiB,CAACvH,GAAG,CAAC6H,GAAG,IACjDA,GAAG,KAAKE,WAAW,GAAGC,WAAW,GAAGH,GACtC,CAAC;;MAED;MACA,MAAMzK,MAAM,CAACgK,aAAa,EAAE;QAAEI,UAAU,EAAEF;MAAkB,CAAC,CAAC;;MAE9D;MACAxI,oBAAoB,CAACwI,iBAAiB,CAAC;;MAEvC;MACA,MAAMpC,SAAS,GAAGtI,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,SAAS,CAAC;MAC1E,MAAMwF,SAAS,GAAG,MAAMhI,MAAM,CAAC+H,SAAS,CAAC;MAEzC,IAAIC,SAAS,CAACN,MAAM,CAAC,CAAC,EAAE;QACtB,MAAMS,cAAc,GAAGH,SAAS,CAAC/F,IAAI,CAAC,CAAC;QAEvC,IAAIkG,cAAc,CAACyC,WAAW,CAAC,KAAKxC,SAAS,EAAE;UAC7C,MAAMe,YAAY,GAAGhB,cAAc,CAACyC,WAAW,CAAC;UAChD,OAAOzC,cAAc,CAACyC,WAAW,CAAC;UAClCzC,cAAc,CAAC0C,WAAW,CAAC,GAAG1B,YAAY;;UAE1C;UACA,MAAMlJ,MAAM,CAAC8H,SAAS,EAAEI,cAAc,CAAC;;UAEvC;UACAlH,UAAU,CAACkH,cAAc,CAAC;QAC5B;MACF;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAO1G,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;MACvD,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMqJ,iBAAiB,GAAG,MAAOrH,QAAQ,IAAK;IAC5C,IAAI,CAACrB,WAAW,IAAI,CAACqB,QAAQ,IAAIA,QAAQ,CAACqE,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,OAAO,KAAK;IAErE,IAAI;MACF,MAAMmC,aAAa,GAAGxK,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,kBAAkB,CAAC;MACvF,MAAM0H,aAAa,GAAG,MAAMlK,MAAM,CAACiK,aAAa,CAAC;MAEjD,IAAIE,iBAAiB;MAErB,IAAID,aAAa,CAACxC,MAAM,CAAC,CAAC,EAAE;QAC1B,MAAM0C,iBAAiB,GAAGF,aAAa,CAACjI,IAAI,CAAC,CAAC,CAACoI,UAAU,IAAI,EAAE;;QAE/D;QACA,IAAID,iBAAiB,CAACnD,QAAQ,CAACxD,QAAQ,CAAC,EAAE;UACxC,OAAO,KAAK;QACd;QAEA0G,iBAAiB,GAAG,CAAC,GAAGC,iBAAiB,EAAE3G,QAAQ,CAAC;MACtD,CAAC,MAAM;QACL0G,iBAAiB,GAAG,CAAC,GAAG7H,yBAAyB,EAAEmB,QAAQ,CAAC;MAC9D;;MAEA;MACA,MAAMxD,MAAM,CAACgK,aAAa,EAAE;QAAEI,UAAU,EAAEF;MAAkB,CAAC,CAAC;;MAE9D;MACAtI,mBAAmB,CAACsI,iBAAiB,CAAC;MACtC,OAAO,IAAI;IACb,CAAC,CAAC,OAAO1I,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;MACrD,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMsJ,oBAAoB,GAAG,MAAOtH,QAAQ,IAAK;IAC/C,IAAI,CAACrB,WAAW,IAAI,CAACqB,QAAQ,EAAE,OAAO,KAAK;IAE3C,IAAI;MACF;MACA,MAAMT,YAAY,GAAGpD,KAAK,CACxBL,UAAU,CAACF,EAAE,EAAE,SAAS,CAAC,EACzBQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CAAC,EACtC3C,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAE4D,QAAQ,CAAC,EAC/BvD,KAAK,CAAC,CAAC,CACT,CAAC;MAED,MAAM8K,WAAW,GAAG,MAAMlL,OAAO,CAACkD,YAAY,CAAC;MAE/C,IAAI,CAACgI,WAAW,CAACR,KAAK,EAAE;QACtB,OAAO;UAAE9F,OAAO,EAAE,KAAK;UAAE+F,MAAM,EAAE;QAAsC,CAAC;MAC1E;;MAEA;MACA,MAAMR,aAAa,GAAGxK,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,kBAAkB,CAAC;MACvF,MAAM0H,aAAa,GAAG,MAAMlK,MAAM,CAACiK,aAAa,CAAC;MAEjD,IAAIC,aAAa,CAACxC,MAAM,CAAC,CAAC,EAAE;QAC1B,MAAM0C,iBAAiB,GAAGF,aAAa,CAACjI,IAAI,CAAC,CAAC,CAACoI,UAAU,IAAI,EAAE;QAC/D,MAAMF,iBAAiB,GAAGC,iBAAiB,CAACvB,MAAM,CAAC6B,GAAG,IAAIA,GAAG,KAAKjH,QAAQ,CAAC;;QAE3E;QACA,MAAMxD,MAAM,CAACgK,aAAa,EAAE;UAAEI,UAAU,EAAEF;QAAkB,CAAC,CAAC;;QAE9D;QACAtI,mBAAmB,CAACsI,iBAAiB,CAAC;MACxC;MAEA,OAAO;QAAEzF,OAAO,EAAE;MAAK,CAAC;IAC1B,CAAC,CAAC,OAAOjD,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;MACvD,OAAO;QAAEiD,OAAO,EAAE,KAAK;QAAE+F,MAAM,EAAEhJ,KAAK,CAACmE;MAAQ,CAAC;IAClD;EACF,CAAC;;EAED;EACA,MAAMqF,kBAAkB,GAAG,MAAAA,CAAOL,WAAW,EAAEC,WAAW,KAAK;IAC7D,IAAI,CAACzI,WAAW,IAAI,CAACwI,WAAW,IAAI,CAACC,WAAW,IAAIA,WAAW,CAAC/C,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,OAAO,KAAK;IAE3F,IAAI;MACF;MACA,IAAI8C,WAAW,KAAK,OAAO,EAAE,OAAO,KAAK;;MAEzC;MACA,MAAMX,aAAa,GAAGxK,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,kBAAkB,CAAC;MACvF,MAAM0H,aAAa,GAAG,MAAMlK,MAAM,CAACiK,aAAa,CAAC;MAEjD,IAAI,CAACC,aAAa,CAACxC,MAAM,CAAC,CAAC,EAAE,OAAO,KAAK;MAEzC,MAAM0C,iBAAiB,GAAGF,aAAa,CAACjI,IAAI,CAAC,CAAC,CAACoI,UAAU,IAAI,EAAE;;MAE/D;MACA,IAAID,iBAAiB,CAACnD,QAAQ,CAAC4D,WAAW,CAAC,IAAIA,WAAW,KAAKD,WAAW,EAAE,OAAO,KAAK;;MAExF;MACA,MAAM5H,YAAY,GAAGpD,KAAK,CACxBL,UAAU,CAACF,EAAE,EAAE,SAAS,CAAC,EACzBQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CAAC,EACtC3C,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAE+K,WAAW,CAAC,EAClC1K,KAAK,CAAC,CAAC,CACT,CAAC;MAED,MAAM8K,WAAW,GAAG,MAAMlL,OAAO,CAACkD,YAAY,CAAC;MAE/C,IAAI,CAACgI,WAAW,CAACR,KAAK,EAAE,OAAO,KAAK;;MAEpC;MACA,MAAML,iBAAiB,GAAGC,iBAAiB,CAACvH,GAAG,CAAC6H,GAAG,IACjDA,GAAG,KAAKE,WAAW,GAAGC,WAAW,GAAGH,GACtC,CAAC;;MAED;MACA,MAAMzK,MAAM,CAACgK,aAAa,EAAE;QAAEI,UAAU,EAAEF;MAAkB,CAAC,CAAC;;MAE9D;MACAtI,mBAAmB,CAACsI,iBAAiB,CAAC;MAEtC,OAAO,IAAI;IACb,CAAC,CAAC,OAAO1I,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;MACtD,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMyJ,kBAAkB,GAAGA,CAACC,KAAK,EAAEC,IAAI,KAAK;IAC1C,IAAI,CAAChJ,WAAW,EAAE,OAAO,EAAE;IAE3B,MAAMiJ,UAAU,GAAG,IAAIxH,IAAI,CAACuH,IAAI,EAAED,KAAK,CAAC;IACxC,MAAMG,WAAW,GAAGD,UAAU,CAAC5C,QAAQ,CAAC,CAAC;IACzC,MAAM8C,UAAU,GAAGF,UAAU,CAAC1C,WAAW,CAAC,CAAC;IAE3C,OAAO/H,QAAQ,CAACiI,MAAM,CAACtF,OAAO,IAAI;MAChC,IAAI,CAACA,OAAO,CAACK,IAAI,EAAE,OAAO,KAAK;MAE/B,IAAI;QACF,MAAMkF,WAAW,GAAG,IAAIjF,IAAI,CAACN,OAAO,CAACK,IAAI,CAAC;QAC1C,OAAOkF,WAAW,CAACL,QAAQ,CAAC,CAAC,KAAK6C,WAAW,IACvCxC,WAAW,CAACH,WAAW,CAAC,CAAC,KAAK4C,UAAU,IACxChI,OAAO,CAACU,MAAM,KAAK7B,WAAW,CAACI,GAAG;MAC1C,CAAC,CAAC,OAAOuG,CAAC,EAAE;QACV,OAAO,KAAK;MACd;IACF,CAAC,CAAC;EACJ,CAAC;;EAED;EACA,MAAMyC,iBAAiB,GAAGA,CAACL,KAAK,EAAEC,IAAI,KAAK;IACzC,IAAI,CAAChJ,WAAW,EAAE,OAAO,EAAE;IAE3B,MAAMiJ,UAAU,GAAG,IAAIxH,IAAI,CAACuH,IAAI,EAAED,KAAK,CAAC;IACxC,MAAMG,WAAW,GAAGD,UAAU,CAAC5C,QAAQ,CAAC,CAAC;IACzC,MAAM8C,UAAU,GAAGF,UAAU,CAAC1C,WAAW,CAAC,CAAC;IAE3C,OAAO7H,OAAO,CAAC+H,MAAM,CAAC1B,MAAM,IAAI;MAC9B,IAAI,CAACA,MAAM,CAACvD,IAAI,EAAE,OAAO,KAAK;MAE9B,IAAI;QACF,MAAM6H,UAAU,GAAG,IAAI5H,IAAI,CAACsD,MAAM,CAACvD,IAAI,CAAC;QACxC,OAAO6H,UAAU,CAAChD,QAAQ,CAAC,CAAC,KAAK6C,WAAW,IACtCG,UAAU,CAAC9C,WAAW,CAAC,CAAC,KAAK4C,UAAU,IACvCpE,MAAM,CAAClD,MAAM,KAAK7B,WAAW,CAACI,GAAG;MACzC,CAAC,CAAC,OAAOuG,CAAC,EAAE;QACV,OAAO,KAAK;MACd;IACF,CAAC,CAAC;EACJ,CAAC;;EAED;EACA,MAAM2C,eAAe,GAAG,MAAAA,CAAA,KAAY;IAClC,IAAI,CAACtJ,WAAW,EAAE,OAAO,EAAE;IAE3B,IAAI;MACF,MAAMuJ,UAAU,GAAG/L,KAAK,CACtBL,UAAU,CAACF,EAAE,EAAE,cAAc,CAAC,EAC9BQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CACvC,CAAC;MAED,MAAMoJ,SAAS,GAAG,MAAM9L,OAAO,CAAC6L,UAAU,CAAC;MAE3C,OAAOC,SAAS,CAAChJ,IAAI,CAACC,GAAG,CAACpD,GAAG,KAAK;QAChCqD,EAAE,EAAErD,GAAG,CAACqD,EAAE;QACV,GAAGrD,GAAG,CAACwC,IAAI,CAAC;MACd,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,OAAOR,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,OAAO,EAAE;IACX;EACF,CAAC;;EAED;EACA,MAAMoK,aAAa,GAAG,MAAAA,CAAO/I,EAAE,EAAEgJ,WAAW,KAAK;IAC/C,IAAI,CAAC1J,WAAW,IAAI,CAACU,EAAE,EAAE,OAAO,KAAK;IAErC,IAAI;MACF,MAAM0E,UAAU,GAAG/H,GAAG,CAACJ,EAAE,EAAE,UAAU,EAAEyD,EAAE,CAAC;MAC1C,MAAMnD,SAAS,CAAC6H,UAAU,EAAEsE,WAAW,CAAC;MACxC,OAAO,IAAI;IACb,CAAC,CAAC,OAAOrK,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/C,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMsK,YAAY,GAAG,MAAAA,CAAOjJ,EAAE,EAAEgJ,WAAW,KAAK;IAC9C,IAAI,CAAC1J,WAAW,IAAI,CAACU,EAAE,EAAE,OAAO,KAAK;IAErC,IAAI;MACF,MAAMkJ,SAAS,GAAGvM,GAAG,CAACJ,EAAE,EAAE,SAAS,EAAEyD,EAAE,CAAC;MACxC,MAAMnD,SAAS,CAACqM,SAAS,EAAEF,WAAW,CAAC;MACvC,OAAO,IAAI;IACb,CAAC,CAAC,OAAOrK,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMwK,UAAU,GAAG,MAAAA,CAAA,KAAY;IAC7B,IAAI,CAAC7J,WAAW,EAAE,OAAO,IAAI;IAE7B,IAAI;MACF;MACA,MAAMG,aAAa,GAAG3C,KAAK,CACzBL,UAAU,CAACF,EAAE,EAAE,UAAU,CAAC,EAC1BQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CACvC,CAAC;MAED,MAAMQ,YAAY,GAAGpD,KAAK,CACxBL,UAAU,CAACF,EAAE,EAAE,SAAS,CAAC,EACzBQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CACvC,CAAC;MAED,MAAMmJ,UAAU,GAAG/L,KAAK,CACtBL,UAAU,CAACF,EAAE,EAAE,cAAc,CAAC,EAC9BQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CACvC,CAAC;MAED,MAAM,CAAC+H,YAAY,EAAES,WAAW,EAAEY,SAAS,EAAEM,cAAc,EAAEC,WAAW,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CAC5FvM,OAAO,CAACyC,aAAa,CAAC,EACtBzC,OAAO,CAACkD,YAAY,CAAC,EACrBlD,OAAO,CAAC6L,UAAU,CAAC,EACnB3L,MAAM,CAACP,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,mBAAmB,CAAC,CAAC,EAC1ExC,MAAM,CAACP,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC,CACjE,CAAC;MAEF,MAAMyJ,UAAU,GAAG;QACjBrL,QAAQ,EAAE2J,YAAY,CAAC3H,IAAI,CAACC,GAAG,CAACpD,GAAG,KAAK;UAACqD,EAAE,EAAErD,GAAG,CAACqD,EAAE;UAAE,GAAGrD,GAAG,CAACwC,IAAI,CAAC;QAAC,CAAC,CAAC,CAAC;QACrEnB,OAAO,EAAEkK,WAAW,CAACpI,IAAI,CAACC,GAAG,CAACpD,GAAG,KAAK;UAACqD,EAAE,EAAErD,GAAG,CAACqD,EAAE;UAAE,GAAGrD,GAAG,CAACwC,IAAI,CAAC;QAAC,CAAC,CAAC,CAAC;QACnEC,YAAY,EAAE0J,SAAS,CAAChJ,IAAI,CAACC,GAAG,CAACpD,GAAG,KAAK;UAACqD,EAAE,EAAErD,GAAG,CAACqD,EAAE;UAAE,GAAGrD,GAAG,CAACwC,IAAI,CAAC;QAAC,CAAC,CAAC,CAAC;QACtEP,iBAAiB,EAAEwK,cAAc,CAACxE,MAAM,CAAC,CAAC,GAAGwE,cAAc,CAACjK,IAAI,CAAC,CAAC,CAACoI,UAAU,GAAGhI,0BAA0B;QAC1GT,gBAAgB,EAAEA,gBAAgB;QAClCZ,OAAO,EAAEmL,WAAW,CAACzE,MAAM,CAAC,CAAC,GAAGyE,WAAW,CAAClK,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACvDqK,UAAU,EAAE,IAAIzI,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QACpCG,MAAM,EAAE7B,WAAW,CAACI;MACtB,CAAC;MAED,OAAOyJ,UAAU;IACnB,CAAC,CAAC,OAAOxK,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC7C,OAAO,IAAI;IACb;EACF,CAAC;;EAED;EACA,MAAM8K,UAAU,GAAG,MAAOtK,IAAI,IAAK;IACjC,IAAI,CAACG,WAAW,IAAI,CAACH,IAAI,EAAE,OAAO,KAAK;IAEvC,IAAI;MACF;MACA,IAAI,CAACA,IAAI,CAACrB,QAAQ,IAAI,CAACqB,IAAI,CAACnB,OAAO,IAAI,CAACmB,IAAI,CAACjB,OAAO,IAChD,CAACiB,IAAI,CAACP,iBAAiB,IAAI,CAACO,IAAI,CAACL,gBAAgB,EAAE;QACrDmB,OAAO,CAACtB,KAAK,CAAC,+BAA+B,CAAC;QAC9C,OAAO,KAAK;MACd;;MAEA;MACA,MAAM+K,KAAK,GAAGnN,EAAE,CAACmN,KAAK,CAAC,CAAC;;MAExB;MACA,MAAMC,oBAAoB,GAAGhN,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,mBAAmB,CAAC;MAC/FgK,KAAK,CAACE,GAAG,CAACD,oBAAoB,EAAE;QAAEpC,UAAU,EAAEpI,IAAI,CAACP;MAAkB,CAAC,CAAC;;MAEvE;MACA,MAAMiL,mBAAmB,GAAGlN,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,kBAAkB,CAAC;MAC7FgK,KAAK,CAACE,GAAG,CAACC,mBAAmB,EAAE;QAAEtC,UAAU,EAAEpI,IAAI,CAACL;MAAiB,CAAC,CAAC;;MAErE;MACA,MAAMgL,UAAU,GAAGnN,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,SAAS,CAAC;MAC3EgK,KAAK,CAACE,GAAG,CAACE,UAAU,EAAE3K,IAAI,CAACjB,OAAO,CAAC;;MAEnC;MACA,MAAMwL,KAAK,CAACK,MAAM,CAAC,CAAC;;MAEpB;MACAlL,oBAAoB,CAACM,IAAI,CAACP,iBAAiB,CAAC;MAC5CG,mBAAmB,CAACI,IAAI,CAACL,gBAAgB,CAAC;MAC1CX,UAAU,CAACgB,IAAI,CAACjB,OAAO,CAAC;;MAExB;MACA,KAAK,MAAMuC,OAAO,IAAItB,IAAI,CAACrB,QAAQ,EAAE;QACnC,IAAI;UACF,MAAM;YAAEkC,EAAE;YAAE,GAAGgD;UAAY,CAAC,GAAGvC,OAAO;UACtCuC,WAAW,CAAC7B,MAAM,GAAG7B,WAAW,CAACI,GAAG,CAAC,CAAC;UACtC,MAAMhD,MAAM,CAACD,UAAU,CAACF,EAAE,EAAE,UAAU,CAAC,EAAEyG,WAAW,CAAC;QACvD,CAAC,CAAC,OAAOiD,CAAC,EAAE;UACVhG,OAAO,CAACtB,KAAK,CAAC,0BAA0B,EAAEsH,CAAC,CAAC;UAC5C;QACF;MACF;MAEA,KAAK,MAAM5B,MAAM,IAAIlF,IAAI,CAACnB,OAAO,EAAE;QACjC,IAAI;UACF,MAAM;YAAEgC,EAAE;YAAE,GAAGgK;UAAW,CAAC,GAAG3F,MAAM;UACpC2F,UAAU,CAAC7I,MAAM,GAAG7B,WAAW,CAACI,GAAG,CAAC,CAAC;UACrC,MAAMhD,MAAM,CAACD,UAAU,CAACF,EAAE,EAAE,SAAS,CAAC,EAAEyN,UAAU,CAAC;QACrD,CAAC,CAAC,OAAO/D,CAAC,EAAE;UACVhG,OAAO,CAACtB,KAAK,CAAC,yBAAyB,EAAEsH,CAAC,CAAC;UAC3C;QACF;MACF;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAOtH,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC7C,OAAO,KAAK;IACd;EACF,CAAC;;EAED;EACA,MAAMsL,mBAAmB,GAAG,MAAAA,CAAOC,MAAM,GAAG,CAAC,KAAK;IAChD,IAAI,CAAC5K,WAAW,IAAI4K,MAAM,GAAG,CAAC,EAAE,OAAO,IAAI;IAE3C,IAAI;MACF,MAAMzE,WAAW,GAAG,IAAI1E,IAAI,CAAC,CAAC;MAC9B,MAAMoJ,QAAQ,GAAG;QACfC,aAAa,EAAE,EAAE;QACjBC,aAAa,EAAE,EAAE;QACjBC,gBAAgB,EAAE,CAAC,CAAC;QACpBC,YAAY,EAAE;UACZC,KAAK,EAAE,CAAC;UACRC,UAAU,EAAE;QACd;MACF,CAAC;;MAED;MACA,MAAMC,SAAS,GAAG,IAAI3J,IAAI,CAAC,CAAC;MAC5B2J,SAAS,CAACC,QAAQ,CAACD,SAAS,CAAC/E,QAAQ,CAAC,CAAC,GAAGuE,MAAM,CAAC;;MAEjD;MACA,MAAMU,eAAe,GAAGF,SAAS,CAAC1J,WAAW,CAAC,CAAC;MAE/C,MAAMvB,aAAa,GAAG3C,KAAK,CACzBL,UAAU,CAACF,EAAE,EAAE,UAAU,CAAC,EAC1BQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CAAC,EACtC3C,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE6N,eAAe,CACrC,CAAC;MAED,MAAMnD,YAAY,GAAG,MAAMzK,OAAO,CAACyC,aAAa,CAAC;MAEjD,MAAMoL,gBAAgB,GAAGpD,YAAY,CAAC3H,IAAI,CAACC,GAAG,CAACpD,GAAG,KAAK;QACrDqD,EAAE,EAAErD,GAAG,CAACqD,EAAE;QACV,GAAGrD,GAAG,CAACwC,IAAI,CAAC;MACd,CAAC,CAAC,CAAC;;MAEH;MACA,MAAM2L,cAAc,GAAG,CAAC,CAAC;MACzBD,gBAAgB,CAACE,OAAO,CAACtK,OAAO,IAAI;QAClC,MAAM;UAAEE,QAAQ;UAAEC;QAAO,CAAC,GAAGH,OAAO;QACpC,IAAI,CAACE,QAAQ,EAAE;QAEfmK,cAAc,CAACnK,QAAQ,CAAC,GAAG,CAACmK,cAAc,CAACnK,QAAQ,CAAC,IAAI,CAAC,IAAIE,UAAU,CAACD,MAAM,IAAI,CAAC,CAAC;MACtF,CAAC,CAAC;MAEFuJ,QAAQ,CAACC,aAAa,GAAGnG,MAAM,CAACC,OAAO,CAAC4G,cAAc,CAAC,CACpD/K,GAAG,CAAC,CAAC,CAACY,QAAQ,EAAE6J,KAAK,CAAC,MAAM;QAAE7J,QAAQ;QAAE6J;MAAM,CAAC,CAAC,CAAC,CACjDQ,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACV,KAAK,GAAGS,CAAC,CAACT,KAAK,CAAC,CACjCvJ,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;;MAEhB;MACA,MAAMkK,WAAW,GAAG,CAAC,CAAC;MACtBN,gBAAgB,CAACE,OAAO,CAACtK,OAAO,IAAI;QAClC,IAAI,CAACA,OAAO,CAACK,IAAI,EAAE;QAEnB,MAAMkF,WAAW,GAAG,IAAIjF,IAAI,CAACN,OAAO,CAACK,IAAI,CAAC;QAC1C,MAAMsK,SAAS,GAAG,GAAGpF,WAAW,CAACH,WAAW,CAAC,CAAC,IAAIG,WAAW,CAACL,QAAQ,CAAC,CAAC,GAAC,CAAC,EAAE;QAE5E,IAAI,CAACwF,WAAW,CAACC,SAAS,CAAC,EAAE;UAC3BD,WAAW,CAACC,SAAS,CAAC,GAAG;YACvB/C,KAAK,EAAErC,WAAW,CAACL,QAAQ,CAAC,CAAC;YAC7B2C,IAAI,EAAEtC,WAAW,CAACH,WAAW,CAAC,CAAC;YAC/B2E,KAAK,EAAE,CAAC;YACRa,KAAK,EAAErF,WAAW,CAACsF,cAAc,CAAC,SAAS,EAAE;cAAEjD,KAAK,EAAE,OAAO;cAAEC,IAAI,EAAE;YAAU,CAAC;UAClF,CAAC;QACH;QAEA6C,WAAW,CAACC,SAAS,CAAC,CAACZ,KAAK,IAAI3J,UAAU,CAACJ,OAAO,CAACG,MAAM,IAAI,CAAC,CAAC;MACjE,CAAC,CAAC;MAEFuJ,QAAQ,CAACE,aAAa,GAAGpG,MAAM,CAACsH,MAAM,CAACJ,WAAW,CAAC,CAChDH,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;QACd,IAAID,CAAC,CAAC3C,IAAI,KAAK4C,CAAC,CAAC5C,IAAI,EAAE,OAAO2C,CAAC,CAAC3C,IAAI,GAAG4C,CAAC,CAAC5C,IAAI;QAC7C,OAAO2C,CAAC,CAAC5C,KAAK,GAAG6C,CAAC,CAAC7C,KAAK;MAC1B,CAAC,CAAC;;MAEJ;MACA,MAAMmD,aAAa,GAAGX,gBAAgB,CAAC9E,MAAM,CAACtF,OAAO,IAAIA,OAAO,CAACkC,WAAW,CAAC,CAAC8I,MAAM;MACpFtB,QAAQ,CAACI,YAAY,GAAG;QACtBC,KAAK,EAAEgB,aAAa;QACpBf,UAAU,EAAEI,gBAAgB,CAACY,MAAM,GAAG,CAAC,GAClCD,aAAa,GAAGX,gBAAgB,CAACY,MAAM,GAAI,GAAG,GAC/C;MACN,CAAC;MAED,OAAOtB,QAAQ;IACjB,CAAC,CAAC,OAAOxL,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;MAC3D,OAAO,IAAI;IACb;EACF,CAAC;;EAED;EACA1C,SAAS,CAAC,MAAM;IACd,IAAI,CAACqD,WAAW,EAAE;MAChBT,oBAAoB,CAAC,EAAE,CAAC;MACxBE,mBAAmB,CAAC,EAAE,CAAC;MACvBZ,UAAU,CAAC,CAAC,CAAC,CAAC;MACd;IACF;;IAEA;IACA,MAAMuN,aAAa,GAAG,MAAAA,CAAA,KAAY;MAChC,IAAI;QACF;QACA,MAAM/B,oBAAoB,GAAGhN,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,mBAAmB,CAAC;QAC/F,MAAMiM,oBAAoB,GAAG,MAAMzO,MAAM,CAACyM,oBAAoB,CAAC;QAE/D,IAAIgC,oBAAoB,CAAC/G,MAAM,CAAC,CAAC,EAAE;UACjC/F,oBAAoB,CAAC8M,oBAAoB,CAACxM,IAAI,CAAC,CAAC,CAACoI,UAAU,IAAIhI,0BAA0B,CAAC;QAC5F,CAAC,MAAM;UACL;UACA,MAAMpC,MAAM,CAACwM,oBAAoB,EAAE;YACjCpC,UAAU,EAAEhI;UACd,CAAC,CAAC;UACFV,oBAAoB,CAACU,0BAA0B,CAAC;QAClD;;QAEA;QACA,MAAMsK,mBAAmB,GAAGlN,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,kBAAkB,CAAC;QAC7F,MAAMkM,mBAAmB,GAAG,MAAM1O,MAAM,CAAC2M,mBAAmB,CAAC;QAE7D,IAAI+B,mBAAmB,CAAChH,MAAM,CAAC,CAAC,EAAE;UAChC7F,mBAAmB,CAAC6M,mBAAmB,CAACzM,IAAI,CAAC,CAAC,CAACoI,UAAU,IAAI/H,yBAAyB,CAAC;QACzF,CAAC,MAAM;UACL;UACA,MAAMrC,MAAM,CAAC0M,mBAAmB,EAAE;YAChCtC,UAAU,EAAE/H;UACd,CAAC,CAAC;UACFT,mBAAmB,CAACS,yBAAyB,CAAC;QAChD;;QAEA;QACA,MAAMsK,UAAU,GAAGnN,GAAG,CAACJ,EAAE,EAAE,OAAO,EAAE+C,WAAW,CAACI,GAAG,EAAE,UAAU,EAAE,SAAS,CAAC;QAC3E,MAAMmM,UAAU,GAAG,MAAM3O,MAAM,CAAC4M,UAAU,CAAC;QAE3C,IAAI+B,UAAU,CAACjH,MAAM,CAAC,CAAC,EAAE;UACvBzG,UAAU,CAAC0N,UAAU,CAAC1M,IAAI,CAAC,CAAC,CAAC;QAC/B;MACF,CAAC,CAAC,OAAOR,KAAK,EAAE;QACdsB,OAAO,CAACtB,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;QAC/CE,oBAAoB,CAACU,0BAA0B,CAAC;QAChDR,mBAAmB,CAACS,yBAAyB,CAAC;MAChD;IACF,CAAC;IAEDkM,aAAa,CAAC,CAAC;EACjB,CAAC,EAAE,CAACpM,WAAW,CAAC,CAAC;;EAEjB;EACArD,SAAS,CAAC,MAAM;IACd,IAAI,CAACqD,WAAW,EAAE;MAChBjB,SAAS,CAAC,EAAE,CAAC;MACb;IACF;;IAEA;IACA,MAAMyN,WAAW,GAAGhP,KAAK,CACvBL,UAAU,CAACF,EAAE,EAAE,QAAQ,CAAC,EACxBQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CAAC,EACtC3C,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAC3B,CAAC;;IAED;IACA,MAAM4C,WAAW,GAAG1C,UAAU,CAAC6O,WAAW,EAAGlM,QAAQ,IAAK;MACxD,MAAMmM,UAAU,GAAGnM,QAAQ,CAACE,IAAI,CAACC,GAAG,CAACpD,GAAG,KAAK;QAC3CqD,EAAE,EAAErD,GAAG,CAACqD,EAAE;QACV,GAAGrD,GAAG,CAACwC,IAAI,CAAC;MACd,CAAC,CAAC,CAAC;MACHd,SAAS,CAAC0N,UAAU,CAAC;IACvB,CAAC,EAAGpN,KAAK,IAAK;MACZsB,OAAO,CAACtB,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;IAC/C,CAAC,CAAC;IAEF,OAAO,MAAMgB,WAAW,CAAC,CAAC;EAC5B,CAAC,EAAE,CAACL,WAAW,CAAC,CAAC;;EAEjB;EACArD,SAAS,CAAC,MAAM;IACd,IAAI,CAACqD,WAAW,EAAE;MAChBD,eAAe,CAAC,EAAE,CAAC;MACnB;IACF;;IAEA;IACA,MAAMwJ,UAAU,GAAG/L,KAAK,CACtBL,UAAU,CAACF,EAAE,EAAE,cAAc,CAAC,EAC9BQ,KAAK,CAAC,QAAQ,EAAE,IAAI,EAAEuC,WAAW,CAACI,GAAG,CACvC,CAAC;;IAED;IACA,MAAMC,WAAW,GAAG1C,UAAU,CAAC4L,UAAU,EAAGjJ,QAAQ,IAAK;MACvD,MAAMoM,SAAS,GAAGpM,QAAQ,CAACE,IAAI,CAACC,GAAG,CAACpD,GAAG,KAAK;QAC1CqD,EAAE,EAAErD,GAAG,CAACqD,EAAE;QACV,GAAGrD,GAAG,CAACwC,IAAI,CAAC;MACd,CAAC,CAAC,CAAC;MACHE,eAAe,CAAC2M,SAAS,CAAC;IAC5B,CAAC,EAAGrN,KAAK,IAAK;MACZsB,OAAO,CAACtB,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;IACtD,CAAC,CAAC;IAEF,OAAO,MAAMgB,WAAW,CAAC,CAAC;EAC5B,CAAC,EAAE,CAACL,WAAW,CAAC,CAAC;EAEjB,oBACE7B,OAAA,CAACC,cAAc,CAACuO,QAAQ;IAACC,KAAK,EAAE;MAC9BpO,QAAQ;MACRE,OAAO;MACPE,OAAO;MACPE,MAAM;MACNQ,iBAAiB;MACjBE,gBAAgB;MAChBE,iBAAiB;MACjBI,YAAY;MACZZ,WAAW;MACXF,OAAO;MACPkC,UAAU;MACV4D,SAAS;MACTK,aAAa;MACbK,YAAY;MACZiE,aAAa;MACbE,YAAY;MACZlE,YAAY;MACZK,YAAY;MACZ4B,eAAe;MACfC,WAAW;MACXC,kBAAkB;MAClBM,qBAAqB;MACrBK,mBAAmB;MACnBG,iBAAiB;MACjBC,oBAAoB;MACpBE,kBAAkB;MAClBzG,WAAW;MACXqB,qBAAqB;MACrBS,oBAAoB;MACpB4E,kBAAkB;MAClBM,iBAAiB;MACjBE,eAAe;MACfO,UAAU;MACVM,UAAU;MACVQ;IACF,CAAE;IAAArM,QAAA,EACCA;EAAQ;IAAAuO,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACc,CAAC;AAE9B,CAAC;AAACzO,EAAA,CAt2CWF,eAAe;AAAA4O,EAAA,GAAf5O,eAAe;AAAA,IAAA4O,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}