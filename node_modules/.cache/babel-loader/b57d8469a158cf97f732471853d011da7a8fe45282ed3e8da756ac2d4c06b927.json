{"ast":null,"code":"// src/services/ReceiptScanningService.js\n\n/**\r\n * Service for handling receipt scanning functionality\r\n * This service mocks a server-side OCR processing approach\r\n */\n\n/**\r\n * Processes a receipt image and extracts relevant expense data\r\n * \r\n * @param {File|Blob} imageFile - The receipt image file to process\r\n * @returns {Promise<Object>} - Extracted receipt data or error information\r\n */\nexport const scanReceiptImage = async imageFile => {\n  if (!imageFile) {\n    return {\n      success: false,\n      error: 'No image file provided'\n    };\n  }\n\n  // Check if file is a valid image type\n  const validImageTypes = ['image/jpeg', 'image/png', 'image/heic', 'image/heif'];\n  if (!validImageTypes.includes(imageFile.type)) {\n    return {\n      success: false,\n      error: 'Invalid file format. Please upload a JPEG or PNG image.'\n    };\n  }\n  try {\n    // Create form data that would normally be sent to a server\n    const formData = new FormData();\n    formData.append('receipt', imageFile);\n\n    // In a real implementation, this would make an API call to a server\n    // for OCR processing. We'll simulate the server response here.\n\n    // Simulate processing time\n    await new Promise(resolve => setTimeout(resolve, 1500));\n\n    // Generate a temporary URL for the uploaded image\n    const imageUrl = URL.createObjectURL(imageFile);\n\n    // Mock a successful response with extracted data\n    const extractedData = simulateOCRResponse(imageUrl);\n    return {\n      success: true,\n      ...extractedData,\n      imageUrl\n    };\n  } catch (error) {\n    console.error('Error scanning receipt:', error);\n    return {\n      success: false,\n      error: error.message || 'Failed to process receipt. Please try again.'\n    };\n  }\n};\n\n/**\r\n * Helper function to simulate OCR API response\r\n * In production, this would be replaced by the actual API call\r\n * \r\n * @param {string} imageUrl - URL to the receipt image\r\n * @returns {Object} - Simulated extracted data\r\n */\nconst simulateOCRResponse = imageUrl => {\n  // Generate a random amount between $5 and $150\n  const amount = (Math.random() * 145 + 5).toFixed(2);\n\n  // Generate a random date within the last 30 days\n  const today = new Date();\n  const daysAgo = Math.floor(Math.random() * 30);\n  const receiptDate = new Date(today);\n  receiptDate.setDate(today.getDate() - daysAgo);\n  const dateString = receiptDate.toISOString().split('T')[0];\n\n  // Select a random merchant from common options\n  const merchants = ['Whole Foods Market', 'Target', 'Amazon', 'Starbucks', 'Chevron', 'Walgreens', 'CVS Pharmacy', 'Home Depot', 'Trader Joe\\'s', 'Best Buy', 'Subway', 'Shell', 'Walmart', 'Kroger', 'McDonald\\'s', 'Costco'];\n  const merchantName = merchants[Math.floor(Math.random() * merchants.length)];\n\n  // Map merchant to appropriate category\n  const categoryMap = {\n    'Whole Foods Market': 'Food',\n    'Target': 'Shopping',\n    'Amazon': 'Shopping',\n    'Starbucks': 'Food',\n    'Chevron': 'Transportation',\n    'Walgreens': 'Healthcare',\n    'CVS Pharmacy': 'Healthcare',\n    'Home Depot': 'Housing',\n    'Trader Joe\\'s': 'Food',\n    'Best Buy': 'Shopping',\n    'Subway': 'Food',\n    'Shell': 'Transportation',\n    'Walmart': 'Shopping',\n    'Kroger': 'Food',\n    'McDonald\\'s': 'Food',\n    'Costco': 'Shopping'\n  };\n  const category = categoryMap[merchantName] || 'Other';\n  return {\n    merchantName,\n    amount,\n    date: dateString,\n    category,\n    confidence: 0.92,\n    // Simulated confidence score\n    description: merchantName // Use merchant name as description\n  };\n};\n\n/**\r\n * Parse and validate receipt data returned from the OCR service\r\n * \r\n * @param {Object} ocrData - Raw data from the OCR service\r\n * @returns {Object} - Normalized receipt data\r\n */\nexport const parseReceiptData = ocrData => {\n  if (!ocrData || !ocrData.success) {\n    return null;\n  }\n\n  // Extract and validate amount\n  let amount = parseFloat(ocrData.amount);\n  if (isNaN(amount) || amount <= 0) {\n    amount = 0;\n  }\n\n  // Validate date\n  let receiptDate = ocrData.date;\n  if (!receiptDate || !isValidDate(receiptDate)) {\n    receiptDate = new Date().toISOString().slice(0, 10);\n  }\n\n  // Normalize merchant name\n  const merchantName = ocrData.merchantName || 'Unknown Vendor';\n  return {\n    amount,\n    date: receiptDate,\n    description: merchantName,\n    category: ocrData.category || 'Other',\n    imageUrl: ocrData.imageUrl || null,\n    notes: ocrData.notes || ''\n  };\n};\n\n/**\r\n * Helper function to validate date string\r\n * \r\n * @param {string} dateString - Date string to validate\r\n * @returns {boolean} - Whether the date is valid\r\n */\nconst isValidDate = dateString => {\n  if (!dateString) return false;\n\n  // Try to create a date object and check if it's valid\n  const date = new Date(dateString);\n  return !isNaN(date.getTime());\n};\nexport default ReceiptScanner;","map":{"version":3,"names":["scanReceiptImage","imageFile","success","error","validImageTypes","includes","type","formData","FormData","append","Promise","resolve","setTimeout","imageUrl","URL","createObjectURL","extractedData","simulateOCRResponse","console","message","amount","Math","random","toFixed","today","Date","daysAgo","floor","receiptDate","setDate","getDate","dateString","toISOString","split","merchants","merchantName","length","categoryMap","category","date","confidence","description","parseReceiptData","ocrData","parseFloat","isNaN","isValidDate","slice","notes","getTime","ReceiptScanner"],"sources":["C:/Users/tejit/OneDrive/Desktop/expence tracker final/expence-tracker/src/components/ReceiptScanner.js"],"sourcesContent":["// src/services/ReceiptScanningService.js\r\n\r\n/**\r\n * Service for handling receipt scanning functionality\r\n * This service mocks a server-side OCR processing approach\r\n */\r\n\r\n/**\r\n * Processes a receipt image and extracts relevant expense data\r\n * \r\n * @param {File|Blob} imageFile - The receipt image file to process\r\n * @returns {Promise<Object>} - Extracted receipt data or error information\r\n */\r\nexport const scanReceiptImage = async (imageFile) => {\r\n  if (!imageFile) {\r\n    return { \r\n      success: false, \r\n      error: 'No image file provided' \r\n    };\r\n  }\r\n  \r\n  // Check if file is a valid image type\r\n  const validImageTypes = ['image/jpeg', 'image/png', 'image/heic', 'image/heif'];\r\n  if (!validImageTypes.includes(imageFile.type)) {\r\n    return {\r\n      success: false,\r\n      error: 'Invalid file format. Please upload a JPEG or PNG image.'\r\n    };\r\n  }\r\n  \r\n  try {\r\n    // Create form data that would normally be sent to a server\r\n    const formData = new FormData();\r\n    formData.append('receipt', imageFile);\r\n    \r\n    // In a real implementation, this would make an API call to a server\r\n    // for OCR processing. We'll simulate the server response here.\r\n    \r\n    // Simulate processing time\r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n    \r\n    // Generate a temporary URL for the uploaded image\r\n    const imageUrl = URL.createObjectURL(imageFile);\r\n    \r\n    // Mock a successful response with extracted data\r\n    const extractedData = simulateOCRResponse(imageUrl);\r\n    \r\n    return {\r\n      success: true,\r\n      ...extractedData,\r\n      imageUrl\r\n    };\r\n  } catch (error) {\r\n    console.error('Error scanning receipt:', error);\r\n    return {\r\n      success: false,\r\n      error: error.message || 'Failed to process receipt. Please try again.'\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Helper function to simulate OCR API response\r\n * In production, this would be replaced by the actual API call\r\n * \r\n * @param {string} imageUrl - URL to the receipt image\r\n * @returns {Object} - Simulated extracted data\r\n */\r\nconst simulateOCRResponse = (imageUrl) => {\r\n  // Generate a random amount between $5 and $150\r\n  const amount = (Math.random() * 145 + 5).toFixed(2);\r\n  \r\n  // Generate a random date within the last 30 days\r\n  const today = new Date();\r\n  const daysAgo = Math.floor(Math.random() * 30);\r\n  const receiptDate = new Date(today);\r\n  receiptDate.setDate(today.getDate() - daysAgo);\r\n  const dateString = receiptDate.toISOString().split('T')[0];\r\n  \r\n  // Select a random merchant from common options\r\n  const merchants = [\r\n    'Whole Foods Market', 'Target', 'Amazon', 'Starbucks',\r\n    'Chevron', 'Walgreens', 'CVS Pharmacy', 'Home Depot',\r\n    'Trader Joe\\'s', 'Best Buy', 'Subway', 'Shell',\r\n    'Walmart', 'Kroger', 'McDonald\\'s', 'Costco'\r\n  ];\r\n  const merchantName = merchants[Math.floor(Math.random() * merchants.length)];\r\n  \r\n  // Map merchant to appropriate category\r\n  const categoryMap = {\r\n    'Whole Foods Market': 'Food',\r\n    'Target': 'Shopping',\r\n    'Amazon': 'Shopping',\r\n    'Starbucks': 'Food',\r\n    'Chevron': 'Transportation',\r\n    'Walgreens': 'Healthcare',\r\n    'CVS Pharmacy': 'Healthcare',\r\n    'Home Depot': 'Housing',\r\n    'Trader Joe\\'s': 'Food',\r\n    'Best Buy': 'Shopping',\r\n    'Subway': 'Food',\r\n    'Shell': 'Transportation',\r\n    'Walmart': 'Shopping',\r\n    'Kroger': 'Food',\r\n    'McDonald\\'s': 'Food',\r\n    'Costco': 'Shopping'\r\n  };\r\n  \r\n  const category = categoryMap[merchantName] || 'Other';\r\n  \r\n  return {\r\n    merchantName,\r\n    amount,\r\n    date: dateString,\r\n    category,\r\n    confidence: 0.92, // Simulated confidence score\r\n    description: merchantName  // Use merchant name as description\r\n  };\r\n};\r\n\r\n/**\r\n * Parse and validate receipt data returned from the OCR service\r\n * \r\n * @param {Object} ocrData - Raw data from the OCR service\r\n * @returns {Object} - Normalized receipt data\r\n */\r\nexport const parseReceiptData = (ocrData) => {\r\n  if (!ocrData || !ocrData.success) {\r\n    return null;\r\n  }\r\n  \r\n  // Extract and validate amount\r\n  let amount = parseFloat(ocrData.amount);\r\n  if (isNaN(amount) || amount <= 0) {\r\n    amount = 0;\r\n  }\r\n  \r\n  // Validate date\r\n  let receiptDate = ocrData.date;\r\n  if (!receiptDate || !isValidDate(receiptDate)) {\r\n    receiptDate = new Date().toISOString().slice(0, 10);\r\n  }\r\n  \r\n  // Normalize merchant name\r\n  const merchantName = ocrData.merchantName || 'Unknown Vendor';\r\n  \r\n  return {\r\n    amount,\r\n    date: receiptDate,\r\n    description: merchantName,\r\n    category: ocrData.category || 'Other',\r\n    imageUrl: ocrData.imageUrl || null,\r\n    notes: ocrData.notes || ''\r\n  };\r\n};\r\n\r\n/**\r\n * Helper function to validate date string\r\n * \r\n * @param {string} dateString - Date string to validate\r\n * @returns {boolean} - Whether the date is valid\r\n */\r\nconst isValidDate = (dateString) => {\r\n  if (!dateString) return false;\r\n  \r\n  // Try to create a date object and check if it's valid\r\n  const date = new Date(dateString);\r\n  return !isNaN(date.getTime());\r\n};\r\nexport default ReceiptScanner;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}