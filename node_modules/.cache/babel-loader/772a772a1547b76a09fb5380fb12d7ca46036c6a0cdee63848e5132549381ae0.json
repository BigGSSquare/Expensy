{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\tejit\\\\OneDrive\\\\Desktop\\\\expence tracker final\\\\expence-tracker\\\\src\\\\context\\\\SplitExpenseContext.js\",\n  _s = $RefreshSig$();\n// src/context/SplitExpenseContext.js\nimport React, { createContext, useState, useEffect, useContext, useRef } from 'react';\nimport { AuthContext } from './AuthContext';\nimport { ExpenseContext } from './ExpenseContext';\nimport { createSplitExpense, createParticipant, updateParticipantStatus, calculateSplitStatus } from '../models/SplitExpenseModel';\nimport { sendSplitExpenseEmail } from '../services/EmailService';\n// Add Firebase imports\nimport { db } from '../config/firebase';\nimport { collection, addDoc, doc, deleteDoc, updateDoc, query, where, getDocs, onSnapshot, getDoc, setDoc } from 'firebase/firestore';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const SplitExpenseContext = /*#__PURE__*/createContext();\nexport const SplitExpenseProvider = ({\n  children\n}) => {\n  _s();\n  const [splitExpenses, setSplitExpenses] = useState([]);\n  const [contacts, setContacts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [emailStatus, setEmailStatus] = useState({});\n\n  // Add refs to track and clean up listeners\n  const emailTimeoutsRef = useRef({});\n  const contactsListenerRef = useRef(null);\n  const {\n    currentUser\n  } = useContext(AuthContext);\n  const {\n    addExpense\n  } = useContext(ExpenseContext);\n\n  // Load data from Firestore when component mounts or user changes\n  useEffect(() => {\n    if (!currentUser) {\n      setSplitExpenses([]);\n      setContacts([]);\n      setLoading(false);\n      return;\n    }\n    setLoading(true);\n    console.log('Loading split expenses for user:', currentUser.uid);\n\n    // Query Firestore for split expenses\n    const splitExpensesQuery = query(collection(db, 'splitExpenses'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener for split expenses\n    const unsubscribe = onSnapshot(splitExpensesQuery, snapshot => {\n      try {\n        // Process incoming data changes\n        const splitExpensesList = snapshot.docs.map(doc => {\n          const data = doc.data();\n          // Ensure ID is always stored as a string\n          return {\n            id: String(doc.id),\n            ...data,\n            // Ensure participants have string IDs too\n            participants: Array.isArray(data.participants) ? data.participants.map(p => ({\n              ...p,\n              id: String(p.id)\n            })) : data.participants\n          };\n        });\n        console.log('Loaded split expenses:', splitExpensesList.length);\n        setSplitExpenses(splitExpensesList);\n        setLoading(false);\n      } catch (error) {\n        console.error(\"Error processing split expenses data:\", error);\n        setSplitExpenses([]);\n        setLoading(false);\n      }\n    }, error => {\n      console.error(\"Error getting split expenses:\", error.code, error.message);\n      setLoading(false);\n    });\n\n    // Load contacts\n    loadContacts();\n    return () => {\n      unsubscribe();\n      // Clean up contacts listener if it exists\n      if (contactsListenerRef.current) {\n        contactsListenerRef.current();\n      }\n    };\n  }, [currentUser]);\n\n  // Clean up email status timeouts on unmount\n  useEffect(() => {\n    return () => {\n      // Clear all timeouts when component unmounts\n      Object.values(emailTimeoutsRef.current).forEach(timeoutId => {\n        clearTimeout(timeoutId);\n      });\n      emailTimeoutsRef.current = {};\n    };\n  }, []);\n\n  // Function to load contacts from Firestore - with improved error handling\n  const loadContacts = async () => {\n    if (!currentUser) {\n      setContacts([]);\n      return false;\n    }\n    try {\n      console.log('Setting up contacts listener for user:', currentUser.uid);\n      const contactsQuery = query(collection(db, 'contacts'), where('userId', '==', currentUser.uid));\n\n      // Set up real-time listener for contacts\n      const unsubscribe = onSnapshot(contactsQuery, snapshot => {\n        try {\n          const contactsList = snapshot.docs.map(doc => ({\n            id: String(doc.id),\n            // Ensure ID is stored as a string\n            ...doc.data()\n          }));\n          console.log('Loaded contacts:', contactsList.length);\n          setContacts(contactsList);\n        } catch (error) {\n          console.error('Error processing contacts data:', error);\n          setContacts([]);\n        }\n      }, error => {\n        console.error('Error in contacts listener:', error);\n        setContacts([]);\n      });\n\n      // Store the unsubscribe function to clean up on unmount\n      contactsListenerRef.current = unsubscribe;\n      return true;\n    } catch (error) {\n      console.error('Error setting up contacts listener:', error);\n      setContacts([]);\n      return false;\n    }\n  };\n\n  /**\r\n   * Create a new split expense with improved error handling\r\n   * @param {Object} expenseData - Expense data (amount, category, etc.)\r\n   * @param {Array} participants - Array of participants\r\n   * @returns {Object} New split expense or null if failed\r\n   */\n  const createNewSplitExpense = async (expenseData, participants) => {\n    if (!currentUser) {\n      console.error('Cannot create split expense: No authenticated user');\n      return null;\n    }\n    try {\n      console.log('Creating new split expense with:', {\n        expenseDetails: expenseData,\n        participantCount: participants.length\n      });\n\n      // Ensure participants have string IDs and valid data\n      const validatedParticipants = participants.map(p => ({\n        ...p,\n        id: String(p.id || `p_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`),\n        shareAmount: parseFloat(p.shareAmount) || 0,\n        sharePercentage: parseFloat(p.sharePercentage) || 0,\n        status: p.status || 'unpaid'\n      }));\n\n      // Find the creator's participant object to determine their share\n      const creatorParticipant = validatedParticipants.find(p => p.email && currentUser.email && p.email.toLowerCase() === currentUser.email.toLowerCase() || p.name && currentUser.name && p.name === currentUser.name);\n\n      // If creator isn't found in participants, use the first participant as a fallback\n      const userShare = (creatorParticipant === null || creatorParticipant === void 0 ? void 0 : creatorParticipant.shareAmount) || (validatedParticipants.length > 0 ? validatedParticipants[0].shareAmount : 0);\n\n      // First create the base expense with proper split expense attribution\n      const baseExpense = {\n        ...expenseData,\n        // Make sure amount is parsed as a number\n        amount: parseFloat(expenseData.amount),\n        // Mark this as a split expense\n        isSplit: true,\n        // Add the current user's share for proper budget calculations\n        userShare: userShare,\n        // Add the number of participants\n        participantCount: validatedParticipants.length,\n        // Add userId if not already set\n        userId: currentUser.uid,\n        // Add a descriptive note\n        notes: expenseData.notes || `Split with ${validatedParticipants.length} people`,\n        // Add creation date\n        createdAt: new Date().toISOString()\n      };\n      console.log('Creating base expense for split:', baseExpense);\n\n      // Try to add the expense\n      const expenseId = await addExpense(baseExpense);\n      if (!expenseId) {\n        throw new Error('Failed to create base expense');\n      }\n      console.log('Base expense created with ID:', expenseId);\n\n      // Create the split expense object\n      const newSplitExpense = createSplitExpense({\n        ...expenseData,\n        // The addExpense function returns the ID, but we need the full object\n        id: expenseId,\n        userId: currentUser.uid\n      }, validatedParticipants);\n      console.log('Split expense object created:', newSplitExpense);\n\n      // Add to Firestore\n      const splitExpenseData = {\n        ...newSplitExpense,\n        userId: currentUser.uid,\n        createdAt: new Date().toISOString()\n      };\n      const docRef = await addDoc(collection(db, 'splitExpenses'), splitExpenseData);\n      console.log('Split expense added to Firestore with ID:', docRef.id);\n\n      // Add the Firestore document ID\n      const splitExpenseWithId = {\n        ...splitExpenseData,\n        id: String(docRef.id)\n      };\n\n      // Add any new contacts to Firestore\n      const existingContactEmails = contacts.map(c => {\n        var _c$email;\n        return (_c$email = c.email) === null || _c$email === void 0 ? void 0 : _c$email.toLowerCase();\n      }).filter(Boolean);\n      console.log('Checking for new contacts to add...');\n      for (const participant of validatedParticipants) {\n        // Only add contacts with email addresses\n        if (participant.email && !existingContactEmails.includes(participant.email.toLowerCase())) {\n          console.log('Adding new contact:', participant.name);\n          try {\n            // Create a new contact entry\n            const contactData = {\n              name: participant.name,\n              email: participant.email,\n              userId: currentUser.uid,\n              createdAt: new Date().toISOString()\n            };\n            const contactRef = await addDoc(collection(db, 'contacts'), contactData);\n            console.log('New contact added with ID:', contactRef.id);\n\n            // Update local contacts state\n            setContacts(prev => [...prev, {\n              id: String(contactRef.id),\n              ...contactData\n            }]);\n          } catch (contactError) {\n            console.error('Error adding contact:', contactError);\n            // Continue with split expense creation even if contact can't be added\n          }\n        }\n      }\n\n      // Send email notifications to participants (except the creator)\n      const otherParticipants = validatedParticipants.filter(p => p.email && currentUser.email && p.email.toLowerCase() !== currentUser.email.toLowerCase());\n      if (otherParticipants.length > 0) {\n        console.log(`Sending split expense notifications to ${otherParticipants.length} participants`);\n\n        // Create a queue to send emails sequentially to avoid rate limits\n        const sendEmailQueue = async () => {\n          for (let i = 0; i < otherParticipants.length; i++) {\n            const participant = otherParticipants[i];\n            const stringParticipantId = String(participant.id);\n            try {\n              // Track email status\n              setEmailStatus(prev => ({\n                ...prev,\n                [stringParticipantId]: {\n                  sending: true\n                }\n              }));\n\n              // Send the email with minimal parameters\n              const result = await sendSplitExpenseEmail(participant, splitExpenseWithId, currentUser);\n              console.log(`Email result for ${participant.name}:`, result);\n\n              // Update email status\n              setEmailStatus(prev => ({\n                ...prev,\n                [stringParticipantId]: {\n                  sending: false,\n                  sent: result.success,\n                  error: result.success ? null : result.message\n                }\n              }));\n\n              // Wait a bit between emails to avoid rate limiting\n              if (i < otherParticipants.length - 1) {\n                await new Promise(resolve => setTimeout(resolve, 1000));\n              }\n            } catch (error) {\n              console.error(`Failed to send split email to ${participant.name}:`, error);\n\n              // Update email status with error\n              setEmailStatus(prev => ({\n                ...prev,\n                [stringParticipantId]: {\n                  sending: false,\n                  sent: false,\n                  error: error.message || 'Unknown error'\n                }\n              }));\n\n              // Continue with the next participant even if this one fails\n              await new Promise(resolve => setTimeout(resolve, 500));\n            }\n          }\n\n          // Clear email status after all emails have been processed (plus a buffer)\n          const timeoutId = setTimeout(() => {\n            setEmailStatus({});\n          }, 10000);\n\n          // Store timeout ID to clear if component unmounts\n          emailTimeoutsRef.current['all'] = timeoutId;\n        };\n\n        // Start the email queue\n        sendEmailQueue();\n      }\n      return splitExpenseWithId;\n    } catch (error) {\n      console.error('Error creating split expense:', error);\n      return null;\n    }\n  };\n\n  /**\r\n   * Get a split expense by ID\r\n   * @param {string|number} id - Split expense ID\r\n   * @returns {Object} Split expense or null if not found\r\n   */\n  const getSplitExpense = id => {\n    if (!id) return null;\n    // Always convert IDs to strings for comparison\n    const stringId = String(id);\n    const expense = splitExpenses.find(expense => String(expense.id) === stringId);\n    return expense || null;\n  };\n\n  /**\r\n   * Update a participant's payment status\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @param {string} status - New status (paid, unpaid, declined)\r\n   * @param {string} paymentMethod - Method of payment\r\n   * @returns {boolean} Success status\r\n   */\n  const updatePaymentStatus = async (splitExpenseId, participantId, status, paymentMethod) => {\n    if (!currentUser || !splitExpenseId || !participantId) {\n      console.error('Missing required parameters for updatePaymentStatus');\n      return false;\n    }\n    try {\n      // Convert IDs to strings for consistent comparison\n      const stringExpenseId = String(splitExpenseId);\n      const stringParticipantId = String(participantId);\n      console.log(`Updating payment status for participant ${stringParticipantId} to ${status}`);\n\n      // Find the split expense using string comparison\n      const splitExpense = splitExpenses.find(expense => String(expense.id) === stringExpenseId);\n      if (!splitExpense) {\n        console.error(`Split expense with ID ${stringExpenseId} not found`);\n        return false;\n      }\n\n      // Make sure participants array exists\n      if (!Array.isArray(splitExpense.participants)) {\n        console.error('Participants array is missing or invalid');\n        return false;\n      }\n\n      // Check if participant exists (using string comparison)\n      const participantIndex = splitExpense.participants.findIndex(p => String(p.id) === stringParticipantId);\n      if (participantIndex === -1) {\n        console.error(`Participant with ID ${stringParticipantId} not found`);\n        return false;\n      }\n\n      // Create a deep copy of participants to avoid mutation issues\n      const updatedParticipants = JSON.parse(JSON.stringify(splitExpense.participants));\n\n      // Update the participant\n      updatedParticipants[participantIndex] = {\n        ...updatedParticipants[participantIndex],\n        status: status,\n        paymentMethod: paymentMethod || updatedParticipants[participantIndex].paymentMethod,\n        paidDate: status === 'paid' ? new Date().toISOString() : updatedParticipants[participantIndex].paidDate\n      };\n\n      // Recalculate the overall status\n      const updatedStatus = calculateSplitStatus({\n        ...splitExpense,\n        participants: updatedParticipants\n      });\n      console.log(`New split expense status: ${updatedStatus}`);\n\n      // Update in Firestore with explicit error handling\n      const splitExpenseRef = doc(db, 'splitExpenses', stringExpenseId);\n      await updateDoc(splitExpenseRef, {\n        participants: updatedParticipants,\n        status: updatedStatus,\n        updatedAt: new Date().toISOString()\n      });\n      console.log('Payment status updated successfully in Firestore');\n      return true;\n    } catch (error) {\n      console.error('Error updating payment status:', error);\n      console.error('Error details:', error.code, error.message);\n      return false;\n    }\n  };\n\n  /**\r\n   * Add a new contact with improved validation and error handling\r\n   * @param {string} name - Contact name\r\n   * @param {string} email - Contact email\r\n   * @returns {boolean} Success status\r\n   */\n  const addContact = async (name, email) => {\n    if (!currentUser) {\n      console.error('Cannot add contact: No authenticated user');\n      return false;\n    }\n    if (!name || name.trim() === '') {\n      console.error('Contact name is required');\n      return false;\n    }\n    try {\n      console.log(`Adding new contact: ${name} (${email || 'No email'})`);\n\n      // Check if contact with this email already exists (case insensitive)\n      if (email && email.trim() !== '') {\n        const normalizedEmail = email.trim().toLowerCase();\n\n        // First check against local state to avoid unnecessary Firestore query\n        const existingContact = contacts.find(c => c.email && c.email.toLowerCase() === normalizedEmail);\n        if (existingContact) {\n          console.log(`Contact with email ${email} already exists`);\n          return false;\n        }\n\n        // Double-check with Firestore to be sure\n        const existingContactsQuery = query(collection(db, 'contacts'), where('userId', '==', currentUser.uid), where('email', '==', email.trim()));\n        const existingContacts = await getDocs(existingContactsQuery);\n        if (!existingContacts.empty) {\n          console.log(`Contact with email ${email} exists in Firestore but not in local state`);\n          return false;\n        }\n      }\n\n      // Create new contact object\n      const newContactData = {\n        name: name.trim(),\n        email: email ? email.trim() : '',\n        userId: currentUser.uid,\n        createdAt: new Date().toISOString()\n      };\n\n      // Add to Firestore\n      const docRef = await addDoc(collection(db, 'contacts'), newContactData);\n      console.log('Contact added with ID:', docRef.id);\n      const newContact = {\n        ...newContactData,\n        id: String(docRef.id)\n      };\n\n      // Update local state\n      setContacts(prevContacts => [...prevContacts, newContact]);\n      return true;\n    } catch (error) {\n      console.error('Error adding contact:', error);\n      return false;\n    }\n  };\n\n  /**\r\n   * Delete a contact\r\n   * @param {string} contactId - Contact ID\r\n   * @returns {boolean} Success status\r\n   */\n  const deleteContact = async contactId => {\n    if (!currentUser || !contactId) {\n      console.error('Cannot delete contact: Missing user or contact ID');\n      return false;\n    }\n    try {\n      const stringContactId = String(contactId);\n      console.log(`Deleting contact with ID: ${stringContactId}`);\n\n      // Delete from Firestore\n      await deleteDoc(doc(db, 'contacts', stringContactId));\n\n      // Update local state\n      setContacts(prevContacts => prevContacts.filter(contact => String(contact.id) !== stringContactId));\n      return true;\n    } catch (error) {\n      console.error('Error deleting contact:', error);\n      return false;\n    }\n  };\n\n  /**\r\n   * Get all split expenses\r\n   * @returns {Array} Array of split expenses\r\n   */\n  const getAllSplitExpenses = () => {\n    return splitExpenses;\n  };\n\n  /**\r\n   * Get all contacts\r\n   * @returns {Array} Array of contacts\r\n   */\n  const getAllContacts = () => {\n    return contacts;\n  };\n\n  /**\r\n   * Delete a split expense\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @returns {boolean} Success status\r\n   */\n  const deleteSplitExpense = async splitExpenseId => {\n    if (!currentUser || !splitExpenseId) {\n      console.error('Cannot delete split expense: Missing user or split expense ID');\n      return false;\n    }\n    try {\n      const stringExpenseId = String(splitExpenseId);\n      console.log(`Deleting split expense with ID: ${stringExpenseId}`);\n\n      // Delete from Firestore\n      await deleteDoc(doc(db, 'splitExpenses', stringExpenseId));\n      return true;\n    } catch (error) {\n      console.error('Error deleting split expense:', error);\n      return false;\n    }\n  };\n\n  /**\r\n   * Remind a participant to pay\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @returns {boolean} Success status\r\n   */\n  const sendPaymentReminder = async (splitExpenseId, participantId) => {\n    if (!currentUser || !splitExpenseId || !participantId) {\n      console.error('Missing required parameters for sendPaymentReminder');\n      return false;\n    }\n    try {\n      // Convert IDs to strings for consistent comparison\n      const stringExpenseId = String(splitExpenseId);\n      const stringParticipantId = String(participantId);\n      console.log(`Sending payment reminder for participant ${stringParticipantId}`);\n      const splitExpense = getSplitExpense(stringExpenseId);\n      if (!splitExpense) {\n        console.error(`Split expense with ID ${stringExpenseId} not found`);\n        return false;\n      }\n\n      // Find participant using string comparison\n      const participant = splitExpense.participants && splitExpense.participants.find(p => String(p.id) === stringParticipantId);\n      if (!participant) {\n        console.error(`Participant with ID ${stringParticipantId} not found in split expense`);\n        return false;\n      }\n      if (!participant.email) {\n        console.error(`Participant ${stringParticipantId} has no email address`);\n        return false;\n      }\n\n      // Update email status without accidentally overwriting other statuses\n      setEmailStatus(prev => ({\n        ...prev,\n        [stringParticipantId]: {\n          sending: true\n        }\n      }));\n\n      // Create complete email parameters\n      const emailParams = {\n        to_email: participant.email,\n        to_name: participant.name || 'Participant',\n        creator_name: currentUser.name || 'Group member',\n        expense_description: splitExpense.description || 'Split expense',\n        expense_category: splitExpense.category || 'Uncategorized',\n        expense_date: new Date(splitExpense.date || new Date()).toLocaleDateString(),\n        expense_amount: (splitExpense.totalAmount || 0).toFixed(2),\n        share_amount: (participant.shareAmount || 0).toFixed(2),\n        is_reminder: true,\n        reminder_message: `This is a friendly reminder that your payment of $${(participant.shareAmount || 0).toFixed(2)} for \"${splitExpense.description || 'Split expense'}\" is still pending.`,\n        // Essential parameters for EmailJS template\n        name: currentUser.name || 'FinTrack',\n        email: currentUser.email || '',\n        reply_to: currentUser.email || '',\n        subject: `Payment Reminder: ${splitExpense.description || 'Split expense'}`\n      };\n      try {\n        // Send reminder email with explicit error handling\n        const result = await sendSplitExpenseEmail(participant, splitExpense, currentUser, true, emailParams);\n        console.log(`Reminder email result for ${participant.name}:`, result);\n\n        // Update email status with a clean state update\n        setEmailStatus(prev => ({\n          ...prev,\n          [stringParticipantId]: {\n            sending: false,\n            sent: result.success,\n            error: result.success ? null : result.message\n          }\n        }));\n\n        // Log reminder in Firestore\n        if (result.success) {\n          try {\n            const reminderLog = {\n              splitExpenseId: stringExpenseId,\n              participantId: stringParticipantId,\n              timestamp: new Date().toISOString(),\n              userId: currentUser.uid,\n              success: true\n            };\n            await addDoc(collection(db, 'reminderLogs'), reminderLog);\n          } catch (logError) {\n            console.error('Error logging reminder:', logError);\n            // Continue even if logging fails\n          }\n        }\n\n        // Clear status after some time\n        const timeoutId = setTimeout(() => {\n          setEmailStatus(prev => {\n            const newStatus = {\n              ...prev\n            };\n            if (newStatus[stringParticipantId]) {\n              delete newStatus[stringParticipantId];\n            }\n            return newStatus;\n          });\n        }, 10000);\n\n        // Store timeout ID to clear if component unmounts\n        emailTimeoutsRef.current[stringParticipantId] = timeoutId;\n        return true;\n      } catch (error) {\n        console.error(`Failed to send reminder email to ${participant.name}:`, error);\n\n        // Update email status with error\n        setEmailStatus(prev => ({\n          ...prev,\n          [stringParticipantId]: {\n            sending: false,\n            sent: false,\n            error: error.message || 'Failed to send email'\n          }\n        }));\n        return false;\n      }\n    } catch (error) {\n      console.error('Error sending payment reminder:', error);\n\n      // Make sure the sending status is cleared if there's an error\n      if (participantId) {\n        setEmailStatus(prev => ({\n          ...prev,\n          [String(participantId)]: {\n            sending: false,\n            sent: false,\n            error: error.message || 'Unknown error occurred'\n          }\n        }));\n      }\n      return false;\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(SplitExpenseContext.Provider, {\n    value: {\n      loading,\n      createNewSplitExpense,\n      getSplitExpense,\n      updatePaymentStatus,\n      addContact,\n      deleteContact,\n      getAllSplitExpenses,\n      getAllContacts,\n      deleteSplitExpense,\n      sendPaymentReminder,\n      createParticipant,\n      emailStatus\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 773,\n    columnNumber: 5\n  }, this);\n};\n_s(SplitExpenseProvider, \"O5kj2WC0rmrqojeMJE/smM12IgA=\");\n_c = SplitExpenseProvider;\nexport default SplitExpenseProvider;\nvar _c;\n$RefreshReg$(_c, \"SplitExpenseProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","useRef","AuthContext","ExpenseContext","createSplitExpense","createParticipant","updateParticipantStatus","calculateSplitStatus","sendSplitExpenseEmail","db","collection","addDoc","doc","deleteDoc","updateDoc","query","where","getDocs","onSnapshot","getDoc","setDoc","jsxDEV","_jsxDEV","SplitExpenseContext","SplitExpenseProvider","children","_s","splitExpenses","setSplitExpenses","contacts","setContacts","loading","setLoading","emailStatus","setEmailStatus","emailTimeoutsRef","contactsListenerRef","currentUser","addExpense","console","log","uid","splitExpensesQuery","unsubscribe","snapshot","splitExpensesList","docs","map","data","id","String","participants","Array","isArray","p","length","error","code","message","loadContacts","current","Object","values","forEach","timeoutId","clearTimeout","contactsQuery","contactsList","createNewSplitExpense","expenseData","expenseDetails","participantCount","validatedParticipants","Date","now","Math","random","toString","slice","shareAmount","parseFloat","sharePercentage","status","creatorParticipant","find","email","toLowerCase","name","userShare","baseExpense","amount","isSplit","userId","notes","createdAt","toISOString","expenseId","Error","newSplitExpense","splitExpenseData","docRef","splitExpenseWithId","existingContactEmails","c","_c$email","filter","Boolean","participant","includes","contactData","contactRef","prev","contactError","otherParticipants","sendEmailQueue","i","stringParticipantId","sending","result","sent","success","Promise","resolve","setTimeout","getSplitExpense","stringId","expense","updatePaymentStatus","splitExpenseId","participantId","paymentMethod","stringExpenseId","splitExpense","participantIndex","findIndex","updatedParticipants","JSON","parse","stringify","paidDate","updatedStatus","splitExpenseRef","updatedAt","addContact","trim","normalizedEmail","existingContact","existingContactsQuery","existingContacts","empty","newContactData","newContact","prevContacts","deleteContact","contactId","stringContactId","contact","getAllSplitExpenses","getAllContacts","deleteSplitExpense","sendPaymentReminder","emailParams","to_email","to_name","creator_name","expense_description","description","expense_category","category","expense_date","date","toLocaleDateString","expense_amount","totalAmount","toFixed","share_amount","is_reminder","reminder_message","reply_to","subject","reminderLog","timestamp","logError","newStatus","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/tejit/OneDrive/Desktop/expence tracker final/expence-tracker/src/context/SplitExpenseContext.js"],"sourcesContent":["// src/context/SplitExpenseContext.js\r\nimport React, { createContext, useState, useEffect, useContext, useRef } from 'react';\r\nimport { AuthContext } from './AuthContext';\r\nimport { ExpenseContext } from './ExpenseContext';\r\nimport { \r\n  createSplitExpense, \r\n  createParticipant, \r\n  updateParticipantStatus, \r\n  calculateSplitStatus \r\n} from '../models/SplitExpenseModel';\r\nimport { sendSplitExpenseEmail } from '../services/EmailService';\r\n// Add Firebase imports\r\nimport { db } from '../config/firebase';\r\nimport { \r\n  collection, \r\n  addDoc, \r\n  doc, \r\n  deleteDoc, \r\n  updateDoc, \r\n  query, \r\n  where, \r\n  getDocs, \r\n  onSnapshot, \r\n  getDoc,\r\n  setDoc\r\n} from 'firebase/firestore';\r\n\r\nexport const SplitExpenseContext = createContext();\r\n\r\nexport const SplitExpenseProvider = ({ children }) => {\r\n  const [splitExpenses, setSplitExpenses] = useState([]);\r\n  const [contacts, setContacts] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [emailStatus, setEmailStatus] = useState({});\r\n  \r\n  // Add refs to track and clean up listeners\r\n  const emailTimeoutsRef = useRef({});\r\n  const contactsListenerRef = useRef(null);\r\n  \r\n  const { currentUser } = useContext(AuthContext);\r\n  const { addExpense } = useContext(ExpenseContext);\r\n  \r\n  // Load data from Firestore when component mounts or user changes\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setSplitExpenses([]);\r\n      setContacts([]);\r\n      setLoading(false);\r\n      return;\r\n    }\r\n    \r\n    setLoading(true);\r\n    console.log('Loading split expenses for user:', currentUser.uid);\r\n    \r\n    // Query Firestore for split expenses\r\n    const splitExpensesQuery = query(\r\n      collection(db, 'splitExpenses'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener for split expenses\r\n    const unsubscribe = onSnapshot(\r\n      splitExpensesQuery, \r\n      (snapshot) => {\r\n        try {\r\n          // Process incoming data changes\r\n          const splitExpensesList = snapshot.docs.map(doc => {\r\n            const data = doc.data();\r\n            // Ensure ID is always stored as a string\r\n            return {\r\n              id: String(doc.id),\r\n              ...data,\r\n              // Ensure participants have string IDs too\r\n              participants: Array.isArray(data.participants) \r\n                ? data.participants.map(p => ({...p, id: String(p.id)})) \r\n                : data.participants\r\n            };\r\n          });\r\n          \r\n          console.log('Loaded split expenses:', splitExpensesList.length);\r\n          setSplitExpenses(splitExpensesList);\r\n          setLoading(false);\r\n        } catch (error) {\r\n          console.error(\"Error processing split expenses data:\", error);\r\n          setSplitExpenses([]);\r\n          setLoading(false);\r\n        }\r\n      }, \r\n      (error) => {\r\n        console.error(\"Error getting split expenses:\", error.code, error.message);\r\n        setLoading(false);\r\n      }\r\n    );\r\n    \r\n    // Load contacts\r\n    loadContacts();\r\n    \r\n    return () => {\r\n      unsubscribe();\r\n      // Clean up contacts listener if it exists\r\n      if (contactsListenerRef.current) {\r\n        contactsListenerRef.current();\r\n      }\r\n    };\r\n  }, [currentUser]);\r\n  \r\n  // Clean up email status timeouts on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      // Clear all timeouts when component unmounts\r\n      Object.values(emailTimeoutsRef.current).forEach(timeoutId => {\r\n        clearTimeout(timeoutId);\r\n      });\r\n      emailTimeoutsRef.current = {};\r\n    };\r\n  }, []);\r\n  \r\n  // Function to load contacts from Firestore - with improved error handling\r\n  const loadContacts = async () => {\r\n    if (!currentUser) {\r\n      setContacts([]);\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      console.log('Setting up contacts listener for user:', currentUser.uid);\r\n      \r\n      const contactsQuery = query(\r\n        collection(db, 'contacts'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      // Set up real-time listener for contacts\r\n      const unsubscribe = onSnapshot(\r\n        contactsQuery,\r\n        (snapshot) => {\r\n          try {\r\n            const contactsList = snapshot.docs.map(doc => ({\r\n              id: String(doc.id),  // Ensure ID is stored as a string\r\n              ...doc.data()\r\n            }));\r\n            \r\n            console.log('Loaded contacts:', contactsList.length);\r\n            setContacts(contactsList);\r\n          } catch (error) {\r\n            console.error('Error processing contacts data:', error);\r\n            setContacts([]);\r\n          }\r\n        },\r\n        (error) => {\r\n          console.error('Error in contacts listener:', error);\r\n          setContacts([]);\r\n        }\r\n      );\r\n      \r\n      // Store the unsubscribe function to clean up on unmount\r\n      contactsListenerRef.current = unsubscribe;\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error setting up contacts listener:', error);\r\n      setContacts([]);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Create a new split expense with improved error handling\r\n   * @param {Object} expenseData - Expense data (amount, category, etc.)\r\n   * @param {Array} participants - Array of participants\r\n   * @returns {Object} New split expense or null if failed\r\n   */\r\n  const createNewSplitExpense = async (expenseData, participants) => {\r\n    if (!currentUser) {\r\n      console.error('Cannot create split expense: No authenticated user');\r\n      return null;\r\n    }\r\n    \r\n    try {\r\n      console.log('Creating new split expense with:', { \r\n        expenseDetails: expenseData,\r\n        participantCount: participants.length\r\n      });\r\n      \r\n      // Ensure participants have string IDs and valid data\r\n      const validatedParticipants = participants.map(p => ({\r\n        ...p,\r\n        id: String(p.id || `p_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`),\r\n        shareAmount: parseFloat(p.shareAmount) || 0,\r\n        sharePercentage: parseFloat(p.sharePercentage) || 0,\r\n        status: p.status || 'unpaid'\r\n      }));\r\n      \r\n      // Find the creator's participant object to determine their share\r\n      const creatorParticipant = validatedParticipants.find(p => \r\n        (p.email && currentUser.email && p.email.toLowerCase() === currentUser.email.toLowerCase()) || \r\n        (p.name && currentUser.name && p.name === currentUser.name)\r\n      );\r\n      \r\n      // If creator isn't found in participants, use the first participant as a fallback\r\n      const userShare = creatorParticipant?.shareAmount || \r\n                       (validatedParticipants.length > 0 ? validatedParticipants[0].shareAmount : 0);\r\n      \r\n      // First create the base expense with proper split expense attribution\r\n      const baseExpense = {\r\n        ...expenseData,\r\n        // Make sure amount is parsed as a number\r\n        amount: parseFloat(expenseData.amount),\r\n        // Mark this as a split expense\r\n        isSplit: true,\r\n        // Add the current user's share for proper budget calculations\r\n        userShare: userShare,\r\n        // Add the number of participants\r\n        participantCount: validatedParticipants.length,\r\n        // Add userId if not already set\r\n        userId: currentUser.uid,\r\n        // Add a descriptive note\r\n        notes: expenseData.notes || `Split with ${validatedParticipants.length} people`,\r\n        // Add creation date\r\n        createdAt: new Date().toISOString()\r\n      };\r\n      \r\n      console.log('Creating base expense for split:', baseExpense);\r\n      \r\n      // Try to add the expense\r\n      const expenseId = await addExpense(baseExpense);\r\n      \r\n      if (!expenseId) {\r\n        throw new Error('Failed to create base expense');\r\n      }\r\n      \r\n      console.log('Base expense created with ID:', expenseId);\r\n      \r\n      // Create the split expense object\r\n      const newSplitExpense = createSplitExpense(\r\n        {\r\n          ...expenseData,\r\n          // The addExpense function returns the ID, but we need the full object\r\n          id: expenseId,\r\n          userId: currentUser.uid\r\n        },\r\n        validatedParticipants\r\n      );\r\n      \r\n      console.log('Split expense object created:', newSplitExpense);\r\n      \r\n      // Add to Firestore\r\n      const splitExpenseData = {\r\n        ...newSplitExpense,\r\n        userId: currentUser.uid,\r\n        createdAt: new Date().toISOString()\r\n      };\r\n      \r\n      const docRef = await addDoc(collection(db, 'splitExpenses'), splitExpenseData);\r\n      console.log('Split expense added to Firestore with ID:', docRef.id);\r\n      \r\n      // Add the Firestore document ID\r\n      const splitExpenseWithId = {\r\n        ...splitExpenseData,\r\n        id: String(docRef.id)\r\n      };\r\n      \r\n      // Add any new contacts to Firestore\r\n      const existingContactEmails = contacts\r\n        .map(c => c.email?.toLowerCase())\r\n        .filter(Boolean);\r\n      \r\n      console.log('Checking for new contacts to add...');\r\n      \r\n      for (const participant of validatedParticipants) {\r\n        // Only add contacts with email addresses\r\n        if (participant.email && \r\n            !existingContactEmails.includes(participant.email.toLowerCase())) {\r\n          \r\n          console.log('Adding new contact:', participant.name);\r\n          \r\n          try {\r\n            // Create a new contact entry\r\n            const contactData = {\r\n              name: participant.name,\r\n              email: participant.email,\r\n              userId: currentUser.uid,\r\n              createdAt: new Date().toISOString()\r\n            };\r\n            \r\n            const contactRef = await addDoc(collection(db, 'contacts'), contactData);\r\n            console.log('New contact added with ID:', contactRef.id);\r\n            \r\n            // Update local contacts state\r\n            setContacts(prev => [...prev, {\r\n              id: String(contactRef.id),\r\n              ...contactData\r\n            }]);\r\n          } catch (contactError) {\r\n            console.error('Error adding contact:', contactError);\r\n            // Continue with split expense creation even if contact can't be added\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Send email notifications to participants (except the creator)\r\n      const otherParticipants = validatedParticipants.filter(p => \r\n        p.email && currentUser.email && p.email.toLowerCase() !== currentUser.email.toLowerCase()\r\n      );\r\n      \r\n      if (otherParticipants.length > 0) {\r\n        console.log(`Sending split expense notifications to ${otherParticipants.length} participants`);\r\n        \r\n        // Create a queue to send emails sequentially to avoid rate limits\r\n        const sendEmailQueue = async () => {\r\n          for (let i = 0; i < otherParticipants.length; i++) {\r\n            const participant = otherParticipants[i];\r\n            const stringParticipantId = String(participant.id);\r\n            \r\n            try {\r\n              // Track email status\r\n              setEmailStatus(prev => ({\r\n                ...prev,\r\n                [stringParticipantId]: { sending: true }\r\n              }));\r\n              \r\n              // Send the email with minimal parameters\r\n              const result = await sendSplitExpenseEmail(\r\n                participant, \r\n                splitExpenseWithId, \r\n                currentUser\r\n              );\r\n              \r\n              console.log(`Email result for ${participant.name}:`, result);\r\n              \r\n              // Update email status\r\n              setEmailStatus(prev => ({\r\n                ...prev,\r\n                [stringParticipantId]: { \r\n                  sending: false,\r\n                  sent: result.success, \r\n                  error: result.success ? null : result.message \r\n                }\r\n              }));\r\n              \r\n              // Wait a bit between emails to avoid rate limiting\r\n              if (i < otherParticipants.length - 1) {\r\n                await new Promise(resolve => setTimeout(resolve, 1000));\r\n              }\r\n            } catch (error) {\r\n              console.error(`Failed to send split email to ${participant.name}:`, error);\r\n              \r\n              // Update email status with error\r\n              setEmailStatus(prev => ({\r\n                ...prev,\r\n                [stringParticipantId]: { \r\n                  sending: false,\r\n                  sent: false, \r\n                  error: error.message || 'Unknown error' \r\n                }\r\n              }));\r\n              \r\n              // Continue with the next participant even if this one fails\r\n              await new Promise(resolve => setTimeout(resolve, 500));\r\n            }\r\n          }\r\n          \r\n          // Clear email status after all emails have been processed (plus a buffer)\r\n          const timeoutId = setTimeout(() => {\r\n            setEmailStatus({});\r\n          }, 10000);\r\n          \r\n          // Store timeout ID to clear if component unmounts\r\n          emailTimeoutsRef.current['all'] = timeoutId;\r\n        };\r\n        \r\n        // Start the email queue\r\n        sendEmailQueue();\r\n      }\r\n      \r\n      return splitExpenseWithId;\r\n    } catch (error) {\r\n      console.error('Error creating split expense:', error);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Get a split expense by ID\r\n   * @param {string|number} id - Split expense ID\r\n   * @returns {Object} Split expense or null if not found\r\n   */\r\n  const getSplitExpense = (id) => {\r\n    if (!id) return null;\r\n    // Always convert IDs to strings for comparison\r\n    const stringId = String(id);\r\n    const expense = splitExpenses.find(expense => String(expense.id) === stringId);\r\n    return expense || null;\r\n  };\r\n  \r\n  /**\r\n   * Update a participant's payment status\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @param {string} status - New status (paid, unpaid, declined)\r\n   * @param {string} paymentMethod - Method of payment\r\n   * @returns {boolean} Success status\r\n   */\r\n  const updatePaymentStatus = async (splitExpenseId, participantId, status, paymentMethod) => {\r\n    if (!currentUser || !splitExpenseId || !participantId) {\r\n      console.error('Missing required parameters for updatePaymentStatus');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      // Convert IDs to strings for consistent comparison\r\n      const stringExpenseId = String(splitExpenseId);\r\n      const stringParticipantId = String(participantId);\r\n      \r\n      console.log(`Updating payment status for participant ${stringParticipantId} to ${status}`);\r\n      \r\n      // Find the split expense using string comparison\r\n      const splitExpense = splitExpenses.find(expense => String(expense.id) === stringExpenseId);\r\n      \r\n      if (!splitExpense) {\r\n        console.error(`Split expense with ID ${stringExpenseId} not found`);\r\n        return false;\r\n      }\r\n      \r\n      // Make sure participants array exists\r\n      if (!Array.isArray(splitExpense.participants)) {\r\n        console.error('Participants array is missing or invalid');\r\n        return false;\r\n      }\r\n      \r\n      // Check if participant exists (using string comparison)\r\n      const participantIndex = splitExpense.participants.findIndex(p => String(p.id) === stringParticipantId);\r\n      if (participantIndex === -1) {\r\n        console.error(`Participant with ID ${stringParticipantId} not found`);\r\n        return false;\r\n      }\r\n      \r\n      // Create a deep copy of participants to avoid mutation issues\r\n      const updatedParticipants = JSON.parse(JSON.stringify(splitExpense.participants));\r\n      \r\n      // Update the participant\r\n      updatedParticipants[participantIndex] = {\r\n        ...updatedParticipants[participantIndex],\r\n        status: status,\r\n        paymentMethod: paymentMethod || updatedParticipants[participantIndex].paymentMethod,\r\n        paidDate: status === 'paid' ? new Date().toISOString() : updatedParticipants[participantIndex].paidDate\r\n      };\r\n      \r\n      // Recalculate the overall status\r\n      const updatedStatus = calculateSplitStatus({\r\n        ...splitExpense,\r\n        participants: updatedParticipants\r\n      });\r\n      \r\n      console.log(`New split expense status: ${updatedStatus}`);\r\n      \r\n      // Update in Firestore with explicit error handling\r\n      const splitExpenseRef = doc(db, 'splitExpenses', stringExpenseId);\r\n      \r\n      await updateDoc(splitExpenseRef, {\r\n        participants: updatedParticipants,\r\n        status: updatedStatus,\r\n        updatedAt: new Date().toISOString()\r\n      });\r\n      \r\n      console.log('Payment status updated successfully in Firestore');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating payment status:', error);\r\n      console.error('Error details:', error.code, error.message);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Add a new contact with improved validation and error handling\r\n   * @param {string} name - Contact name\r\n   * @param {string} email - Contact email\r\n   * @returns {boolean} Success status\r\n   */\r\n  const addContact = async (name, email) => {\r\n    if (!currentUser) {\r\n      console.error('Cannot add contact: No authenticated user');\r\n      return false;\r\n    }\r\n    \r\n    if (!name || name.trim() === '') {\r\n      console.error('Contact name is required');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      console.log(`Adding new contact: ${name} (${email || 'No email'})`);\r\n      \r\n      // Check if contact with this email already exists (case insensitive)\r\n      if (email && email.trim() !== '') {\r\n        const normalizedEmail = email.trim().toLowerCase();\r\n        \r\n        // First check against local state to avoid unnecessary Firestore query\r\n        const existingContact = contacts.find(c => \r\n          c.email && c.email.toLowerCase() === normalizedEmail\r\n        );\r\n        \r\n        if (existingContact) {\r\n          console.log(`Contact with email ${email} already exists`);\r\n          return false;\r\n        }\r\n        \r\n        // Double-check with Firestore to be sure\r\n        const existingContactsQuery = query(\r\n          collection(db, 'contacts'),\r\n          where('userId', '==', currentUser.uid),\r\n          where('email', '==', email.trim())\r\n        );\r\n        \r\n        const existingContacts = await getDocs(existingContactsQuery);\r\n        if (!existingContacts.empty) {\r\n          console.log(`Contact with email ${email} exists in Firestore but not in local state`);\r\n          return false;\r\n        }\r\n      }\r\n      \r\n      // Create new contact object\r\n      const newContactData = {\r\n        name: name.trim(),\r\n        email: email ? email.trim() : '',\r\n        userId: currentUser.uid,\r\n        createdAt: new Date().toISOString()\r\n      };\r\n      \r\n      // Add to Firestore\r\n      const docRef = await addDoc(collection(db, 'contacts'), newContactData);\r\n      console.log('Contact added with ID:', docRef.id);\r\n      \r\n      const newContact = {\r\n        ...newContactData,\r\n        id: String(docRef.id)\r\n      };\r\n      \r\n      // Update local state\r\n      setContacts(prevContacts => [...prevContacts, newContact]);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error adding contact:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Delete a contact\r\n   * @param {string} contactId - Contact ID\r\n   * @returns {boolean} Success status\r\n   */\r\n  const deleteContact = async (contactId) => {\r\n    if (!currentUser || !contactId) {\r\n      console.error('Cannot delete contact: Missing user or contact ID');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      const stringContactId = String(contactId);\r\n      console.log(`Deleting contact with ID: ${stringContactId}`);\r\n      \r\n      // Delete from Firestore\r\n      await deleteDoc(doc(db, 'contacts', stringContactId));\r\n      \r\n      // Update local state\r\n      setContacts(prevContacts => prevContacts.filter(contact => String(contact.id) !== stringContactId));\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting contact:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Get all split expenses\r\n   * @returns {Array} Array of split expenses\r\n   */\r\n  const getAllSplitExpenses = () => {\r\n    return splitExpenses;\r\n  };\r\n  \r\n  /**\r\n   * Get all contacts\r\n   * @returns {Array} Array of contacts\r\n   */\r\n  const getAllContacts = () => {\r\n    return contacts;\r\n  };\r\n  \r\n  /**\r\n   * Delete a split expense\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @returns {boolean} Success status\r\n   */\r\n  const deleteSplitExpense = async (splitExpenseId) => {\r\n    if (!currentUser || !splitExpenseId) {\r\n      console.error('Cannot delete split expense: Missing user or split expense ID');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      const stringExpenseId = String(splitExpenseId);\r\n      console.log(`Deleting split expense with ID: ${stringExpenseId}`);\r\n      \r\n      // Delete from Firestore\r\n      await deleteDoc(doc(db, 'splitExpenses', stringExpenseId));\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting split expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Remind a participant to pay\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @returns {boolean} Success status\r\n   */\r\n  const sendPaymentReminder = async (splitExpenseId, participantId) => {\r\n    if (!currentUser || !splitExpenseId || !participantId) {\r\n      console.error('Missing required parameters for sendPaymentReminder');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      // Convert IDs to strings for consistent comparison\r\n      const stringExpenseId = String(splitExpenseId);\r\n      const stringParticipantId = String(participantId);\r\n      \r\n      console.log(`Sending payment reminder for participant ${stringParticipantId}`);\r\n      \r\n      const splitExpense = getSplitExpense(stringExpenseId);\r\n      if (!splitExpense) {\r\n        console.error(`Split expense with ID ${stringExpenseId} not found`);\r\n        return false;\r\n      }\r\n      \r\n      // Find participant using string comparison\r\n      const participant = splitExpense.participants && \r\n        splitExpense.participants.find(p => String(p.id) === stringParticipantId);\r\n        \r\n      if (!participant) {\r\n        console.error(`Participant with ID ${stringParticipantId} not found in split expense`);\r\n        return false;\r\n      }\r\n      \r\n      if (!participant.email) {\r\n        console.error(`Participant ${stringParticipantId} has no email address`);\r\n        return false;\r\n      }\r\n      \r\n      // Update email status without accidentally overwriting other statuses\r\n      setEmailStatus(prev => ({\r\n        ...prev,\r\n        [stringParticipantId]: { sending: true }\r\n      }));\r\n      \r\n      // Create complete email parameters\r\n      const emailParams = {\r\n        to_email: participant.email,\r\n        to_name: participant.name || 'Participant',\r\n        creator_name: currentUser.name || 'Group member',\r\n        expense_description: splitExpense.description || 'Split expense',\r\n        expense_category: splitExpense.category || 'Uncategorized',\r\n        expense_date: new Date(splitExpense.date || new Date()).toLocaleDateString(),\r\n        expense_amount: (splitExpense.totalAmount || 0).toFixed(2),\r\n        share_amount: (participant.shareAmount || 0).toFixed(2),\r\n        is_reminder: true,\r\n        reminder_message: `This is a friendly reminder that your payment of $${(participant.shareAmount || 0).toFixed(2)} for \"${splitExpense.description || 'Split expense'}\" is still pending.`,\r\n        // Essential parameters for EmailJS template\r\n        name: currentUser.name || 'FinTrack',\r\n        email: currentUser.email || '',\r\n        reply_to: currentUser.email || '',\r\n        subject: `Payment Reminder: ${splitExpense.description || 'Split expense'}`\r\n      };\r\n      \r\n      try {\r\n        // Send reminder email with explicit error handling\r\n        const result = await sendSplitExpenseEmail(\r\n          participant, \r\n          splitExpense, \r\n          currentUser, \r\n          true, \r\n          emailParams\r\n        );\r\n        \r\n        console.log(`Reminder email result for ${participant.name}:`, result);\r\n        \r\n        // Update email status with a clean state update\r\n        setEmailStatus(prev => ({\r\n          ...prev,\r\n          [stringParticipantId]: { \r\n            sending: false,\r\n            sent: result.success, \r\n            error: result.success ? null : result.message \r\n          }\r\n        }));\r\n        \r\n        // Log reminder in Firestore\r\n        if (result.success) {\r\n          try {\r\n            const reminderLog = {\r\n              splitExpenseId: stringExpenseId,\r\n              participantId: stringParticipantId,\r\n              timestamp: new Date().toISOString(),\r\n              userId: currentUser.uid,\r\n              success: true\r\n            };\r\n            \r\n            await addDoc(collection(db, 'reminderLogs'), reminderLog);\r\n          } catch (logError) {\r\n            console.error('Error logging reminder:', logError);\r\n            // Continue even if logging fails\r\n          }\r\n        }\r\n        \r\n        // Clear status after some time\r\n        const timeoutId = setTimeout(() => {\r\n          setEmailStatus(prev => {\r\n            const newStatus = { ...prev };\r\n            if (newStatus[stringParticipantId]) {\r\n              delete newStatus[stringParticipantId];\r\n            }\r\n            return newStatus;\r\n          });\r\n        }, 10000);\r\n        \r\n        // Store timeout ID to clear if component unmounts\r\n        emailTimeoutsRef.current[stringParticipantId] = timeoutId;\r\n        \r\n        return true;\r\n      } catch (error) {\r\n        console.error(`Failed to send reminder email to ${participant.name}:`, error);\r\n        \r\n        // Update email status with error\r\n        setEmailStatus(prev => ({\r\n          ...prev,\r\n          [stringParticipantId]: { \r\n            sending: false,\r\n            sent: false, \r\n            error: error.message || 'Failed to send email' \r\n          }\r\n        }));\r\n        \r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error sending payment reminder:', error);\r\n      \r\n      // Make sure the sending status is cleared if there's an error\r\n      if (participantId) {\r\n        setEmailStatus(prev => ({\r\n          ...prev,\r\n          [String(participantId)]: { \r\n            sending: false,\r\n            sent: false, \r\n            error: error.message || 'Unknown error occurred' \r\n          }\r\n        }));\r\n      }\r\n      \r\n      return false;\r\n    }\r\n  };\r\n  \r\n  return (\r\n    <SplitExpenseContext.Provider\r\n      value={{\r\n        loading,\r\n        createNewSplitExpense,\r\n        getSplitExpense,\r\n        updatePaymentStatus,\r\n        addContact,\r\n        deleteContact,\r\n        getAllSplitExpenses,\r\n        getAllContacts,\r\n        deleteSplitExpense,\r\n        sendPaymentReminder,\r\n        createParticipant,\r\n        emailStatus\r\n      }}\r\n    >\r\n      {children}\r\n    </SplitExpenseContext.Provider>\r\n  );\r\n};\r\n\r\nexport default SplitExpenseProvider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}