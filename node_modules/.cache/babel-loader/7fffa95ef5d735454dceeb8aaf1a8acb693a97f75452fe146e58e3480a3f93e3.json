{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\tejit\\\\OneDrive\\\\Desktop\\\\expence tracker final\\\\expence-tracker\\\\src\\\\context\\\\SplitExpenseContext.js\",\n  _s = $RefreshSig$();\n// src/context/SplitExpenseContext.js\nimport React, { createContext, useState, useEffect, useContext } from 'react';\nimport { AuthContext } from './AuthContext';\nimport { ExpenseContext } from './ExpenseContext';\nimport { createSplitExpense, createParticipant, updateParticipantStatus, calculateSplitStatus } from '../models/SplitExpenseModel';\nimport { sendSplitExpenseEmail } from '../services/EmailService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const SplitExpenseContext = /*#__PURE__*/createContext();\nexport const SplitExpenseProvider = ({\n  children\n}) => {\n  _s();\n  const [splitExpenses, setSplitExpenses] = useState([]);\n  const [contacts, setContacts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [emailStatus, setEmailStatus] = useState({});\n  const {\n    currentUser\n  } = useContext(AuthContext);\n  const {\n    addExpense\n  } = useContext(ExpenseContext);\n\n  // Generate unique storage keys for current user\n  const getUserStorageKey = key => {\n    if (!currentUser) return key;\n    return `${key}_${currentUser.id}`;\n  };\n\n  // Load data from localStorage when component mounts or user changes\n  useEffect(() => {\n    if (currentUser) {\n      try {\n        // Load split expenses\n        const savedSplitExpenses = JSON.parse(localStorage.getItem(getUserStorageKey('splitExpenses'))) || [];\n        setSplitExpenses(Array.isArray(savedSplitExpenses) ? savedSplitExpenses : []);\n\n        // Load contacts\n        const savedContacts = JSON.parse(localStorage.getItem(getUserStorageKey('splitContacts'))) || [];\n        setContacts(Array.isArray(savedContacts) ? savedContacts : []);\n      } catch (error) {\n        console.error('Error loading split expense data:', error);\n        setSplitExpenses([]);\n        setContacts([]);\n      } finally {\n        setLoading(false);\n      }\n    } else {\n      setSplitExpenses([]);\n      setContacts([]);\n      setLoading(false);\n    }\n  }, [currentUser]);\n\n  // Save split expenses to localStorage whenever they change\n  useEffect(() => {\n    if (currentUser && !loading) {\n      localStorage.setItem(getUserStorageKey('splitExpenses'), JSON.stringify(splitExpenses));\n    }\n  }, [splitExpenses, currentUser, loading]);\n\n  // Save contacts to localStorage whenever they change\n  useEffect(() => {\n    if (currentUser && !loading) {\n      localStorage.setItem(getUserStorageKey('splitContacts'), JSON.stringify(contacts));\n    }\n  }, [contacts, currentUser, loading]);\n\n  /**\r\n   * Create a new split expense\r\n   * @param {Object} expenseData - Expense data (amount, category, etc.)\r\n   * @param {Array} participants - Array of participants\r\n   * @returns {Object} New split expense or null if failed\r\n   */\n  const createNewSplitExpense = (expenseData, participants) => {\n    if (!currentUser) return null;\n    try {\n      // First create the base expense\n      const expenseResult = addExpense({\n        ...expenseData,\n        // Mark this as a split expense\n        isSplit: true,\n        notes: expenseData.notes || `Split with ${participants.length} people`\n      });\n      if (!expenseResult) {\n        throw new Error('Failed to create base expense');\n      }\n\n      // Create the split expense object\n      const newSplitExpense = createSplitExpense({\n        ...expenseData,\n        // The addExpense function returns the ID, but we need the full object\n        id: expenseResult\n      }, participants);\n\n      // Add to state\n      setSplitExpenses(prev => [...prev, newSplitExpense]);\n\n      // Add any new contacts to the contacts list\n      const existingContactEmails = contacts.map(c => c.email).filter(Boolean);\n      const newContacts = participants.filter(p => p.email && !existingContactEmails.includes(p.email)).map(p => ({\n        id: p.id,\n        name: p.name,\n        email: p.email\n      }));\n      if (newContacts.length > 0) {\n        setContacts(prev => [...prev, ...newContacts]);\n      }\n\n      // Send email notifications to participants (except the creator)\n      const otherParticipants = participants.filter(p => p.email && p.email !== currentUser.email);\n      if (otherParticipants.length > 0) {\n        console.log(`Sending split expense notifications to ${otherParticipants.length} participants`);\n\n        // Create a queue to send emails sequentially to avoid rate limits\n        const sendEmailQueue = async () => {\n          for (let i = 0; i < otherParticipants.length; i++) {\n            const participant = otherParticipants[i];\n            try {\n              // Track email status\n              setEmailStatus(prev => ({\n                ...prev,\n                [participant.id]: {\n                  sending: true\n                }\n              }));\n\n              // Create complete email parameters\n              const emailParams = {\n                to_email: participant.email,\n                to_name: participant.name || 'Participant',\n                creator_name: currentUser.name || 'Group member',\n                expense_description: newSplitExpense.description || 'Split expense',\n                expense_category: newSplitExpense.category || 'Uncategorized',\n                expense_date: new Date(newSplitExpense.date).toLocaleDateString(),\n                expense_amount: newSplitExpense.totalAmount.toFixed(2),\n                share_amount: participant.shareAmount.toFixed(2),\n                is_reminder: false,\n                reminder_message: '',\n                // Essential parameters for EmailJS template\n                name: currentUser.name || 'FinTrack',\n                email: currentUser.email || '',\n                reply_to: currentUser.email || '',\n                subject: `Split expense: ${newSplitExpense.description || 'New expense'}`\n              };\n\n              // Send the email\n              const result = await sendSplitExpenseEmail(participant, newSplitExpense, currentUser, false, emailParams);\n              console.log(`Email result for ${participant.name}:`, result);\n\n              // Update email status\n              setEmailStatus(prev => ({\n                ...prev,\n                [participant.id]: {\n                  sent: result.success,\n                  error: result.success ? null : result.message\n                }\n              }));\n\n              // Wait a bit between emails to avoid rate limiting\n              if (i < otherParticipants.length - 1) {\n                await new Promise(resolve => setTimeout(resolve, 1000));\n              }\n            } catch (error) {\n              console.error(`Failed to send split email to ${participant.name}:`, error);\n\n              // Update email status with error\n              setEmailStatus(prev => ({\n                ...prev,\n                [participant.id]: {\n                  sent: false,\n                  error: error.message || 'Unknown error'\n                }\n              }));\n\n              // Continue with the next participant even if this one fails\n              await new Promise(resolve => setTimeout(resolve, 500));\n            }\n          }\n\n          // Clear email status after all emails have been processed (plus a buffer)\n          setTimeout(() => {\n            setEmailStatus({});\n          }, 10000);\n        };\n\n        // Start the email queue\n        sendEmailQueue();\n      }\n      return newSplitExpense;\n    } catch (error) {\n      console.error('Error creating split expense:', error);\n      return null;\n    }\n  };\n\n  /**\r\n   * Get a split expense by ID\r\n   * @param {string|number} id - Split expense ID\r\n   * @returns {Object} Split expense or null if not found\r\n   */\n  const getSplitExpense = id => {\n    return splitExpenses.find(expense => expense.id === id) || null;\n  };\n\n  /**\r\n   * Update a participant's payment status\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @param {string} status - New status (paid, unpaid, declined)\r\n   * @param {string} paymentMethod - Method of payment\r\n   * @returns {boolean} Success status\r\n   */\n  const updatePaymentStatus = (splitExpenseId, participantId, status, paymentMethod) => {\n    try {\n      // Find the split expense\n      const updatedSplitExpenses = splitExpenses.map(splitExpense => {\n        if (splitExpense.id !== splitExpenseId) return splitExpense;\n\n        // Update the participant\n        const updatedParticipants = splitExpense.participants.map(participant => {\n          if (participant.id !== participantId) return participant;\n          return updateParticipantStatus(participant, status, paymentMethod);\n        });\n\n        // Recalculate the overall status\n        const updatedSplitExpense = {\n          ...splitExpense,\n          participants: updatedParticipants,\n          status: calculateSplitStatus({\n            ...splitExpense,\n            participants: updatedParticipants\n          })\n        };\n        return updatedSplitExpense;\n      });\n      setSplitExpenses(updatedSplitExpenses);\n      return true;\n    } catch (error) {\n      console.error('Error updating payment status:', error);\n      return false;\n    }\n  };\n\n  /**\r\n   * Add a new contact\r\n   * @param {string} name - Contact name\r\n   * @param {string} email - Contact email\r\n   * @returns {Object} New contact or null if failed\r\n   */\n  const addContact = (name, email) => {\n    if (!name.trim()) return null;\n    try {\n      // Check if contact already exists\n      if (contacts.some(c => c.email === email)) {\n        return null;\n      }\n      const newContact = {\n        id: `c_${Date.now()}`,\n        name: name.trim(),\n        email: (email === null || email === void 0 ? void 0 : email.trim()) || ''\n      };\n      setContacts(prev => [...prev, newContact]);\n      return newContact;\n    } catch (error) {\n      console.error('Error adding contact:', error);\n      return null;\n    }\n  };\n\n  /**\r\n   * Delete a contact\r\n   * @param {string} contactId - Contact ID\r\n   * @returns {boolean} Success status\r\n   */\n  const deleteContact = contactId => {\n    try {\n      setContacts(prev => prev.filter(contact => contact.id !== contactId));\n      return true;\n    } catch (error) {\n      console.error('Error deleting contact:', error);\n      return false;\n    }\n  };\n\n  /**\r\n   * Get all split expenses\r\n   * @returns {Array} Array of split expenses\r\n   */\n  const getAllSplitExpenses = () => {\n    return splitExpenses;\n  };\n\n  /**\r\n   * Get all contacts\r\n   * @returns {Array} Array of contacts\r\n   */\n  const getAllContacts = () => {\n    return contacts;\n  };\n\n  /**\r\n   * Delete a split expense\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @returns {boolean} Success status\r\n   */\n  const deleteSplitExpense = splitExpenseId => {\n    try {\n      // Remove from state\n      setSplitExpenses(prev => prev.filter(expense => expense.id !== splitExpenseId));\n      return true;\n    } catch (error) {\n      console.error('Error deleting split expense:', error);\n      return false;\n    }\n  };\n\n  /**\r\n   * Remind a participant to pay\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @returns {boolean} Success status\r\n   */\n  const sendPaymentReminder = async (splitExpenseId, participantId) => {\n    try {\n      const splitExpense = getSplitExpense(splitExpenseId);\n      if (!splitExpense) return false;\n      const participant = splitExpense.participants.find(p => p.id === participantId);\n      if (!participant || !participant.email) return false;\n\n      // Set status to sending\n      setEmailStatus(prev => ({\n        ...prev,\n        [participantId]: {\n          sending: true\n        }\n      }));\n\n      // Create complete email parameters\n      const emailParams = {\n        to_email: participant.email,\n        to_name: participant.name || 'Participant',\n        creator_name: currentUser.name || 'Group member',\n        expense_description: splitExpense.description || 'Split expense',\n        expense_category: splitExpense.category || 'Uncategorized',\n        expense_date: new Date(splitExpense.date).toLocaleDateString(),\n        expense_amount: splitExpense.totalAmount.toFixed(2),\n        share_amount: participant.shareAmount.toFixed(2),\n        is_reminder: true,\n        reminder_message: `This is a friendly reminder that your payment of $${participant.shareAmount.toFixed(2)} for \"${splitExpense.description}\" is still pending.`,\n        // Essential parameters for EmailJS template\n        name: currentUser.name || 'FinTrack',\n        email: currentUser.email || '',\n        reply_to: currentUser.email || '',\n        subject: `Payment Reminder: ${splitExpense.description || 'Split expense'}`\n      };\n      try {\n        // Send reminder email with explicit error handling\n        const result = await sendSplitExpenseEmail(participant, splitExpense, currentUser, true, emailParams);\n        console.log(`Reminder email result for ${participant.name}:`, result);\n\n        // Update email status\n        setEmailStatus(prev => ({\n          ...prev,\n          [participantId]: {\n            sent: result.success,\n            error: result.success ? null : result.message\n          }\n        }));\n      } catch (error) {\n        console.error(`Failed to send reminder email to ${participant.name}:`, error);\n\n        // Update email status with error\n        setEmailStatus(prev => ({\n          ...prev,\n          [participantId]: {\n            sent: false,\n            error: error.message || 'Failed to send email'\n          }\n        }));\n      }\n\n      // Clear status after some time\n      setTimeout(() => {\n        setEmailStatus(prev => {\n          const newStatus = {\n            ...prev\n          };\n          delete newStatus[participantId];\n          return newStatus;\n        });\n      }, 10000);\n      return true;\n    } catch (error) {\n      console.error('Error sending payment reminder:', error);\n\n      // Make sure the sending status is cleared if there's an error\n      setEmailStatus(prev => ({\n        ...prev,\n        [participantId]: {\n          sent: false,\n          error: error.message || 'Unknown error occurred'\n        }\n      }));\n      return false;\n    }\n  };\n\n  /**\r\n   * Create a participant from a contact\r\n   * @param {Object} contact - Contact object\r\n   * @returns {Object} Participant object\r\n   */\n  const createParticipantFromContact = contact => {\n    return createParticipant(contact.name, contact.email);\n  };\n\n  /**\r\n   * Get the email status for a participant\r\n   * @param {string} participantId - Participant ID\r\n   * @returns {Object} Email status object or null\r\n   */\n  const getEmailStatus = participantId => {\n    return emailStatus[participantId] || null;\n  };\n  return /*#__PURE__*/_jsxDEV(SplitExpenseContext.Provider, {\n    value: {\n      loading,\n      createNewSplitExpense,\n      getSplitExpense,\n      updatePaymentStatus,\n      addContact,\n      deleteContact,\n      getAllSplitExpenses,\n      getAllContacts,\n      deleteSplitExpense,\n      sendPaymentReminder,\n      createParticipant,\n      createParticipantFromContact,\n      emailStatus,\n      getEmailStatus\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 458,\n    columnNumber: 5\n  }, this);\n};\n_s(SplitExpenseProvider, \"rYbopUwkltg5RsTAfO3UuSZmR6o=\");\n_c = SplitExpenseProvider;\nexport default SplitExpenseContext;\nvar _c;\n$RefreshReg$(_c, \"SplitExpenseProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","AuthContext","ExpenseContext","createSplitExpense","createParticipant","updateParticipantStatus","calculateSplitStatus","sendSplitExpenseEmail","jsxDEV","_jsxDEV","SplitExpenseContext","SplitExpenseProvider","children","_s","splitExpenses","setSplitExpenses","contacts","setContacts","loading","setLoading","emailStatus","setEmailStatus","currentUser","addExpense","getUserStorageKey","key","id","savedSplitExpenses","JSON","parse","localStorage","getItem","Array","isArray","savedContacts","error","console","setItem","stringify","createNewSplitExpense","expenseData","participants","expenseResult","isSplit","notes","length","Error","newSplitExpense","prev","existingContactEmails","map","c","email","filter","Boolean","newContacts","p","includes","name","otherParticipants","log","sendEmailQueue","i","participant","sending","emailParams","to_email","to_name","creator_name","expense_description","description","expense_category","category","expense_date","Date","date","toLocaleDateString","expense_amount","totalAmount","toFixed","share_amount","shareAmount","is_reminder","reminder_message","reply_to","subject","result","sent","success","message","Promise","resolve","setTimeout","getSplitExpense","find","expense","updatePaymentStatus","splitExpenseId","participantId","status","paymentMethod","updatedSplitExpenses","splitExpense","updatedParticipants","updatedSplitExpense","addContact","trim","some","newContact","now","deleteContact","contactId","contact","getAllSplitExpenses","getAllContacts","deleteSplitExpense","sendPaymentReminder","newStatus","createParticipantFromContact","getEmailStatus","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/tejit/OneDrive/Desktop/expence tracker final/expence-tracker/src/context/SplitExpenseContext.js"],"sourcesContent":["// src/context/SplitExpenseContext.js\r\nimport React, { createContext, useState, useEffect, useContext } from 'react';\r\nimport { AuthContext } from './AuthContext';\r\nimport { ExpenseContext } from './ExpenseContext';\r\nimport { \r\n  createSplitExpense, \r\n  createParticipant, \r\n  updateParticipantStatus, \r\n  calculateSplitStatus \r\n} from '../models/SplitExpenseModel';\r\nimport { sendSplitExpenseEmail } from '../services/EmailService';\r\n\r\nexport const SplitExpenseContext = createContext();\r\n\r\nexport const SplitExpenseProvider = ({ children }) => {\r\n  const [splitExpenses, setSplitExpenses] = useState([]);\r\n  const [contacts, setContacts] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [emailStatus, setEmailStatus] = useState({});\r\n  \r\n  const { currentUser } = useContext(AuthContext);\r\n  const { addExpense } = useContext(ExpenseContext);\r\n  \r\n  // Generate unique storage keys for current user\r\n  const getUserStorageKey = (key) => {\r\n    if (!currentUser) return key;\r\n    return `${key}_${currentUser.id}`;\r\n  };\r\n  \r\n  // Load data from localStorage when component mounts or user changes\r\n  useEffect(() => {\r\n    if (currentUser) {\r\n      try {\r\n        // Load split expenses\r\n        const savedSplitExpenses = JSON.parse(localStorage.getItem(getUserStorageKey('splitExpenses'))) || [];\r\n        setSplitExpenses(Array.isArray(savedSplitExpenses) ? savedSplitExpenses : []);\r\n        \r\n        // Load contacts\r\n        const savedContacts = JSON.parse(localStorage.getItem(getUserStorageKey('splitContacts'))) || [];\r\n        setContacts(Array.isArray(savedContacts) ? savedContacts : []);\r\n      } catch (error) {\r\n        console.error('Error loading split expense data:', error);\r\n        setSplitExpenses([]);\r\n        setContacts([]);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    } else {\r\n      setSplitExpenses([]);\r\n      setContacts([]);\r\n      setLoading(false);\r\n    }\r\n  }, [currentUser]);\r\n  \r\n  // Save split expenses to localStorage whenever they change\r\n  useEffect(() => {\r\n    if (currentUser && !loading) {\r\n      localStorage.setItem(getUserStorageKey('splitExpenses'), JSON.stringify(splitExpenses));\r\n    }\r\n  }, [splitExpenses, currentUser, loading]);\r\n  \r\n  // Save contacts to localStorage whenever they change\r\n  useEffect(() => {\r\n    if (currentUser && !loading) {\r\n      localStorage.setItem(getUserStorageKey('splitContacts'), JSON.stringify(contacts));\r\n    }\r\n  }, [contacts, currentUser, loading]);\r\n  \r\n  /**\r\n   * Create a new split expense\r\n   * @param {Object} expenseData - Expense data (amount, category, etc.)\r\n   * @param {Array} participants - Array of participants\r\n   * @returns {Object} New split expense or null if failed\r\n   */\r\n  const createNewSplitExpense = (expenseData, participants) => {\r\n    if (!currentUser) return null;\r\n    \r\n    try {\r\n      // First create the base expense\r\n      const expenseResult = addExpense({\r\n        ...expenseData,\r\n        // Mark this as a split expense\r\n        isSplit: true,\r\n        notes: expenseData.notes || `Split with ${participants.length} people`\r\n      });\r\n      \r\n      if (!expenseResult) {\r\n        throw new Error('Failed to create base expense');\r\n      }\r\n      \r\n      // Create the split expense object\r\n      const newSplitExpense = createSplitExpense(\r\n        {\r\n          ...expenseData,\r\n          // The addExpense function returns the ID, but we need the full object\r\n          id: expenseResult\r\n        },\r\n        participants\r\n      );\r\n      \r\n      // Add to state\r\n      setSplitExpenses(prev => [...prev, newSplitExpense]);\r\n      \r\n      // Add any new contacts to the contacts list\r\n      const existingContactEmails = contacts.map(c => c.email).filter(Boolean);\r\n      const newContacts = participants\r\n        .filter(p => p.email && !existingContactEmails.includes(p.email))\r\n        .map(p => ({\r\n          id: p.id,\r\n          name: p.name,\r\n          email: p.email\r\n        }));\r\n        \r\n      if (newContacts.length > 0) {\r\n        setContacts(prev => [...prev, ...newContacts]);\r\n      }\r\n      \r\n      // Send email notifications to participants (except the creator)\r\n      const otherParticipants = participants.filter(p => \r\n        p.email && p.email !== currentUser.email\r\n      );\r\n      \r\n      if (otherParticipants.length > 0) {\r\n        console.log(`Sending split expense notifications to ${otherParticipants.length} participants`);\r\n        \r\n        // Create a queue to send emails sequentially to avoid rate limits\r\n        const sendEmailQueue = async () => {\r\n          for (let i = 0; i < otherParticipants.length; i++) {\r\n            const participant = otherParticipants[i];\r\n            \r\n            try {\r\n              // Track email status\r\n              setEmailStatus(prev => ({\r\n                ...prev,\r\n                [participant.id]: { sending: true }\r\n              }));\r\n              \r\n              // Create complete email parameters\r\n              const emailParams = {\r\n                to_email: participant.email,\r\n                to_name: participant.name || 'Participant',\r\n                creator_name: currentUser.name || 'Group member',\r\n                expense_description: newSplitExpense.description || 'Split expense',\r\n                expense_category: newSplitExpense.category || 'Uncategorized',\r\n                expense_date: new Date(newSplitExpense.date).toLocaleDateString(),\r\n                expense_amount: newSplitExpense.totalAmount.toFixed(2),\r\n                share_amount: participant.shareAmount.toFixed(2),\r\n                is_reminder: false,\r\n                reminder_message: '',\r\n                // Essential parameters for EmailJS template\r\n                name: currentUser.name || 'FinTrack',\r\n                email: currentUser.email || '',\r\n                reply_to: currentUser.email || '',\r\n                subject: `Split expense: ${newSplitExpense.description || 'New expense'}`\r\n              };\r\n              \r\n              // Send the email\r\n              const result = await sendSplitExpenseEmail(\r\n                participant, \r\n                newSplitExpense, \r\n                currentUser,\r\n                false,\r\n                emailParams\r\n              );\r\n              \r\n              console.log(`Email result for ${participant.name}:`, result);\r\n              \r\n              // Update email status\r\n              setEmailStatus(prev => ({\r\n                ...prev,\r\n                [participant.id]: { \r\n                  sent: result.success, \r\n                  error: result.success ? null : result.message \r\n                }\r\n              }));\r\n              \r\n              // Wait a bit between emails to avoid rate limiting\r\n              if (i < otherParticipants.length - 1) {\r\n                await new Promise(resolve => setTimeout(resolve, 1000));\r\n              }\r\n            } catch (error) {\r\n              console.error(`Failed to send split email to ${participant.name}:`, error);\r\n              \r\n              // Update email status with error\r\n              setEmailStatus(prev => ({\r\n                ...prev,\r\n                [participant.id]: { \r\n                  sent: false, \r\n                  error: error.message || 'Unknown error' \r\n                }\r\n              }));\r\n              \r\n              // Continue with the next participant even if this one fails\r\n              await new Promise(resolve => setTimeout(resolve, 500));\r\n            }\r\n          }\r\n          \r\n          // Clear email status after all emails have been processed (plus a buffer)\r\n          setTimeout(() => {\r\n            setEmailStatus({});\r\n          }, 10000);\r\n        };\r\n        \r\n        // Start the email queue\r\n        sendEmailQueue();\r\n      }\r\n      \r\n      return newSplitExpense;\r\n    } catch (error) {\r\n      console.error('Error creating split expense:', error);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Get a split expense by ID\r\n   * @param {string|number} id - Split expense ID\r\n   * @returns {Object} Split expense or null if not found\r\n   */\r\n  const getSplitExpense = (id) => {\r\n    return splitExpenses.find(expense => expense.id === id) || null;\r\n  };\r\n  \r\n  /**\r\n   * Update a participant's payment status\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @param {string} status - New status (paid, unpaid, declined)\r\n   * @param {string} paymentMethod - Method of payment\r\n   * @returns {boolean} Success status\r\n   */\r\n  const updatePaymentStatus = (splitExpenseId, participantId, status, paymentMethod) => {\r\n    try {\r\n      // Find the split expense\r\n      const updatedSplitExpenses = splitExpenses.map(splitExpense => {\r\n        if (splitExpense.id !== splitExpenseId) return splitExpense;\r\n        \r\n        // Update the participant\r\n        const updatedParticipants = splitExpense.participants.map(participant => {\r\n          if (participant.id !== participantId) return participant;\r\n          return updateParticipantStatus(participant, status, paymentMethod);\r\n        });\r\n        \r\n        // Recalculate the overall status\r\n        const updatedSplitExpense = {\r\n          ...splitExpense,\r\n          participants: updatedParticipants,\r\n          status: calculateSplitStatus({\r\n            ...splitExpense,\r\n            participants: updatedParticipants\r\n          })\r\n        };\r\n        \r\n        return updatedSplitExpense;\r\n      });\r\n      \r\n      setSplitExpenses(updatedSplitExpenses);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating payment status:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Add a new contact\r\n   * @param {string} name - Contact name\r\n   * @param {string} email - Contact email\r\n   * @returns {Object} New contact or null if failed\r\n   */\r\n  const addContact = (name, email) => {\r\n    if (!name.trim()) return null;\r\n    \r\n    try {\r\n      // Check if contact already exists\r\n      if (contacts.some(c => c.email === email)) {\r\n        return null;\r\n      }\r\n      \r\n      const newContact = {\r\n        id: `c_${Date.now()}`,\r\n        name: name.trim(),\r\n        email: email?.trim() || ''\r\n      };\r\n      \r\n      setContacts(prev => [...prev, newContact]);\r\n      return newContact;\r\n    } catch (error) {\r\n      console.error('Error adding contact:', error);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Delete a contact\r\n   * @param {string} contactId - Contact ID\r\n   * @returns {boolean} Success status\r\n   */\r\n  const deleteContact = (contactId) => {\r\n    try {\r\n      setContacts(prev => prev.filter(contact => contact.id !== contactId));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting contact:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Get all split expenses\r\n   * @returns {Array} Array of split expenses\r\n   */\r\n  const getAllSplitExpenses = () => {\r\n    return splitExpenses;\r\n  };\r\n  \r\n  /**\r\n   * Get all contacts\r\n   * @returns {Array} Array of contacts\r\n   */\r\n  const getAllContacts = () => {\r\n    return contacts;\r\n  };\r\n  \r\n  /**\r\n   * Delete a split expense\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @returns {boolean} Success status\r\n   */\r\n  const deleteSplitExpense = (splitExpenseId) => {\r\n    try {\r\n      // Remove from state\r\n      setSplitExpenses(prev => prev.filter(expense => expense.id !== splitExpenseId));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting split expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Remind a participant to pay\r\n   * @param {string|number} splitExpenseId - Split expense ID\r\n   * @param {string} participantId - Participant ID\r\n   * @returns {boolean} Success status\r\n   */\r\n  const sendPaymentReminder = async (splitExpenseId, participantId) => {\r\n    try {\r\n      const splitExpense = getSplitExpense(splitExpenseId);\r\n      if (!splitExpense) return false;\r\n      \r\n      const participant = splitExpense.participants.find(p => p.id === participantId);\r\n      if (!participant || !participant.email) return false;\r\n      \r\n      // Set status to sending\r\n      setEmailStatus(prev => ({\r\n        ...prev,\r\n        [participantId]: { sending: true }\r\n      }));\r\n      \r\n      // Create complete email parameters\r\n      const emailParams = {\r\n        to_email: participant.email,\r\n        to_name: participant.name || 'Participant',\r\n        creator_name: currentUser.name || 'Group member',\r\n        expense_description: splitExpense.description || 'Split expense',\r\n        expense_category: splitExpense.category || 'Uncategorized',\r\n        expense_date: new Date(splitExpense.date).toLocaleDateString(),\r\n        expense_amount: splitExpense.totalAmount.toFixed(2),\r\n        share_amount: participant.shareAmount.toFixed(2),\r\n        is_reminder: true,\r\n        reminder_message: `This is a friendly reminder that your payment of $${participant.shareAmount.toFixed(2)} for \"${splitExpense.description}\" is still pending.`,\r\n        // Essential parameters for EmailJS template\r\n        name: currentUser.name || 'FinTrack',\r\n        email: currentUser.email || '',\r\n        reply_to: currentUser.email || '',\r\n        subject: `Payment Reminder: ${splitExpense.description || 'Split expense'}`\r\n      };\r\n      \r\n      try {\r\n        // Send reminder email with explicit error handling\r\n        const result = await sendSplitExpenseEmail(\r\n          participant, \r\n          splitExpense, \r\n          currentUser, \r\n          true, \r\n          emailParams\r\n        );\r\n        \r\n        console.log(`Reminder email result for ${participant.name}:`, result);\r\n        \r\n        // Update email status\r\n        setEmailStatus(prev => ({\r\n          ...prev,\r\n          [participantId]: { \r\n            sent: result.success, \r\n            error: result.success ? null : result.message \r\n          }\r\n        }));\r\n      } catch (error) {\r\n        console.error(`Failed to send reminder email to ${participant.name}:`, error);\r\n        \r\n        // Update email status with error\r\n        setEmailStatus(prev => ({\r\n          ...prev,\r\n          [participantId]: { \r\n            sent: false, \r\n            error: error.message || 'Failed to send email' \r\n          }\r\n        }));\r\n      }\r\n      \r\n      // Clear status after some time\r\n      setTimeout(() => {\r\n        setEmailStatus(prev => {\r\n          const newStatus = { ...prev };\r\n          delete newStatus[participantId];\r\n          return newStatus;\r\n        });\r\n      }, 10000);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error sending payment reminder:', error);\r\n      \r\n      // Make sure the sending status is cleared if there's an error\r\n      setEmailStatus(prev => ({\r\n        ...prev,\r\n        [participantId]: { \r\n          sent: false, \r\n          error: error.message || 'Unknown error occurred' \r\n        }\r\n      }));\r\n      \r\n      return false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Create a participant from a contact\r\n   * @param {Object} contact - Contact object\r\n   * @returns {Object} Participant object\r\n   */\r\n  const createParticipantFromContact = (contact) => {\r\n    return createParticipant(contact.name, contact.email);\r\n  };\r\n  \r\n  /**\r\n   * Get the email status for a participant\r\n   * @param {string} participantId - Participant ID\r\n   * @returns {Object} Email status object or null\r\n   */\r\n  const getEmailStatus = (participantId) => {\r\n    return emailStatus[participantId] || null;\r\n  };\r\n  \r\n  return (\r\n    <SplitExpenseContext.Provider\r\n      value={{\r\n        loading,\r\n        createNewSplitExpense,\r\n        getSplitExpense,\r\n        updatePaymentStatus,\r\n        addContact,\r\n        deleteContact,\r\n        getAllSplitExpenses,\r\n        getAllContacts,\r\n        deleteSplitExpense,\r\n        sendPaymentReminder,\r\n        createParticipant,\r\n        createParticipantFromContact,\r\n        emailStatus,\r\n        getEmailStatus\r\n      }}\r\n    >\r\n      {children}\r\n    </SplitExpenseContext.Provider>\r\n  );\r\n};\r\n\r\nexport default SplitExpenseContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}