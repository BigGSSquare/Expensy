{"ast":null,"code":"// src/services/ReceiptScanningService.js\n\n/**\r\n * Service for handling receipt scanning functionality\r\n * This service connects to a third-party OCR API to extract data from receipt images\r\n */\n\n// Simulated API endpoint for receipt scanning\nconst RECEIPT_OCR_API_ENDPOINT = 'https://api.taggun.io/api/receipt/v1/simple/file';\n\n/**\r\n * Processes a receipt image and extracts relevant expense data\r\n * \r\n * @param {File|Blob} imageFile - The receipt image file to process\r\n * @returns {Promise<Object>} - Extracted receipt data or error information\r\n */\nexport const scanReceiptImage = async imageFile => {\n  if (!imageFile) {\n    return {\n      success: false,\n      error: 'No image file provided'\n    };\n  }\n\n  // Check if file is a valid image type\n  const validImageTypes = ['image/jpeg', 'image/png', 'image/heic', 'image/heif'];\n  if (!validImageTypes.includes(imageFile.type)) {\n    return {\n      success: false,\n      error: 'Invalid file format. Please upload a JPEG or PNG image.'\n    };\n  }\n  try {\n    // Create form data to send to the API\n    const formData = new FormData();\n    formData.append('receipt', imageFile);\n\n    // Here we would normally make an actual API call\n    // For demonstration, we'll simulate a response\n    // In a real implementation, this would be:\n    // const response = await fetch(RECEIPT_OCR_API_ENDPOINT, {\n    //   method: 'POST',\n    //   body: formData,\n    //   headers: {\n    //     'Authorization': `Bearer ${API_KEY}`\n    //   }\n    // });\n    // const data = await response.json();\n\n    // For development/testing, simulate processing time\n    await new Promise(resolve => setTimeout(resolve, 1500));\n\n    // Generate a temporary URL for the uploaded image\n    const imageUrl = URL.createObjectURL(imageFile);\n\n    // Mock a successful response with extracted data\n    // In production, this would come from the actual OCR API response\n    const extractedData = simulateOCRResponse(imageUrl);\n    return {\n      success: true,\n      ...extractedData,\n      imageUrl\n    };\n  } catch (error) {\n    console.error('Error scanning receipt:', error);\n    return {\n      success: false,\n      error: error.message || 'Failed to process receipt. Please try again.'\n    };\n  }\n};\n\n/**\r\n * Helper function to simulate OCR API response\r\n * In production, this would be replaced by the actual API call\r\n * \r\n * @param {string} imageUrl - URL to the receipt image\r\n * @returns {Object} - Simulated extracted data\r\n */\nconst simulateOCRResponse = imageUrl => {\n  // Generate a random amount between $5 and $150\n  const amount = (Math.random() * 145 + 5).toFixed(2);\n\n  // Generate a random date within the last 30 days\n  const today = new Date();\n  const daysAgo = Math.floor(Math.random() * 30);\n  const receiptDate = new Date(today);\n  receiptDate.setDate(today.getDate() - daysAgo);\n  const dateString = receiptDate.toISOString().split('T')[0];\n\n  // Select a random merchant from common options\n  const merchants = ['Whole Foods Market', 'Target', 'Amazon', 'Starbucks', 'Chevron', 'Walgreens', 'CVS Pharmacy', 'Home Depot', 'Trader Joe\\'s', 'Best Buy', 'Subway', 'Shell', 'Walmart', 'Kroger', 'McDonald\\'s', 'Costco'];\n  const merchantName = merchants[Math.floor(Math.random() * merchants.length)];\n\n  // Generate some random items based on the merchant\n  const itemsByMerchant = {\n    'Whole Foods Market': ['Organic Apples', 'Almond Milk', 'Avocados', 'Spinach', 'Greek Yogurt'],\n    'Target': ['T-Shirt', 'Household Cleaner', 'Batteries', 'Paper Towels', 'Snacks'],\n    'Amazon': ['USB Cable', 'Phone Case', 'Book', 'HDMI Adapter', 'Headphones'],\n    'Starbucks': ['Latte', 'Pastry', 'Cold Brew', 'Breakfast Sandwich'],\n    'Chevron': ['Unleaded Gas', 'Car Wash', 'Motor Oil', 'Snacks'],\n    'Walgreens': ['Medication', 'Vitamins', 'Personal Care', 'Greeting Card'],\n    'CVS Pharmacy': ['Prescription', 'Cold Medicine', 'Shampoo', 'Cosmetics'],\n    'Home Depot': ['Light Bulbs', 'Paint', 'Tools', 'Plant', 'Hardware'],\n    'Trader Joe\\'s': ['Cheese', 'Frozen Meal', 'Wine', 'Crackers', 'Flowers'],\n    'Best Buy': ['Phone Charger', 'SD Card', 'Laptop Sleeve', 'Screen Protector'],\n    'Subway': ['Footlong Sandwich', 'Cookie', 'Chips', 'Soda'],\n    'Shell': ['Premium Gas', 'Car Wash', 'Engine Oil', 'Windshield Washer Fluid'],\n    'Walmart': ['Groceries', 'Household Supplies', 'Electronics', 'Clothing'],\n    'Kroger': ['Produce', 'Meat', 'Bakery', 'Dairy', 'Frozen Food'],\n    'McDonald\\'s': ['Burger', 'Fries', 'Soda', 'Ice Cream', 'Salad'],\n    'Costco': ['Bulk Items', 'Electronics', 'Rotisserie Chicken', 'Toilet Paper']\n  };\n\n  // Get items for the selected merchant, or use generic items\n  const merchantItems = itemsByMerchant[merchantName] || ['Item 1', 'Item 2', 'Item 3'];\n\n  // Select 1-4 random items from the merchant's items list\n  const itemCount = Math.floor(Math.random() * 4) + 1;\n  const items = [];\n  for (let i = 0; i < itemCount; i++) {\n    const randomIndex = Math.floor(Math.random() * merchantItems.length);\n    items.push(merchantItems[randomIndex]);\n  }\n\n  // Generate a receipt number\n  const receiptNumber = `REC-${Math.floor(Math.random() * 10000).toString().padStart(4, '0')}`;\n  return {\n    merchantName,\n    amount,\n    date: dateString,\n    receiptNumber,\n    items,\n    confidence: 0.92,\n    // Simulated confidence score of the OCR extraction\n    taxAmount: (amount * 0.0825).toFixed(2),\n    // Simulated tax calculation\n    currencyCode: 'USD'\n  };\n};\n\n/**\r\n * Validate and parse receipt data returned from the OCR service\r\n * \r\n * @param {Object} ocrData - Raw data from the OCR service\r\n * @returns {Object} - Normalized receipt data\r\n */\nexport const parseReceiptData = ocrData => {\n  if (!ocrData || !ocrData.success) {\n    return null;\n  }\n\n  // Extract and validate amount\n  let amount = parseFloat(ocrData.amount);\n  if (isNaN(amount) || amount <= 0) {\n    amount = 0;\n  }\n\n  // Validate date\n  let receiptDate = ocrData.date;\n  if (!receiptDate || !isValidDate(receiptDate)) {\n    receiptDate = new Date().toISOString().slice(0, 10);\n  }\n\n  // Normalize merchant name\n  const merchantName = ocrData.merchantName || 'Unknown Vendor';\n  return {\n    amount,\n    date: receiptDate,\n    merchantName,\n    items: Array.isArray(ocrData.items) ? ocrData.items : [],\n    receiptNumber: ocrData.receiptNumber || null,\n    taxAmount: ocrData.taxAmount || 0,\n    imageUrl: ocrData.imageUrl || null,\n    confidence: ocrData.confidence || 0\n  };\n};\n\n/**\r\n * Helper function to validate date string\r\n * \r\n * @param {string} dateString - Date string to validate\r\n * @returns {boolean} - Whether the date is valid\r\n */\nconst isValidDate = dateString => {\n  if (!dateString) return false;\n\n  // Try to create a date object and check if it's valid\n  const date = new Date(dateString);\n  return !isNaN(date.getTime());\n};","map":{"version":3,"names":["RECEIPT_OCR_API_ENDPOINT","scanReceiptImage","imageFile","success","error","validImageTypes","includes","type","formData","FormData","append","Promise","resolve","setTimeout","imageUrl","URL","createObjectURL","extractedData","simulateOCRResponse","console","message","amount","Math","random","toFixed","today","Date","daysAgo","floor","receiptDate","setDate","getDate","dateString","toISOString","split","merchants","merchantName","length","itemsByMerchant","merchantItems","itemCount","items","i","randomIndex","push","receiptNumber","toString","padStart","date","confidence","taxAmount","currencyCode","parseReceiptData","ocrData","parseFloat","isNaN","isValidDate","slice","Array","isArray","getTime"],"sources":["C:/Users/tejit/OneDrive/Desktop/expence tracker final/expence-tracker/src/services/ReceiptScanningService.js"],"sourcesContent":["// src/services/ReceiptScanningService.js\r\n\r\n/**\r\n * Service for handling receipt scanning functionality\r\n * This service connects to a third-party OCR API to extract data from receipt images\r\n */\r\n\r\n// Simulated API endpoint for receipt scanning\r\nconst RECEIPT_OCR_API_ENDPOINT = 'https://api.taggun.io/api/receipt/v1/simple/file';\r\n\r\n/**\r\n * Processes a receipt image and extracts relevant expense data\r\n * \r\n * @param {File|Blob} imageFile - The receipt image file to process\r\n * @returns {Promise<Object>} - Extracted receipt data or error information\r\n */\r\nexport const scanReceiptImage = async (imageFile) => {\r\n  if (!imageFile) {\r\n    return { \r\n      success: false, \r\n      error: 'No image file provided' \r\n    };\r\n  }\r\n  \r\n  // Check if file is a valid image type\r\n  const validImageTypes = ['image/jpeg', 'image/png', 'image/heic', 'image/heif'];\r\n  if (!validImageTypes.includes(imageFile.type)) {\r\n    return {\r\n      success: false,\r\n      error: 'Invalid file format. Please upload a JPEG or PNG image.'\r\n    };\r\n  }\r\n  \r\n  try {\r\n    // Create form data to send to the API\r\n    const formData = new FormData();\r\n    formData.append('receipt', imageFile);\r\n    \r\n    // Here we would normally make an actual API call\r\n    // For demonstration, we'll simulate a response\r\n    // In a real implementation, this would be:\r\n    // const response = await fetch(RECEIPT_OCR_API_ENDPOINT, {\r\n    //   method: 'POST',\r\n    //   body: formData,\r\n    //   headers: {\r\n    //     'Authorization': `Bearer ${API_KEY}`\r\n    //   }\r\n    // });\r\n    // const data = await response.json();\r\n    \r\n    // For development/testing, simulate processing time\r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n    \r\n    // Generate a temporary URL for the uploaded image\r\n    const imageUrl = URL.createObjectURL(imageFile);\r\n    \r\n    // Mock a successful response with extracted data\r\n    // In production, this would come from the actual OCR API response\r\n    const extractedData = simulateOCRResponse(imageUrl);\r\n    \r\n    return {\r\n      success: true,\r\n      ...extractedData,\r\n      imageUrl\r\n    };\r\n  } catch (error) {\r\n    console.error('Error scanning receipt:', error);\r\n    return {\r\n      success: false,\r\n      error: error.message || 'Failed to process receipt. Please try again.'\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Helper function to simulate OCR API response\r\n * In production, this would be replaced by the actual API call\r\n * \r\n * @param {string} imageUrl - URL to the receipt image\r\n * @returns {Object} - Simulated extracted data\r\n */\r\nconst simulateOCRResponse = (imageUrl) => {\r\n  // Generate a random amount between $5 and $150\r\n  const amount = (Math.random() * 145 + 5).toFixed(2);\r\n  \r\n  // Generate a random date within the last 30 days\r\n  const today = new Date();\r\n  const daysAgo = Math.floor(Math.random() * 30);\r\n  const receiptDate = new Date(today);\r\n  receiptDate.setDate(today.getDate() - daysAgo);\r\n  const dateString = receiptDate.toISOString().split('T')[0];\r\n  \r\n  // Select a random merchant from common options\r\n  const merchants = [\r\n    'Whole Foods Market', 'Target', 'Amazon', 'Starbucks',\r\n    'Chevron', 'Walgreens', 'CVS Pharmacy', 'Home Depot',\r\n    'Trader Joe\\'s', 'Best Buy', 'Subway', 'Shell',\r\n    'Walmart', 'Kroger', 'McDonald\\'s', 'Costco'\r\n  ];\r\n  const merchantName = merchants[Math.floor(Math.random() * merchants.length)];\r\n  \r\n  // Generate some random items based on the merchant\r\n  const itemsByMerchant = {\r\n    'Whole Foods Market': ['Organic Apples', 'Almond Milk', 'Avocados', 'Spinach', 'Greek Yogurt'],\r\n    'Target': ['T-Shirt', 'Household Cleaner', 'Batteries', 'Paper Towels', 'Snacks'],\r\n    'Amazon': ['USB Cable', 'Phone Case', 'Book', 'HDMI Adapter', 'Headphones'],\r\n    'Starbucks': ['Latte', 'Pastry', 'Cold Brew', 'Breakfast Sandwich'],\r\n    'Chevron': ['Unleaded Gas', 'Car Wash', 'Motor Oil', 'Snacks'],\r\n    'Walgreens': ['Medication', 'Vitamins', 'Personal Care', 'Greeting Card'],\r\n    'CVS Pharmacy': ['Prescription', 'Cold Medicine', 'Shampoo', 'Cosmetics'],\r\n    'Home Depot': ['Light Bulbs', 'Paint', 'Tools', 'Plant', 'Hardware'],\r\n    'Trader Joe\\'s': ['Cheese', 'Frozen Meal', 'Wine', 'Crackers', 'Flowers'],\r\n    'Best Buy': ['Phone Charger', 'SD Card', 'Laptop Sleeve', 'Screen Protector'],\r\n    'Subway': ['Footlong Sandwich', 'Cookie', 'Chips', 'Soda'],\r\n    'Shell': ['Premium Gas', 'Car Wash', 'Engine Oil', 'Windshield Washer Fluid'],\r\n    'Walmart': ['Groceries', 'Household Supplies', 'Electronics', 'Clothing'],\r\n    'Kroger': ['Produce', 'Meat', 'Bakery', 'Dairy', 'Frozen Food'],\r\n    'McDonald\\'s': ['Burger', 'Fries', 'Soda', 'Ice Cream', 'Salad'],\r\n    'Costco': ['Bulk Items', 'Electronics', 'Rotisserie Chicken', 'Toilet Paper']\r\n  };\r\n  \r\n  // Get items for the selected merchant, or use generic items\r\n  const merchantItems = itemsByMerchant[merchantName] || ['Item 1', 'Item 2', 'Item 3'];\r\n  \r\n  // Select 1-4 random items from the merchant's items list\r\n  const itemCount = Math.floor(Math.random() * 4) + 1;\r\n  const items = [];\r\n  for (let i = 0; i < itemCount; i++) {\r\n    const randomIndex = Math.floor(Math.random() * merchantItems.length);\r\n    items.push(merchantItems[randomIndex]);\r\n  }\r\n  \r\n  // Generate a receipt number\r\n  const receiptNumber = `REC-${Math.floor(Math.random() * 10000).toString().padStart(4, '0')}`;\r\n  \r\n  return {\r\n    merchantName,\r\n    amount,\r\n    date: dateString,\r\n    receiptNumber,\r\n    items,\r\n    confidence: 0.92, // Simulated confidence score of the OCR extraction\r\n    taxAmount: (amount * 0.0825).toFixed(2), // Simulated tax calculation\r\n    currencyCode: 'USD'\r\n  };\r\n};\r\n\r\n/**\r\n * Validate and parse receipt data returned from the OCR service\r\n * \r\n * @param {Object} ocrData - Raw data from the OCR service\r\n * @returns {Object} - Normalized receipt data\r\n */\r\nexport const parseReceiptData = (ocrData) => {\r\n  if (!ocrData || !ocrData.success) {\r\n    return null;\r\n  }\r\n  \r\n  // Extract and validate amount\r\n  let amount = parseFloat(ocrData.amount);\r\n  if (isNaN(amount) || amount <= 0) {\r\n    amount = 0;\r\n  }\r\n  \r\n  // Validate date\r\n  let receiptDate = ocrData.date;\r\n  if (!receiptDate || !isValidDate(receiptDate)) {\r\n    receiptDate = new Date().toISOString().slice(0, 10);\r\n  }\r\n  \r\n  // Normalize merchant name\r\n  const merchantName = ocrData.merchantName || 'Unknown Vendor';\r\n  \r\n  return {\r\n    amount,\r\n    date: receiptDate,\r\n    merchantName,\r\n    items: Array.isArray(ocrData.items) ? ocrData.items : [],\r\n    receiptNumber: ocrData.receiptNumber || null,\r\n    taxAmount: ocrData.taxAmount || 0,\r\n    imageUrl: ocrData.imageUrl || null,\r\n    confidence: ocrData.confidence || 0\r\n  };\r\n};\r\n\r\n/**\r\n * Helper function to validate date string\r\n * \r\n * @param {string} dateString - Date string to validate\r\n * @returns {boolean} - Whether the date is valid\r\n */\r\nconst isValidDate = (dateString) => {\r\n  if (!dateString) return false;\r\n  \r\n  // Try to create a date object and check if it's valid\r\n  const date = new Date(dateString);\r\n  return !isNaN(date.getTime());\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}