{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\tejit\\\\OneDrive\\\\Desktop\\\\expence tracker final\\\\expence-tracker\\\\src\\\\context\\\\ExpenseContext.js\",\n  _s = $RefreshSig$();\n// src/context/ExpenseContext.js\nimport React, { createContext, useState, useEffect, useContext } from 'react';\nimport { AuthContext } from './AuthContext';\nimport { sendBudgetAlertEmail } from '../services/EmailService';\nimport { scanReceiptImage, parseReceiptData } from '../services/ReceiptScanningService';\n// Add Firebase imports\nimport { db, storage } from '../config/firebase';\nimport { collection, addDoc, doc, deleteDoc, updateDoc, query, where, getDocs, onSnapshot, getDoc, setDoc, limit } from 'firebase/firestore';\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ExpenseContext = /*#__PURE__*/createContext();\nexport const ExpenseProvider = ({\n  children\n}) => {\n  _s();\n  const [expenses, setExpenses] = useState([]);\n  const [incomes, setIncomes] = useState([]);\n  const [budgets, setBudgets] = useState({});\n  const [alerts, setAlerts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [emailStatus, setEmailStatus] = useState({\n    sent: false,\n    error: null\n  });\n  const [expenseCategories, setExpenseCategories] = useState([]);\n  const [incomeCategories, setIncomeCategories] = useState([]);\n  // Add new state for receipt scanning\n  const [receiptScanStatus, setReceiptScanStatus] = useState({\n    scanning: false,\n    error: null,\n    data: null\n  });\n  // Track receipt scan history\n  const [receiptScans, setReceiptScans] = useState([]);\n  const {\n    currentUser\n  } = useContext(AuthContext);\n\n  // Default categories if none are found\n  const DEFAULT_EXPENSE_CATEGORIES = ['Food', 'Housing', 'Transportation', 'Entertainment', 'Utilities', 'Healthcare', 'Shopping', 'Personal Care', 'Education', 'Other'];\n  const DEFAULT_INCOME_CATEGORIES = ['Salary', 'Freelance', 'Investment', 'Gift', 'Business', 'Side Hustle', 'Rental', 'Other'];\n\n  // Load expenses from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setExpenses([]);\n      setLoading(false);\n      return;\n    }\n    setLoading(true);\n\n    // Query Firestore for expenses\n    const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(expensesQuery, snapshot => {\n      const expensesList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setExpenses(expensesList);\n      setLoading(false);\n    }, error => {\n      console.error(\"Error getting expenses:\", error);\n      setLoading(false);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Load incomes from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setIncomes([]);\n      return;\n    }\n\n    // Query Firestore for incomes\n    const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(incomesQuery, snapshot => {\n      const incomesList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setIncomes(incomesList);\n    }, error => {\n      console.error(\"Error getting incomes:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Clear email status after some time\n  useEffect(() => {\n    if (emailStatus.sent || emailStatus.error) {\n      const timer = setTimeout(() => {\n        setEmailStatus({\n          sent: false,\n          error: null\n        });\n      }, 5000);\n      return () => clearTimeout(timer);\n    }\n  }, [emailStatus]);\n\n  // Clear receipt scan data after processing\n  useEffect(() => {\n    if (receiptScanStatus.data && !receiptScanStatus.scanning) {\n      const timer = setTimeout(() => {\n        setReceiptScanStatus(prevState => ({\n          ...prevState,\n          data: null\n        }));\n      }, 30000); // Give user 30 seconds to review before clearing\n\n      return () => clearTimeout(timer);\n    }\n  }, [receiptScanStatus]);\n\n  // Add a new expense with validation\n  // Updated addExpense function for ExpenseContext.js\n  const addExpense = async expense => {\n    if (!currentUser) {\n      console.error('Cannot add expense: No authenticated user');\n      return false;\n    }\n    try {\n      console.log('Starting expense creation with data:', expense);\n\n      // Validate expense data\n      if (!expense.category) {\n        console.error('Missing category in expense');\n        return false;\n      }\n      const amount = parseFloat(expense.amount);\n      if (isNaN(amount) || amount <= 0) {\n        console.error('Invalid expense amount:', expense.amount);\n        return false;\n      }\n\n      // Handle receipt image if present\n      let receiptImageUrl = expense.receiptImageUrl || null;\n      if (expense.receiptImage instanceof File) {\n        console.log('Uploading receipt image...');\n        const storageRef = ref(storage, `receipts/${currentUser.uid}/${Date.now()}_${expense.receiptImage.name}`);\n        await uploadBytes(storageRef, expense.receiptImage);\n        receiptImageUrl = await getDownloadURL(storageRef);\n        console.log('Receipt image uploaded, URL:', receiptImageUrl);\n      }\n\n      // Create new expense object with proper types and defaults\n      const newExpense = {\n        category: expense.category,\n        amount: amount,\n        date: expense.date || new Date().toISOString().slice(0, 10),\n        description: expense.description || '',\n        userId: currentUser.uid,\n        createdAt: new Date().toISOString(),\n        fromReceipt: expense.fromReceipt || false,\n        receiptImageUrl,\n        receiptScanId: expense.receiptScanId || null\n      };\n      console.log('Formatted expense object:', newExpense);\n\n      // Delete any properties we don't want to store\n      delete newExpense.receiptImage;\n\n      // Log the collection reference and ensure Firestore is connected\n      const expensesCollection = collection(db, 'expenses');\n      console.log('Expenses collection reference:', expensesCollection);\n\n      // Add to Firestore\n      console.log('Adding expense to Firestore...');\n      const docRef = await addDoc(expensesCollection, newExpense);\n      console.log('Expense added to Firestore, ID:', docRef.id);\n\n      // Check for budget alerts\n      await checkBudgetAlerts({\n        ...newExpense,\n        id: docRef.id\n      });\n      return docRef.id;\n    } catch (error) {\n      console.error('Error adding expense:', error);\n      console.error('Error code:', error.code);\n      console.error('Error message:', error.message);\n\n      // Check for specific Firebase errors\n      if (error.code === 'permission-denied') {\n        console.error('Firebase permission denied. Check Firestore rules.');\n      } else if (error.code === 'unavailable') {\n        console.error('Firebase service unavailable. Check internet connection.');\n      } else if (error.code === 'unauthenticated') {\n        console.error('User is not authenticated with Firebase.');\n      }\n      return false;\n    }\n  };\n\n  // New function to handle receipt scanning\n  const scanReceipt = async imageFile => {\n    if (!currentUser) return {\n      success: false,\n      error: 'User not logged in'\n    };\n    if (!imageFile) {\n      setReceiptScanStatus({\n        scanning: false,\n        error: 'No image provided',\n        data: null\n      });\n      return {\n        success: false,\n        error: 'No image provided'\n      };\n    }\n    try {\n      var _parsedData$items;\n      // Set scanning status\n      setReceiptScanStatus({\n        scanning: true,\n        error: null,\n        data: null\n      });\n\n      // Call the receipt scanning service\n      const scanResult = await scanReceiptImage(imageFile);\n      if (!scanResult || !scanResult.success) {\n        const errorMessage = (scanResult === null || scanResult === void 0 ? void 0 : scanResult.error) || 'Failed to scan receipt';\n        setReceiptScanStatus({\n          scanning: false,\n          error: errorMessage,\n          data: null\n        });\n        return {\n          success: false,\n          error: errorMessage\n        };\n      }\n\n      // Process the scanned data\n      const parsedData = parseReceiptData(scanResult);\n      if (!parsedData) {\n        setReceiptScanStatus({\n          scanning: false,\n          error: 'Failed to parse receipt data',\n          data: null\n        });\n        return {\n          success: false,\n          error: 'Failed to parse receipt data'\n        };\n      }\n\n      // Create a scan record\n      const scanId = Date.now();\n      const scanRecord = {\n        id: scanId,\n        date: new Date().toISOString(),\n        rawData: scanResult,\n        parsedData: parsedData,\n        userId: currentUser.uid,\n        status: 'pending',\n        // pending, applied, rejected\n        imageUrl: scanResult.imageUrl\n      };\n\n      // Store the scan record in Firestore\n      await addDoc(collection(db, 'receiptScans'), scanRecord);\n\n      // Prepare the extracted data for the UI\n      const extractedExpense = {\n        amount: parsedData.amount,\n        description: parsedData.merchantName || 'Receipt expense',\n        category: mapVendorToCategory(parsedData.merchantName || ''),\n        date: parsedData.date || new Date().toISOString().slice(0, 10),\n        fromReceipt: true,\n        receiptImageUrl: parsedData.imageUrl || null,\n        receiptScanId: scanId,\n        notes: `Receipt from ${parsedData.merchantName || 'unknown vendor'}${((_parsedData$items = parsedData.items) === null || _parsedData$items === void 0 ? void 0 : _parsedData$items.length) > 0 ? `, Items: ${parsedData.items.join(', ')}` : ''}`\n      };\n\n      // Update scan status with the extracted data\n      setReceiptScanStatus({\n        scanning: false,\n        error: null,\n        data: extractedExpense\n      });\n      return {\n        success: true,\n        data: extractedExpense,\n        scanId\n      };\n    } catch (error) {\n      console.error('Error scanning receipt:', error);\n      setReceiptScanStatus({\n        scanning: false,\n        error: error.message || 'Error scanning receipt',\n        data: null\n      });\n      return {\n        success: false,\n        error: error.message || 'Error scanning receipt'\n      };\n    }\n  };\n\n  // Function to add the expense from a scanned receipt\n  const addExpenseFromReceipt = async (expenseData, modifications = {}) => {\n    if (!currentUser) return false;\n    try {\n      // Combine scanned data with any user modifications\n      const finalExpenseData = {\n        ...expenseData,\n        ...modifications,\n        fromReceipt: true\n      };\n\n      // Use the existing addExpense function\n      const result = await addExpense(finalExpenseData);\n      if (result && finalExpenseData.receiptScanId) {\n        // Update the scan record status in Firestore\n        const scanRef = doc(db, 'receiptScans', String(finalExpenseData.receiptScanId));\n        await updateDoc(scanRef, {\n          status: 'applied'\n        });\n\n        // Clear the scanned data after successful addition\n        setReceiptScanStatus(prevState => ({\n          ...prevState,\n          data: null\n        }));\n      }\n      return result;\n    } catch (error) {\n      console.error('Error adding expense from receipt:', error);\n      return false;\n    }\n  };\n\n  // Function to reject a scanned receipt\n  const rejectScannedReceipt = async scanId => {\n    if (!scanId) return false;\n    try {\n      var _receiptScanStatus$da;\n      // Update the scan record status in Firestore\n      const scanRef = doc(db, 'receiptScans', String(scanId));\n      await updateDoc(scanRef, {\n        status: 'rejected'\n      });\n\n      // Clear any pending scan data with this ID\n      if (((_receiptScanStatus$da = receiptScanStatus.data) === null || _receiptScanStatus$da === void 0 ? void 0 : _receiptScanStatus$da.receiptScanId) === scanId) {\n        setReceiptScanStatus({\n          scanning: false,\n          error: null,\n          data: null\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error('Error rejecting scanned receipt:', error);\n      return false;\n    }\n  };\n\n  // Helper function to map vendor names to appropriate categories\n  const mapVendorToCategory = vendorName => {\n    const vendorNameLower = vendorName.toLowerCase();\n\n    // Simple mapping logic - can be expanded based on common vendors\n    if (!vendorName) return 'Other';\n    const categoryMappings = {\n      'restaurant': 'Food',\n      'cafÃ©': 'Food',\n      'cafe': 'Food',\n      'grocery': 'Food',\n      'supermarket': 'Food',\n      'market': 'Food',\n      'gas': 'Transportation',\n      'fuel': 'Transportation',\n      'uber': 'Transportation',\n      'lyft': 'Transportation',\n      'taxi': 'Transportation',\n      'pharmacy': 'Healthcare',\n      'drug': 'Healthcare',\n      'doctor': 'Healthcare',\n      'clinic': 'Healthcare',\n      'hospital': 'Healthcare',\n      'rent': 'Housing',\n      'mortgage': 'Housing',\n      'netflix': 'Entertainment',\n      'spotify': 'Entertainment',\n      'cinema': 'Entertainment',\n      'movie': 'Entertainment',\n      'theater': 'Entertainment',\n      'amazon': 'Shopping',\n      'walmart': 'Shopping',\n      'target': 'Shopping',\n      'utility': 'Utilities',\n      'electric': 'Utilities',\n      'water': 'Utilities',\n      'gas bill': 'Utilities',\n      'phone': 'Utilities',\n      'internet': 'Utilities',\n      'school': 'Education',\n      'college': 'Education',\n      'university': 'Education',\n      'tuition': 'Education',\n      'book': 'Education',\n      'haircut': 'Personal Care',\n      'salon': 'Personal Care',\n      'spa': 'Personal Care',\n      'gym': 'Personal Care'\n    };\n    for (const [keyword, category] of Object.entries(categoryMappings)) {\n      if (vendorNameLower.includes(keyword)) {\n        return category;\n      }\n    }\n    return 'Other';\n  };\n\n  // Add a new income with validation\n  const addIncome = async income => {\n    if (!currentUser) return false;\n    try {\n      // Validate income data\n      if (!income.source) {\n        console.error('Missing source in income');\n        return false;\n      }\n      const amount = parseFloat(income.amount);\n      if (isNaN(amount) || amount <= 0) {\n        console.error('Invalid income amount:', income.amount);\n        return false;\n      }\n\n      // Create new income object\n      const newIncome = {\n        ...income,\n        amount,\n        date: income.date || new Date().toISOString().slice(0, 10),\n        userId: currentUser.uid,\n        createdAt: new Date().toISOString()\n      };\n\n      // Add to Firestore\n      const docRef = await addDoc(collection(db, 'incomes'), newIncome);\n      return docRef.id;\n    } catch (error) {\n      console.error('Error adding income:', error);\n      return false;\n    }\n  };\n\n  // Delete an expense\n  const deleteExpense = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      // Get the expense before deleting it (to check for receipt info)\n      const expenseRef = doc(db, 'expenses', id);\n      const expenseSnap = await getDoc(expenseRef);\n      if (expenseSnap.exists()) {\n        const expenseData = expenseSnap.data();\n\n        // Delete the expense document\n        await deleteDoc(expenseRef);\n\n        // If this was a receipt-based expense, update the scan record\n        if (expenseData.receiptScanId) {\n          const scanRef = doc(db, 'receiptScans', String(expenseData.receiptScanId));\n          const scanSnap = await getDoc(scanRef);\n          if (scanSnap.exists()) {\n            await updateDoc(scanRef, {\n              status: 'rejected'\n            });\n          }\n        }\n      } else {\n        // Document not found\n        console.error('Expense not found');\n        return false;\n      }\n      return true;\n    } catch (error) {\n      console.error('Error deleting expense:', error);\n      return false;\n    }\n  };\n\n  // Delete an income\n  const deleteIncome = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      await deleteDoc(doc(db, 'incomes', id));\n      return true;\n    } catch (error) {\n      console.error('Error deleting income:', error);\n      return false;\n    }\n  };\n\n  // Update budget settings\n  const updateBudget = async (category, amount) => {\n    if (!currentUser || !category || category.trim() === '' || isNaN(parseFloat(amount))) {\n      return false;\n    }\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        // Update existing budgets document\n        await updateDoc(budgetRef, {\n          [category]: parseFloat(amount)\n        });\n      } else {\n        // Create new budgets document\n        await setDoc(budgetRef, {\n          [category]: parseFloat(amount)\n        });\n      }\n\n      // Update local state\n      setBudgets(prevBudgets => ({\n        ...prevBudgets,\n        [category]: parseFloat(amount)\n      }));\n      return true;\n    } catch (error) {\n      console.error('Error updating budget:', error);\n      return false;\n    }\n  };\n\n  // Delete a budget\n  const deleteBudget = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n\n        // Remove the category from the budgets\n        if (currentBudgets[category] !== undefined) {\n          delete currentBudgets[category];\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error deleting budget:', error);\n      return false;\n    }\n  };\n\n  // Check if adding this expense exceeds the budget\n  const checkBudgetAlerts = async (newExpense, allExpenses = expenses) => {\n    if (!currentUser) return; // Don't process if no user is logged in\n    if (!newExpense || !newExpense.category) return;\n    const {\n      category\n    } = newExpense;\n\n    // Get budgets from Firestore\n    try {\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (!budgetDoc.exists()) return;\n      const budgets = budgetDoc.data();\n\n      // Check if there's a budget for this category\n      if (budgets[category]) {\n        // Get current month expenses for this category\n        const currentDate = new Date();\n        const currentMonth = currentDate.getMonth();\n        const currentYear = currentDate.getFullYear();\n        const monthlyExpenses = allExpenses.filter(expense => {\n          if (!expense.date) return false;\n          try {\n            const expenseDate = new Date(expense.date);\n            return expenseDate.getMonth() === currentMonth && expenseDate.getFullYear() === currentYear && expense.category === category && expense.userId === currentUser.uid;\n          } catch (e) {\n            console.error('Invalid date format:', expense.date);\n            return false;\n          }\n        });\n        const totalSpent = monthlyExpenses.reduce((sum, expense) => {\n          const amount = parseFloat(expense.amount);\n          return sum + (isNaN(amount) ? 0 : amount);\n        }, 0);\n        const budgetAmount = parseFloat(budgets[category]);\n        if (!isNaN(budgetAmount) && totalSpent > budgetAmount) {\n          var _currentUser$preferen;\n          // Create new alert\n          const newAlert = {\n            message: `Budget alert: You've exceeded your ${category} budget of $${budgetAmount.toFixed(2)}`,\n            category: category,\n            read: false,\n            date: new Date().toISOString(),\n            userId: currentUser.uid\n          };\n\n          // Add to Firestore\n          const alertRef = await addDoc(collection(db, 'alerts'), newAlert);\n\n          // Send email alert if user has enabled email notifications\n          if ((currentUser === null || currentUser === void 0 ? void 0 : (_currentUser$preferen = currentUser.preferences) === null || _currentUser$preferen === void 0 ? void 0 : _currentUser$preferen.emailNotifications) !== false) {\n            if (currentUser.email) {\n              sendBudgetAlertEmail(currentUser, category, budgetAmount, totalSpent).then(result => {\n                setEmailStatus({\n                  sent: result.success,\n                  error: result.success ? null : result.message\n                });\n              }).catch(error => {\n                setEmailStatus({\n                  sent: false,\n                  error: error.message || 'Error sending email'\n                });\n              });\n            } else {\n              setEmailStatus({\n                sent: false,\n                error: \"No email address found for user\"\n              });\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error checking budget alerts:', error);\n    }\n  };\n\n  // Mark an alert as read\n  const markAlertAsRead = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      const alertRef = doc(db, 'alerts', id);\n      await updateDoc(alertRef, {\n        read: true\n      });\n      return true;\n    } catch (error) {\n      console.error('Error marking alert as read:', error);\n      return false;\n    }\n  };\n\n  // Delete an alert\n  const deleteAlert = async id => {\n    if (!currentUser || !id) return false;\n    try {\n      await deleteDoc(doc(db, 'alerts', id));\n      return true;\n    } catch (error) {\n      console.error('Error deleting alert:', error);\n      return false;\n    }\n  };\n\n  // Add a new expense category\n  const addExpenseCategory = async category => {\n    if (!currentUser || !category || category.trim() === '') return false;\n    try {\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      let updatedCategories;\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n\n        // Check if category already exists\n        if (currentCategories.includes(category)) {\n          return false;\n        }\n        updatedCategories = [...currentCategories, category];\n      } else {\n        updatedCategories = [...DEFAULT_EXPENSE_CATEGORIES, category];\n      }\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setExpenseCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error adding expense category:', error);\n      return false;\n    }\n  };\n\n  // Delete an expense category\n  const deleteExpenseCategory = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      // Don't delete if there are expenses using this category\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('category', '==', category), limit(1));\n      const expensesSnap = await getDocs(expensesQuery);\n      if (!expensesSnap.empty) {\n        return {\n          success: false,\n          reason: 'Category in use by existing expenses'\n        };\n      }\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\n\n        // Update Firestore\n        await setDoc(categoriesRef, {\n          categories: updatedCategories\n        });\n\n        // Update local state\n        setExpenseCategories(updatedCategories);\n      }\n\n      // Also remove any budgets for this category\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n        if (currentBudgets[category] !== undefined) {\n          delete currentBudgets[category];\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error deleting expense category:', error);\n      return {\n        success: false,\n        reason: error.message\n      };\n    }\n  };\n\n  // Edit an expense category\n  const editExpenseCategory = async (oldCategory, newCategory) => {\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\n    try {\n      // Don't allow editing the \"Other\" category\n      if (oldCategory === 'Other') return false;\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (!categoriesDoc.exists()) return false;\n      const currentCategories = categoriesDoc.data().categories || [];\n\n      // Check if the new category name already exists\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\n\n      // Check if the category is in use\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('category', '==', oldCategory), limit(1));\n      const expensesSnap = await getDocs(expensesQuery);\n      if (!expensesSnap.empty) return false;\n\n      // Update categories\n      const updatedCategories = currentCategories.map(cat => cat === oldCategory ? newCategory : cat);\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setExpenseCategories(updatedCategories);\n\n      // Update any budget for this category\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      const budgetDoc = await getDoc(budgetRef);\n      if (budgetDoc.exists()) {\n        const currentBudgets = budgetDoc.data();\n        if (currentBudgets[oldCategory] !== undefined) {\n          const budgetAmount = currentBudgets[oldCategory];\n          delete currentBudgets[oldCategory];\n          currentBudgets[newCategory] = budgetAmount;\n\n          // Update Firestore\n          await setDoc(budgetRef, currentBudgets);\n\n          // Update local state\n          setBudgets(currentBudgets);\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error editing expense category:', error);\n      return false;\n    }\n  };\n\n  // Add a new income category\n  const addIncomeCategory = async category => {\n    if (!currentUser || !category || category.trim() === '') return false;\n    try {\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      let updatedCategories;\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n\n        // Check if category already exists\n        if (currentCategories.includes(category)) {\n          return false;\n        }\n        updatedCategories = [...currentCategories, category];\n      } else {\n        updatedCategories = [...DEFAULT_INCOME_CATEGORIES, category];\n      }\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setIncomeCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error adding income category:', error);\n      return false;\n    }\n  };\n\n  // Delete an income category\n  const deleteIncomeCategory = async category => {\n    if (!currentUser || !category) return false;\n    try {\n      // Don't delete if there are incomes using this category\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid), where('source', '==', category), limit(1));\n      const incomesSnap = await getDocs(incomesQuery);\n      if (!incomesSnap.empty) {\n        return {\n          success: false,\n          reason: 'Category in use by existing incomes'\n        };\n      }\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (categoriesDoc.exists()) {\n        const currentCategories = categoriesDoc.data().categories || [];\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\n\n        // Update Firestore\n        await setDoc(categoriesRef, {\n          categories: updatedCategories\n        });\n\n        // Update local state\n        setIncomeCategories(updatedCategories);\n      }\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error deleting income category:', error);\n      return {\n        success: false,\n        reason: error.message\n      };\n    }\n  };\n\n  // Edit an income category\n  const editIncomeCategory = async (oldCategory, newCategory) => {\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\n    try {\n      // Don't allow editing the \"Other\" category\n      if (oldCategory === 'Other') return false;\n\n      // Get current categories\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      const categoriesDoc = await getDoc(categoriesRef);\n      if (!categoriesDoc.exists()) return false;\n      const currentCategories = categoriesDoc.data().categories || [];\n\n      // Check if the new category name already exists\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\n\n      // Check if the category is in use\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid), where('source', '==', oldCategory), limit(1));\n      const incomesSnap = await getDocs(incomesQuery);\n      if (!incomesSnap.empty) return false;\n\n      // Update categories\n      const updatedCategories = currentCategories.map(cat => cat === oldCategory ? newCategory : cat);\n\n      // Update Firestore\n      await setDoc(categoriesRef, {\n        categories: updatedCategories\n      });\n\n      // Update local state\n      setIncomeCategories(updatedCategories);\n      return true;\n    } catch (error) {\n      console.error('Error editing income category:', error);\n      return false;\n    }\n  };\n\n  // Get expenses for a specific month\n  const getMonthlyExpenses = (month, year) => {\n    if (!currentUser) return [];\n    const targetDate = new Date(year, month);\n    const targetMonth = targetDate.getMonth();\n    const targetYear = targetDate.getFullYear();\n    return expenses.filter(expense => {\n      if (!expense.date) return false;\n      try {\n        const expenseDate = new Date(expense.date);\n        return expenseDate.getMonth() === targetMonth && expenseDate.getFullYear() === targetYear && expense.userId === currentUser.uid;\n      } catch (e) {\n        return false;\n      }\n    });\n  };\n\n  // Get incomes for a specific month\n  const getMonthlyIncomes = (month, year) => {\n    if (!currentUser) return [];\n    const targetDate = new Date(year, month);\n    const targetMonth = targetDate.getMonth();\n    const targetYear = targetDate.getFullYear();\n    return incomes.filter(income => {\n      if (!income.date) return false;\n      try {\n        const incomeDate = new Date(income.date);\n        return incomeDate.getMonth() === targetMonth && incomeDate.getFullYear() === targetYear && income.userId === currentUser.uid;\n      } catch (e) {\n        return false;\n      }\n    });\n  };\n\n  // Get historical receipt scans\n  const getReceiptScans = async () => {\n    if (!currentUser) return [];\n    try {\n      const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n      const scansSnap = await getDocs(scansQuery);\n      return scansSnap.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error getting receipt scans:', error);\n      return [];\n    }\n  };\n\n  // Update an existing expense\n  const updateExpense = async (id, updatedData) => {\n    if (!currentUser || !id) return false;\n    try {\n      const expenseRef = doc(db, 'expenses', id);\n      await updateDoc(expenseRef, updatedData);\n      return true;\n    } catch (error) {\n      console.error('Error updating expense:', error);\n      return false;\n    }\n  };\n\n  // Update an existing income\n  const updateIncome = async (id, updatedData) => {\n    if (!currentUser || !id) return false;\n    try {\n      const incomeRef = doc(db, 'incomes', id);\n      await updateDoc(incomeRef, updatedData);\n      return true;\n    } catch (error) {\n      console.error('Error updating income:', error);\n      return false;\n    }\n  };\n\n  // Export data for backups\n  const exportData = async () => {\n    if (!currentUser) return null;\n    try {\n      // Get all current user data\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid));\n      const incomesQuery = query(collection(db, 'incomes'), where('userId', '==', currentUser.uid));\n      const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n      const [expensesSnap, incomesSnap, scansSnap, categoriesSnap, budgetsSnap] = await Promise.all([getDocs(expensesQuery), getDocs(incomesQuery), getDocs(scansQuery), getDoc(doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories')), getDoc(doc(db, 'users', currentUser.uid, 'settings', 'budgets'))]);\n      const exportData = {\n        expenses: expensesSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        incomes: incomesSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        receiptScans: scansSnap.docs.map(doc => ({\n          id: doc.id,\n          ...doc.data()\n        })),\n        expenseCategories: categoriesSnap.exists() ? categoriesSnap.data().categories : DEFAULT_EXPENSE_CATEGORIES,\n        incomeCategories: incomeCategories,\n        budgets: budgetsSnap.exists() ? budgetsSnap.data() : {},\n        exportDate: new Date().toISOString(),\n        userId: currentUser.uid\n      };\n      return exportData;\n    } catch (error) {\n      console.error('Error exporting data:', error);\n      return null;\n    }\n  };\n\n  // Import data from backups\n  const importData = async data => {\n    if (!currentUser || !data) return false;\n    try {\n      // Validate data structure\n      if (!data.expenses || !data.incomes || !data.budgets || !data.expenseCategories || !data.incomeCategories) {\n        console.error('Invalid import data structure');\n        return false;\n      }\n\n      // Begin batch operations\n      const batch = db.batch();\n\n      // Update expense categories\n      const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n      batch.set(expenseCategoriesRef, {\n        categories: data.expenseCategories\n      });\n\n      // Update income categories\n      const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n      batch.set(incomeCategoriesRef, {\n        categories: data.incomeCategories\n      });\n\n      // Update budgets\n      const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n      batch.set(budgetsRef, data.budgets);\n\n      // Commit the batch\n      await batch.commit();\n\n      // Update local state\n      setExpenseCategories(data.expenseCategories);\n      setIncomeCategories(data.incomeCategories);\n      setBudgets(data.budgets);\n\n      // Handle expense and income imports separately (may be too many for a single batch)\n      for (const expense of data.expenses) {\n        try {\n          const {\n            id,\n            ...expenseData\n          } = expense;\n          expenseData.userId = currentUser.uid; // Ensure correct user ID\n          await addDoc(collection(db, 'expenses'), expenseData);\n        } catch (e) {\n          console.error('Error importing expense:', e);\n          // Continue with other imports\n        }\n      }\n      for (const income of data.incomes) {\n        try {\n          const {\n            id,\n            ...incomeData\n          } = income;\n          incomeData.userId = currentUser.uid; // Ensure correct user ID\n          await addDoc(collection(db, 'incomes'), incomeData);\n        } catch (e) {\n          console.error('Error importing income:', e);\n          // Continue with other imports\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error importing data:', error);\n      return false;\n    }\n  };\n\n  // Get spending insights\n  const getSpendingInsights = async (months = 3) => {\n    if (!currentUser || months < 1) return null;\n    try {\n      const currentDate = new Date();\n      const insights = {\n        topCategories: [],\n        monthlyTotals: [],\n        yearlyComparison: {},\n        receiptUsage: {\n          total: 0,\n          percentage: 0\n        }\n      };\n\n      // Get relevant expenses from Firestore\n      const startDate = new Date();\n      startDate.setMonth(startDate.getMonth() - months);\n\n      // Format for Firestore query\n      const startDateString = startDate.toISOString();\n      const expensesQuery = query(collection(db, 'expenses'), where('userId', '==', currentUser.uid), where('date', '>=', startDateString));\n      const expensesSnap = await getDocs(expensesQuery);\n      const relevantExpenses = expensesSnap.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n\n      // Calculate top spending categories\n      const categoryTotals = {};\n      relevantExpenses.forEach(expense => {\n        const {\n          category,\n          amount\n        } = expense;\n        if (!category) return;\n        categoryTotals[category] = (categoryTotals[category] || 0) + parseFloat(amount || 0);\n      });\n      insights.topCategories = Object.entries(categoryTotals).map(([category, total]) => ({\n        category,\n        total\n      })).sort((a, b) => b.total - a.total).slice(0, 5); // Get top 5\n\n      // Calculate monthly totals\n      const monthlyData = {};\n      relevantExpenses.forEach(expense => {\n        if (!expense.date) return;\n        const expenseDate = new Date(expense.date);\n        const monthYear = `${expenseDate.getFullYear()}-${expenseDate.getMonth() + 1}`;\n        if (!monthlyData[monthYear]) {\n          monthlyData[monthYear] = {\n            month: expenseDate.getMonth(),\n            year: expenseDate.getFullYear(),\n            total: 0,\n            label: expenseDate.toLocaleString('default', {\n              month: 'short',\n              year: 'numeric'\n            })\n          };\n        }\n        monthlyData[monthYear].total += parseFloat(expense.amount || 0);\n      });\n      insights.monthlyTotals = Object.values(monthlyData).sort((a, b) => {\n        if (a.year !== b.year) return a.year - b.year;\n        return a.month - b.month;\n      });\n\n      // Calculate receipt usage statistics\n      const receiptsCount = relevantExpenses.filter(expense => expense.fromReceipt).length;\n      insights.receiptUsage = {\n        total: receiptsCount,\n        percentage: relevantExpenses.length > 0 ? receiptsCount / relevantExpenses.length * 100 : 0\n      };\n      return insights;\n    } catch (error) {\n      console.error('Error generating spending insights:', error);\n      return null;\n    }\n  };\n\n  // Load categories and other settings from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setExpenseCategories([]);\n      setIncomeCategories([]);\n      setBudgets({});\n      return;\n    }\n\n    // Load categories and budgets\n    const fetchSettings = async () => {\n      try {\n        // Get expense categories\n        const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\n        const expenseCategoriesDoc = await getDoc(expenseCategoriesRef);\n        if (expenseCategoriesDoc.exists()) {\n          setExpenseCategories(expenseCategoriesDoc.data().categories || DEFAULT_EXPENSE_CATEGORIES);\n        } else {\n          // Create default categories if none exist\n          await setDoc(expenseCategoriesRef, {\n            categories: DEFAULT_EXPENSE_CATEGORIES\n          });\n          setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\n        }\n\n        // Get income categories\n        const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\n        const incomeCategoriesDoc = await getDoc(incomeCategoriesRef);\n        if (incomeCategoriesDoc.exists()) {\n          setIncomeCategories(incomeCategoriesDoc.data().categories || DEFAULT_INCOME_CATEGORIES);\n        } else {\n          // Create default categories if none exist\n          await setDoc(incomeCategoriesRef, {\n            categories: DEFAULT_INCOME_CATEGORIES\n          });\n          setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\n        }\n\n        // Get budgets\n        const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\n        const budgetsDoc = await getDoc(budgetsRef);\n        if (budgetsDoc.exists()) {\n          setBudgets(budgetsDoc.data());\n        }\n      } catch (error) {\n        console.error('Error loading settings:', error);\n        setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\n        setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\n      }\n    };\n    fetchSettings();\n  }, [currentUser]);\n\n  // Load alerts from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setAlerts([]);\n      return;\n    }\n\n    // Query Firestore for alerts\n    const alertsQuery = query(collection(db, 'alerts'), where('userId', '==', currentUser.uid), where('read', '==', false));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(alertsQuery, snapshot => {\n      const alertsList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setAlerts(alertsList);\n    }, error => {\n      console.error(\"Error getting alerts:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n\n  // Load receipt scans from Firestore\n  useEffect(() => {\n    if (!currentUser) {\n      setReceiptScans([]);\n      return;\n    }\n\n    // Query Firestore for receipt scans\n    const scansQuery = query(collection(db, 'receiptScans'), where('userId', '==', currentUser.uid));\n\n    // Set up real-time listener\n    const unsubscribe = onSnapshot(scansQuery, snapshot => {\n      const scansList = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setReceiptScans(scansList);\n    }, error => {\n      console.error(\"Error getting receipt scans:\", error);\n    });\n    return () => unsubscribe();\n  }, [currentUser]);\n  return /*#__PURE__*/_jsxDEV(ExpenseContext.Provider, {\n    value: {\n      expenses,\n      incomes,\n      budgets,\n      alerts,\n      expenseCategories,\n      incomeCategories,\n      receiptScanStatus,\n      receiptScans,\n      emailStatus,\n      loading,\n      addExpense,\n      addIncome,\n      deleteExpense,\n      deleteIncome,\n      updateExpense,\n      updateIncome,\n      updateBudget,\n      deleteBudget,\n      markAlertAsRead,\n      deleteAlert,\n      addExpenseCategory,\n      deleteExpenseCategory,\n      editExpenseCategory,\n      addIncomeCategory,\n      deleteIncomeCategory,\n      editIncomeCategory,\n      scanReceipt,\n      addExpenseFromReceipt,\n      rejectScannedReceipt,\n      getMonthlyExpenses,\n      getMonthlyIncomes,\n      getReceiptScans,\n      exportData,\n      importData,\n      getSpendingInsights\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1414,\n    columnNumber: 5\n  }, this);\n};\n_s(ExpenseProvider, \"jN6mlIMGqoim1aOMvmQUTdySb1Y=\");\n_c = ExpenseProvider;\nvar _c;\n$RefreshReg$(_c, \"ExpenseProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","AuthContext","sendBudgetAlertEmail","scanReceiptImage","parseReceiptData","db","storage","collection","addDoc","doc","deleteDoc","updateDoc","query","where","getDocs","onSnapshot","getDoc","setDoc","limit","ref","uploadBytes","getDownloadURL","jsxDEV","_jsxDEV","ExpenseContext","ExpenseProvider","children","_s","expenses","setExpenses","incomes","setIncomes","budgets","setBudgets","alerts","setAlerts","loading","setLoading","emailStatus","setEmailStatus","sent","error","expenseCategories","setExpenseCategories","incomeCategories","setIncomeCategories","receiptScanStatus","setReceiptScanStatus","scanning","data","receiptScans","setReceiptScans","currentUser","DEFAULT_EXPENSE_CATEGORIES","DEFAULT_INCOME_CATEGORIES","expensesQuery","uid","unsubscribe","snapshot","expensesList","docs","map","id","console","incomesQuery","incomesList","timer","setTimeout","clearTimeout","prevState","addExpense","expense","log","category","amount","parseFloat","isNaN","receiptImageUrl","receiptImage","File","storageRef","Date","now","name","newExpense","date","toISOString","slice","description","userId","createdAt","fromReceipt","receiptScanId","expensesCollection","docRef","checkBudgetAlerts","code","message","scanReceipt","imageFile","success","_parsedData$items","scanResult","errorMessage","parsedData","scanId","scanRecord","rawData","status","imageUrl","extractedExpense","merchantName","mapVendorToCategory","notes","items","length","join","addExpenseFromReceipt","expenseData","modifications","finalExpenseData","result","scanRef","String","rejectScannedReceipt","_receiptScanStatus$da","vendorName","vendorNameLower","toLowerCase","categoryMappings","keyword","Object","entries","includes","addIncome","income","source","newIncome","deleteExpense","expenseRef","expenseSnap","exists","scanSnap","deleteIncome","updateBudget","trim","budgetRef","budgetDoc","prevBudgets","deleteBudget","currentBudgets","undefined","allExpenses","currentDate","currentMonth","getMonth","currentYear","getFullYear","monthlyExpenses","filter","expenseDate","e","totalSpent","reduce","sum","budgetAmount","_currentUser$preferen","newAlert","toFixed","read","alertRef","preferences","emailNotifications","email","then","catch","markAlertAsRead","deleteAlert","addExpenseCategory","categoriesRef","categoriesDoc","updatedCategories","currentCategories","categories","deleteExpenseCategory","expensesSnap","empty","reason","cat","editExpenseCategory","oldCategory","newCategory","addIncomeCategory","deleteIncomeCategory","incomesSnap","editIncomeCategory","getMonthlyExpenses","month","year","targetDate","targetMonth","targetYear","getMonthlyIncomes","incomeDate","getReceiptScans","scansQuery","scansSnap","updateExpense","updatedData","updateIncome","incomeRef","exportData","categoriesSnap","budgetsSnap","Promise","all","exportDate","importData","batch","expenseCategoriesRef","set","incomeCategoriesRef","budgetsRef","commit","incomeData","getSpendingInsights","months","insights","topCategories","monthlyTotals","yearlyComparison","receiptUsage","total","percentage","startDate","setMonth","startDateString","relevantExpenses","categoryTotals","forEach","sort","a","b","monthlyData","monthYear","label","toLocaleString","values","receiptsCount","fetchSettings","expenseCategoriesDoc","incomeCategoriesDoc","budgetsDoc","alertsQuery","alertsList","scansList","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/tejit/OneDrive/Desktop/expence tracker final/expence-tracker/src/context/ExpenseContext.js"],"sourcesContent":["// src/context/ExpenseContext.js\r\nimport React, { createContext, useState, useEffect, useContext } from 'react';\r\nimport { AuthContext } from './AuthContext';\r\nimport { sendBudgetAlertEmail } from '../services/EmailService';\r\nimport { scanReceiptImage, parseReceiptData } from '../services/ReceiptScanningService';\r\n// Add Firebase imports\r\nimport { db, storage } from '../config/firebase';\r\nimport { \r\n  collection, \r\n  addDoc, \r\n  doc, \r\n  deleteDoc, \r\n  updateDoc, \r\n  query, \r\n  where, \r\n  getDocs, \r\n  onSnapshot, \r\n  getDoc,\r\n  setDoc,\r\n  limit \r\n} from 'firebase/firestore';\r\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\r\n\r\nexport const ExpenseContext = createContext();\r\n\r\nexport const ExpenseProvider = ({ children }) => {\r\n  const [expenses, setExpenses] = useState([]);\r\n  const [incomes, setIncomes] = useState([]);\r\n  const [budgets, setBudgets] = useState({});\r\n  const [alerts, setAlerts] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [emailStatus, setEmailStatus] = useState({ sent: false, error: null });\r\n  const [expenseCategories, setExpenseCategories] = useState([]);\r\n  const [incomeCategories, setIncomeCategories] = useState([]);\r\n  // Add new state for receipt scanning\r\n  const [receiptScanStatus, setReceiptScanStatus] = useState({ \r\n    scanning: false, \r\n    error: null, \r\n    data: null \r\n  });\r\n  // Track receipt scan history\r\n  const [receiptScans, setReceiptScans] = useState([]);\r\n  \r\n  const { currentUser } = useContext(AuthContext);\r\n  \r\n  // Default categories if none are found\r\n  const DEFAULT_EXPENSE_CATEGORIES = [\r\n    'Food', 'Housing', 'Transportation', 'Entertainment', \r\n    'Utilities', 'Healthcare', 'Shopping', 'Personal Care', 'Education', 'Other'\r\n  ];\r\n  \r\n  const DEFAULT_INCOME_CATEGORIES = [\r\n    'Salary', 'Freelance', 'Investment', 'Gift', \r\n    'Business', 'Side Hustle', 'Rental', 'Other'\r\n  ];\r\n  \r\n  // Load expenses from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setExpenses([]);\r\n      setLoading(false);\r\n      return;\r\n    }\r\n    \r\n    setLoading(true);\r\n    \r\n    // Query Firestore for expenses\r\n    const expensesQuery = query(\r\n      collection(db, 'expenses'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(expensesQuery, (snapshot) => {\r\n      const expensesList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setExpenses(expensesList);\r\n      setLoading(false);\r\n    }, (error) => {\r\n      console.error(\"Error getting expenses:\", error);\r\n      setLoading(false);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Load incomes from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setIncomes([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for incomes\r\n    const incomesQuery = query(\r\n      collection(db, 'incomes'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(incomesQuery, (snapshot) => {\r\n      const incomesList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setIncomes(incomesList);\r\n    }, (error) => {\r\n      console.error(\"Error getting incomes:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Clear email status after some time\r\n  useEffect(() => {\r\n    if (emailStatus.sent || emailStatus.error) {\r\n      const timer = setTimeout(() => {\r\n        setEmailStatus({ sent: false, error: null });\r\n      }, 5000);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [emailStatus]);\r\n  \r\n  // Clear receipt scan data after processing\r\n  useEffect(() => {\r\n    if (receiptScanStatus.data && !receiptScanStatus.scanning) {\r\n      const timer = setTimeout(() => {\r\n        setReceiptScanStatus(prevState => ({\r\n          ...prevState, \r\n          data: null\r\n        }));\r\n      }, 30000); // Give user 30 seconds to review before clearing\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [receiptScanStatus]);\r\n  \r\n  // Add a new expense with validation\r\n  // Updated addExpense function for ExpenseContext.js\r\n  const addExpense = async (expense) => {\r\n    if (!currentUser) {\r\n      console.error('Cannot add expense: No authenticated user');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      console.log('Starting expense creation with data:', expense);\r\n      \r\n      // Validate expense data\r\n      if (!expense.category) {\r\n        console.error('Missing category in expense');\r\n        return false;\r\n      }\r\n      \r\n      const amount = parseFloat(expense.amount);\r\n      if (isNaN(amount) || amount <= 0) {\r\n        console.error('Invalid expense amount:', expense.amount);\r\n        return false;\r\n      }\r\n      \r\n      // Handle receipt image if present\r\n      let receiptImageUrl = expense.receiptImageUrl || null;\r\n      if (expense.receiptImage instanceof File) {\r\n        console.log('Uploading receipt image...');\r\n        const storageRef = ref(storage, `receipts/${currentUser.uid}/${Date.now()}_${expense.receiptImage.name}`);\r\n        await uploadBytes(storageRef, expense.receiptImage);\r\n        receiptImageUrl = await getDownloadURL(storageRef);\r\n        console.log('Receipt image uploaded, URL:', receiptImageUrl);\r\n      }\r\n      \r\n      // Create new expense object with proper types and defaults\r\n      const newExpense = {\r\n        category: expense.category,\r\n        amount: amount,\r\n        date: expense.date || new Date().toISOString().slice(0, 10),\r\n        description: expense.description || '',\r\n        userId: currentUser.uid,\r\n        createdAt: new Date().toISOString(),\r\n        fromReceipt: expense.fromReceipt || false,\r\n        receiptImageUrl,\r\n        receiptScanId: expense.receiptScanId || null\r\n      };\r\n      \r\n      console.log('Formatted expense object:', newExpense);\r\n      \r\n      // Delete any properties we don't want to store\r\n      delete newExpense.receiptImage;\r\n      \r\n      // Log the collection reference and ensure Firestore is connected\r\n      const expensesCollection = collection(db, 'expenses');\r\n      console.log('Expenses collection reference:', expensesCollection);\r\n      \r\n      // Add to Firestore\r\n      console.log('Adding expense to Firestore...');\r\n      const docRef = await addDoc(expensesCollection, newExpense);\r\n      console.log('Expense added to Firestore, ID:', docRef.id);\r\n      \r\n      // Check for budget alerts\r\n      await checkBudgetAlerts({\r\n        ...newExpense,\r\n        id: docRef.id\r\n      });\r\n      \r\n      return docRef.id;\r\n    } catch (error) {\r\n      console.error('Error adding expense:', error);\r\n      console.error('Error code:', error.code);\r\n      console.error('Error message:', error.message);\r\n      \r\n      // Check for specific Firebase errors\r\n      if (error.code === 'permission-denied') {\r\n        console.error('Firebase permission denied. Check Firestore rules.');\r\n      } else if (error.code === 'unavailable') {\r\n        console.error('Firebase service unavailable. Check internet connection.');\r\n      } else if (error.code === 'unauthenticated') {\r\n        console.error('User is not authenticated with Firebase.');\r\n      }\r\n      \r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // New function to handle receipt scanning\r\n  const scanReceipt = async (imageFile) => {\r\n    if (!currentUser) return { success: false, error: 'User not logged in' };\r\n    if (!imageFile) {\r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: 'No image provided',\r\n        data: null\r\n      });\r\n      return { success: false, error: 'No image provided' };\r\n    }\r\n    \r\n    try {\r\n      // Set scanning status\r\n      setReceiptScanStatus({\r\n        scanning: true,\r\n        error: null,\r\n        data: null\r\n      });\r\n      \r\n      // Call the receipt scanning service\r\n      const scanResult = await scanReceiptImage(imageFile);\r\n      \r\n      if (!scanResult || !scanResult.success) {\r\n        const errorMessage = scanResult?.error || 'Failed to scan receipt';\r\n        setReceiptScanStatus({\r\n          scanning: false,\r\n          error: errorMessage,\r\n          data: null\r\n        });\r\n        \r\n        return { success: false, error: errorMessage };\r\n      }\r\n      \r\n      // Process the scanned data\r\n      const parsedData = parseReceiptData(scanResult);\r\n      \r\n      if (!parsedData) {\r\n        setReceiptScanStatus({\r\n          scanning: false,\r\n          error: 'Failed to parse receipt data',\r\n          data: null\r\n        });\r\n        \r\n        return { success: false, error: 'Failed to parse receipt data' };\r\n      }\r\n      \r\n      // Create a scan record\r\n      const scanId = Date.now();\r\n      const scanRecord = {\r\n        id: scanId,\r\n        date: new Date().toISOString(),\r\n        rawData: scanResult,\r\n        parsedData: parsedData,\r\n        userId: currentUser.uid,\r\n        status: 'pending', // pending, applied, rejected\r\n        imageUrl: scanResult.imageUrl\r\n      };\r\n      \r\n      // Store the scan record in Firestore\r\n      await addDoc(collection(db, 'receiptScans'), scanRecord);\r\n      \r\n      // Prepare the extracted data for the UI\r\n      const extractedExpense = {\r\n        amount: parsedData.amount,\r\n        description: parsedData.merchantName || 'Receipt expense',\r\n        category: mapVendorToCategory(parsedData.merchantName || ''),\r\n        date: parsedData.date || new Date().toISOString().slice(0, 10),\r\n        fromReceipt: true,\r\n        receiptImageUrl: parsedData.imageUrl || null,\r\n        receiptScanId: scanId,\r\n        notes: `Receipt from ${parsedData.merchantName || 'unknown vendor'}${parsedData.items?.length > 0 ? `, Items: ${parsedData.items.join(', ')}` : ''}`\r\n      };\r\n      \r\n      // Update scan status with the extracted data\r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: null,\r\n        data: extractedExpense\r\n      });\r\n      \r\n      return {\r\n        success: true,\r\n        data: extractedExpense,\r\n        scanId\r\n      };\r\n    } catch (error) {\r\n      console.error('Error scanning receipt:', error);\r\n      \r\n      setReceiptScanStatus({\r\n        scanning: false,\r\n        error: error.message || 'Error scanning receipt',\r\n        data: null\r\n      });\r\n      \r\n      return {\r\n        success: false,\r\n        error: error.message || 'Error scanning receipt'\r\n      };\r\n    }\r\n  };\r\n  \r\n  // Function to add the expense from a scanned receipt\r\n  const addExpenseFromReceipt = async (expenseData, modifications = {}) => {\r\n    if (!currentUser) return false;\r\n    \r\n    try {\r\n      // Combine scanned data with any user modifications\r\n      const finalExpenseData = {\r\n        ...expenseData,\r\n        ...modifications,\r\n        fromReceipt: true\r\n      };\r\n      \r\n      // Use the existing addExpense function\r\n      const result = await addExpense(finalExpenseData);\r\n      \r\n      if (result && finalExpenseData.receiptScanId) {\r\n        // Update the scan record status in Firestore\r\n        const scanRef = doc(db, 'receiptScans', String(finalExpenseData.receiptScanId));\r\n        await updateDoc(scanRef, { status: 'applied' });\r\n        \r\n        // Clear the scanned data after successful addition\r\n        setReceiptScanStatus(prevState => ({\r\n          ...prevState,\r\n          data: null\r\n        }));\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('Error adding expense from receipt:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Function to reject a scanned receipt\r\n  const rejectScannedReceipt = async (scanId) => {\r\n    if (!scanId) return false;\r\n    \r\n    try {\r\n      // Update the scan record status in Firestore\r\n      const scanRef = doc(db, 'receiptScans', String(scanId));\r\n      await updateDoc(scanRef, { status: 'rejected' });\r\n      \r\n      // Clear any pending scan data with this ID\r\n      if (receiptScanStatus.data?.receiptScanId === scanId) {\r\n        setReceiptScanStatus({\r\n          scanning: false,\r\n          error: null,\r\n          data: null\r\n        });\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error rejecting scanned receipt:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Helper function to map vendor names to appropriate categories\r\n  const mapVendorToCategory = (vendorName) => {\r\n    const vendorNameLower = vendorName.toLowerCase();\r\n    \r\n    // Simple mapping logic - can be expanded based on common vendors\r\n    if (!vendorName) return 'Other';\r\n    \r\n    const categoryMappings = {\r\n      'restaurant': 'Food',\r\n      'cafÃ©': 'Food',\r\n      'cafe': 'Food',\r\n      'grocery': 'Food',\r\n      'supermarket': 'Food',\r\n      'market': 'Food',\r\n      'gas': 'Transportation',\r\n      'fuel': 'Transportation',\r\n      'uber': 'Transportation',\r\n      'lyft': 'Transportation',\r\n      'taxi': 'Transportation',\r\n      'pharmacy': 'Healthcare',\r\n      'drug': 'Healthcare',\r\n      'doctor': 'Healthcare',\r\n      'clinic': 'Healthcare',\r\n      'hospital': 'Healthcare',\r\n      'rent': 'Housing',\r\n      'mortgage': 'Housing',\r\n      'netflix': 'Entertainment',\r\n      'spotify': 'Entertainment',\r\n      'cinema': 'Entertainment',\r\n      'movie': 'Entertainment',\r\n      'theater': 'Entertainment',\r\n      'amazon': 'Shopping',\r\n      'walmart': 'Shopping',\r\n      'target': 'Shopping',\r\n      'utility': 'Utilities',\r\n      'electric': 'Utilities',\r\n      'water': 'Utilities',\r\n      'gas bill': 'Utilities',\r\n      'phone': 'Utilities',\r\n      'internet': 'Utilities',\r\n      'school': 'Education',\r\n      'college': 'Education',\r\n      'university': 'Education',\r\n      'tuition': 'Education',\r\n      'book': 'Education',\r\n      'haircut': 'Personal Care',\r\n      'salon': 'Personal Care',\r\n      'spa': 'Personal Care',\r\n      'gym': 'Personal Care'\r\n    };\r\n    \r\n    for (const [keyword, category] of Object.entries(categoryMappings)) {\r\n      if (vendorNameLower.includes(keyword)) {\r\n        return category;\r\n      }\r\n    }\r\n    \r\n    return 'Other';\r\n  };\r\n  \r\n  // Add a new income with validation\r\n  const addIncome = async (income) => {\r\n    if (!currentUser) return false;\r\n    \r\n    try {\r\n      // Validate income data\r\n      if (!income.source) {\r\n        console.error('Missing source in income');\r\n        return false;\r\n      }\r\n      \r\n      const amount = parseFloat(income.amount);\r\n      if (isNaN(amount) || amount <= 0) {\r\n        console.error('Invalid income amount:', income.amount);\r\n        return false;\r\n      }\r\n      \r\n      // Create new income object\r\n      const newIncome = {\r\n        ...income,\r\n        amount,\r\n        date: income.date || new Date().toISOString().slice(0, 10),\r\n        userId: currentUser.uid,\r\n        createdAt: new Date().toISOString()\r\n      };\r\n      \r\n      // Add to Firestore\r\n      const docRef = await addDoc(collection(db, 'incomes'), newIncome);\r\n      \r\n      return docRef.id;\r\n    } catch (error) {\r\n      console.error('Error adding income:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an expense\r\n  const deleteExpense = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      // Get the expense before deleting it (to check for receipt info)\r\n      const expenseRef = doc(db, 'expenses', id);\r\n      const expenseSnap = await getDoc(expenseRef);\r\n      \r\n      if (expenseSnap.exists()) {\r\n        const expenseData = expenseSnap.data();\r\n        \r\n        // Delete the expense document\r\n        await deleteDoc(expenseRef);\r\n        \r\n        // If this was a receipt-based expense, update the scan record\r\n        if (expenseData.receiptScanId) {\r\n          const scanRef = doc(db, 'receiptScans', String(expenseData.receiptScanId));\r\n          const scanSnap = await getDoc(scanRef);\r\n          \r\n          if (scanSnap.exists()) {\r\n            await updateDoc(scanRef, { status: 'rejected' });\r\n          }\r\n        }\r\n      } else {\r\n        // Document not found\r\n        console.error('Expense not found');\r\n        return false;\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an income\r\n  const deleteIncome = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      await deleteDoc(doc(db, 'incomes', id));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting income:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Update budget settings\r\n  const updateBudget = async (category, amount) => {\r\n    if (!currentUser || !category || category.trim() === '' || isNaN(parseFloat(amount))) {\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        // Update existing budgets document\r\n        await updateDoc(budgetRef, {\r\n          [category]: parseFloat(amount)\r\n        });\r\n      } else {\r\n        // Create new budgets document\r\n        await setDoc(budgetRef, {\r\n          [category]: parseFloat(amount)\r\n        });\r\n      }\r\n      \r\n      // Update local state\r\n      setBudgets(prevBudgets => ({\r\n        ...prevBudgets,\r\n        [category]: parseFloat(amount)\r\n      }));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating budget:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete a budget\r\n  const deleteBudget = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        // Remove the category from the budgets\r\n        if (currentBudgets[category] !== undefined) {\r\n          delete currentBudgets[category];\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting budget:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Check if adding this expense exceeds the budget\r\n  const checkBudgetAlerts = async (newExpense, allExpenses = expenses) => {\r\n    if (!currentUser) return; // Don't process if no user is logged in\r\n    if (!newExpense || !newExpense.category) return;\r\n    \r\n    const { category } = newExpense;\r\n    \r\n    // Get budgets from Firestore\r\n    try {\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (!budgetDoc.exists()) return;\r\n      \r\n      const budgets = budgetDoc.data();\r\n      \r\n      // Check if there's a budget for this category\r\n      if (budgets[category]) {\r\n        // Get current month expenses for this category\r\n        const currentDate = new Date();\r\n        const currentMonth = currentDate.getMonth();\r\n        const currentYear = currentDate.getFullYear();\r\n        \r\n        const monthlyExpenses = allExpenses.filter(expense => {\r\n          if (!expense.date) return false;\r\n          \r\n          try {\r\n            const expenseDate = new Date(expense.date);\r\n            return expenseDate.getMonth() === currentMonth && \r\n                  expenseDate.getFullYear() === currentYear &&\r\n                  expense.category === category &&\r\n                  expense.userId === currentUser.uid;\r\n          } catch (e) {\r\n            console.error('Invalid date format:', expense.date);\r\n            return false;\r\n          }\r\n        });\r\n        \r\n        const totalSpent = monthlyExpenses.reduce((sum, expense) => {\r\n          const amount = parseFloat(expense.amount);\r\n          return sum + (isNaN(amount) ? 0 : amount);\r\n        }, 0);\r\n        \r\n        const budgetAmount = parseFloat(budgets[category]);\r\n        \r\n        if (!isNaN(budgetAmount) && totalSpent > budgetAmount) {\r\n          // Create new alert\r\n          const newAlert = {\r\n            message: `Budget alert: You've exceeded your ${category} budget of $${budgetAmount.toFixed(2)}`,\r\n            category: category,\r\n            read: false,\r\n            date: new Date().toISOString(),\r\n            userId: currentUser.uid\r\n          };\r\n          \r\n          // Add to Firestore\r\n          const alertRef = await addDoc(collection(db, 'alerts'), newAlert);\r\n          \r\n          // Send email alert if user has enabled email notifications\r\n          if (currentUser?.preferences?.emailNotifications !== false) {\r\n            if (currentUser.email) {\r\n              sendBudgetAlertEmail(\r\n                currentUser,\r\n                category,\r\n                budgetAmount,\r\n                totalSpent\r\n              ).then(result => {\r\n                setEmailStatus({ \r\n                  sent: result.success, \r\n                  error: result.success ? null : result.message \r\n                });\r\n              }).catch(error => {\r\n                setEmailStatus({ \r\n                  sent: false, \r\n                  error: error.message || 'Error sending email'\r\n                });\r\n              });\r\n            } else {\r\n              setEmailStatus({ \r\n                sent: false, \r\n                error: \"No email address found for user\"\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error checking budget alerts:', error);\r\n    }\r\n  };\r\n  \r\n  // Mark an alert as read\r\n  const markAlertAsRead = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const alertRef = doc(db, 'alerts', id);\r\n      await updateDoc(alertRef, { read: true });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error marking alert as read:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an alert\r\n  const deleteAlert = async (id) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      await deleteDoc(doc(db, 'alerts', id));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting alert:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Add a new expense category\r\n  const addExpenseCategory = async (category) => {\r\n    if (!currentUser || !category || category.trim() === '') return false;\r\n    \r\n    try {\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      let updatedCategories;\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        \r\n        // Check if category already exists\r\n        if (currentCategories.includes(category)) {\r\n          return false;\r\n        }\r\n        \r\n        updatedCategories = [...currentCategories, category];\r\n      } else {\r\n        updatedCategories = [...DEFAULT_EXPENSE_CATEGORIES, category];\r\n      }\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setExpenseCategories(updatedCategories);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error adding expense category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an expense category\r\n  const deleteExpenseCategory = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      // Don't delete if there are expenses using this category\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('category', '==', category),\r\n        limit(1)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      if (!expensesSnap.empty) {\r\n        return { success: false, reason: 'Category in use by existing expenses' };\r\n      }\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\r\n        \r\n        // Update Firestore\r\n        await setDoc(categoriesRef, { categories: updatedCategories });\r\n        \r\n        // Update local state\r\n        setExpenseCategories(updatedCategories);\r\n      }\r\n      \r\n      // Also remove any budgets for this category\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        if (currentBudgets[category] !== undefined) {\r\n          delete currentBudgets[category];\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Error deleting expense category:', error);\r\n      return { success: false, reason: error.message };\r\n    }\r\n  };\r\n  \r\n  // Edit an expense category\r\n  const editExpenseCategory = async (oldCategory, newCategory) => {\r\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\r\n    \r\n    try {\r\n      // Don't allow editing the \"Other\" category\r\n      if (oldCategory === 'Other') return false;\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (!categoriesDoc.exists()) return false;\r\n      \r\n      const currentCategories = categoriesDoc.data().categories || [];\r\n      \r\n      // Check if the new category name already exists\r\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\r\n      \r\n      // Check if the category is in use\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('category', '==', oldCategory),\r\n        limit(1)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      if (!expensesSnap.empty) return false;\r\n      \r\n      // Update categories\r\n      const updatedCategories = currentCategories.map(cat => \r\n        cat === oldCategory ? newCategory : cat\r\n      );\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setExpenseCategories(updatedCategories);\r\n      \r\n      // Update any budget for this category\r\n      const budgetRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      const budgetDoc = await getDoc(budgetRef);\r\n      \r\n      if (budgetDoc.exists()) {\r\n        const currentBudgets = budgetDoc.data();\r\n        \r\n        if (currentBudgets[oldCategory] !== undefined) {\r\n          const budgetAmount = currentBudgets[oldCategory];\r\n          delete currentBudgets[oldCategory];\r\n          currentBudgets[newCategory] = budgetAmount;\r\n          \r\n          // Update Firestore\r\n          await setDoc(budgetRef, currentBudgets);\r\n          \r\n          // Update local state\r\n          setBudgets(currentBudgets);\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error editing expense category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Add a new income category\r\n  const addIncomeCategory = async (category) => {\r\n    if (!currentUser || !category || category.trim() === '') return false;\r\n    \r\n    try {\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      let updatedCategories;\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        \r\n        // Check if category already exists\r\n        if (currentCategories.includes(category)) {\r\n          return false;\r\n        }\r\n        \r\n        updatedCategories = [...currentCategories, category];\r\n      } else {\r\n        updatedCategories = [...DEFAULT_INCOME_CATEGORIES, category];\r\n      }\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setIncomeCategories(updatedCategories);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error adding income category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Delete an income category\r\n  const deleteIncomeCategory = async (category) => {\r\n    if (!currentUser || !category) return false;\r\n    \r\n    try {\r\n      // Don't delete if there are incomes using this category\r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('source', '==', category),\r\n        limit(1)\r\n      );\r\n      \r\n      const incomesSnap = await getDocs(incomesQuery);\r\n      \r\n      if (!incomesSnap.empty) {\r\n        return { success: false, reason: 'Category in use by existing incomes' };\r\n      }\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (categoriesDoc.exists()) {\r\n        const currentCategories = categoriesDoc.data().categories || [];\r\n        const updatedCategories = currentCategories.filter(cat => cat !== category);\r\n        \r\n        // Update Firestore\r\n        await setDoc(categoriesRef, { categories: updatedCategories });\r\n        \r\n        // Update local state\r\n        setIncomeCategories(updatedCategories);\r\n      }\r\n      \r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Error deleting income category:', error);\r\n      return { success: false, reason: error.message };\r\n    }\r\n  };\r\n  \r\n  // Edit an income category\r\n  const editIncomeCategory = async (oldCategory, newCategory) => {\r\n    if (!currentUser || !oldCategory || !newCategory || newCategory.trim() === '') return false;\r\n    \r\n    try {\r\n      // Don't allow editing the \"Other\" category\r\n      if (oldCategory === 'Other') return false;\r\n      \r\n      // Get current categories\r\n      const categoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      const categoriesDoc = await getDoc(categoriesRef);\r\n      \r\n      if (!categoriesDoc.exists()) return false;\r\n      \r\n      const currentCategories = categoriesDoc.data().categories || [];\r\n      \r\n      // Check if the new category name already exists\r\n      if (currentCategories.includes(newCategory) && newCategory !== oldCategory) return false;\r\n      \r\n      // Check if the category is in use\r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('source', '==', oldCategory),\r\n        limit(1)\r\n      );\r\n      \r\n      const incomesSnap = await getDocs(incomesQuery);\r\n      \r\n      if (!incomesSnap.empty) return false;\r\n      \r\n      // Update categories\r\n      const updatedCategories = currentCategories.map(cat => \r\n        cat === oldCategory ? newCategory : cat\r\n      );\r\n      \r\n      // Update Firestore\r\n      await setDoc(categoriesRef, { categories: updatedCategories });\r\n      \r\n      // Update local state\r\n      setIncomeCategories(updatedCategories);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error editing income category:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Get expenses for a specific month\r\n  const getMonthlyExpenses = (month, year) => {\r\n    if (!currentUser) return [];\r\n    \r\n    const targetDate = new Date(year, month);\r\n    const targetMonth = targetDate.getMonth();\r\n    const targetYear = targetDate.getFullYear();\r\n    \r\n    return expenses.filter(expense => {\r\n      if (!expense.date) return false;\r\n      \r\n      try {\r\n        const expenseDate = new Date(expense.date);\r\n        return expenseDate.getMonth() === targetMonth && \r\n              expenseDate.getFullYear() === targetYear &&\r\n              expense.userId === currentUser.uid;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    });\r\n  };\r\n  \r\n  // Get incomes for a specific month\r\n  const getMonthlyIncomes = (month, year) => {\r\n    if (!currentUser) return [];\r\n    \r\n    const targetDate = new Date(year, month);\r\n    const targetMonth = targetDate.getMonth();\r\n    const targetYear = targetDate.getFullYear();\r\n    \r\n    return incomes.filter(income => {\r\n      if (!income.date) return false;\r\n      \r\n      try {\r\n        const incomeDate = new Date(income.date);\r\n        return incomeDate.getMonth() === targetMonth && \r\n              incomeDate.getFullYear() === targetYear &&\r\n              income.userId === currentUser.uid;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    });\r\n  };\r\n  \r\n  // Get historical receipt scans\r\n  const getReceiptScans = async () => {\r\n    if (!currentUser) return [];\r\n    \r\n    try {\r\n      const scansQuery = query(\r\n        collection(db, 'receiptScans'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const scansSnap = await getDocs(scansQuery);\r\n      \r\n      return scansSnap.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error getting receipt scans:', error);\r\n      return [];\r\n    }\r\n  };\r\n  \r\n  // Update an existing expense\r\n  const updateExpense = async (id, updatedData) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const expenseRef = doc(db, 'expenses', id);\r\n      await updateDoc(expenseRef, updatedData);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating expense:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Update an existing income\r\n  const updateIncome = async (id, updatedData) => {\r\n    if (!currentUser || !id) return false;\r\n    \r\n    try {\r\n      const incomeRef = doc(db, 'incomes', id);\r\n      await updateDoc(incomeRef, updatedData);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating income:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Export data for backups\r\n  const exportData = async () => {\r\n    if (!currentUser) return null;\r\n    \r\n    try {\r\n      // Get all current user data\r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const incomesQuery = query(\r\n        collection(db, 'incomes'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const scansQuery = query(\r\n        collection(db, 'receiptScans'),\r\n        where('userId', '==', currentUser.uid)\r\n      );\r\n      \r\n      const [expensesSnap, incomesSnap, scansSnap, categoriesSnap, budgetsSnap] = await Promise.all([\r\n        getDocs(expensesQuery),\r\n        getDocs(incomesQuery),\r\n        getDocs(scansQuery),\r\n        getDoc(doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories')),\r\n        getDoc(doc(db, 'users', currentUser.uid, 'settings', 'budgets'))\r\n      ]);\r\n      \r\n      const exportData = {\r\n        expenses: expensesSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        incomes: incomesSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        receiptScans: scansSnap.docs.map(doc => ({id: doc.id, ...doc.data()})),\r\n        expenseCategories: categoriesSnap.exists() ? categoriesSnap.data().categories : DEFAULT_EXPENSE_CATEGORIES,\r\n        incomeCategories: incomeCategories,\r\n        budgets: budgetsSnap.exists() ? budgetsSnap.data() : {},\r\n        exportDate: new Date().toISOString(),\r\n        userId: currentUser.uid\r\n      };\r\n      \r\n      return exportData;\r\n    } catch (error) {\r\n      console.error('Error exporting data:', error);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  // Import data from backups\r\n  const importData = async (data) => {\r\n    if (!currentUser || !data) return false;\r\n    \r\n    try {\r\n      // Validate data structure\r\n      if (!data.expenses || !data.incomes || !data.budgets || \r\n          !data.expenseCategories || !data.incomeCategories) {\r\n        console.error('Invalid import data structure');\r\n        return false;\r\n      }\r\n      \r\n      // Begin batch operations\r\n      const batch = db.batch();\r\n      \r\n      // Update expense categories\r\n      const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n      batch.set(expenseCategoriesRef, { categories: data.expenseCategories });\r\n      \r\n      // Update income categories\r\n      const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n      batch.set(incomeCategoriesRef, { categories: data.incomeCategories });\r\n      \r\n      // Update budgets\r\n      const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n      batch.set(budgetsRef, data.budgets);\r\n      \r\n      // Commit the batch\r\n      await batch.commit();\r\n      \r\n      // Update local state\r\n      setExpenseCategories(data.expenseCategories);\r\n      setIncomeCategories(data.incomeCategories);\r\n      setBudgets(data.budgets);\r\n      \r\n      // Handle expense and income imports separately (may be too many for a single batch)\r\n      for (const expense of data.expenses) {\r\n        try {\r\n          const { id, ...expenseData } = expense;\r\n          expenseData.userId = currentUser.uid; // Ensure correct user ID\r\n          await addDoc(collection(db, 'expenses'), expenseData);\r\n        } catch (e) {\r\n          console.error('Error importing expense:', e);\r\n          // Continue with other imports\r\n        }\r\n      }\r\n      \r\n      for (const income of data.incomes) {\r\n        try {\r\n          const { id, ...incomeData } = income;\r\n          incomeData.userId = currentUser.uid; // Ensure correct user ID\r\n          await addDoc(collection(db, 'incomes'), incomeData);\r\n        } catch (e) {\r\n          console.error('Error importing income:', e);\r\n          // Continue with other imports\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error importing data:', error);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  // Get spending insights\r\n  const getSpendingInsights = async (months = 3) => {\r\n    if (!currentUser || months < 1) return null;\r\n    \r\n    try {\r\n      const currentDate = new Date();\r\n      const insights = {\r\n        topCategories: [],\r\n        monthlyTotals: [],\r\n        yearlyComparison: {},\r\n        receiptUsage: {\r\n          total: 0,\r\n          percentage: 0\r\n        }\r\n      };\r\n      \r\n      // Get relevant expenses from Firestore\r\n      const startDate = new Date();\r\n      startDate.setMonth(startDate.getMonth() - months);\r\n      \r\n      // Format for Firestore query\r\n      const startDateString = startDate.toISOString();\r\n      \r\n      const expensesQuery = query(\r\n        collection(db, 'expenses'),\r\n        where('userId', '==', currentUser.uid),\r\n        where('date', '>=', startDateString)\r\n      );\r\n      \r\n      const expensesSnap = await getDocs(expensesQuery);\r\n      \r\n      const relevantExpenses = expensesSnap.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      \r\n      // Calculate top spending categories\r\n      const categoryTotals = {};\r\n      relevantExpenses.forEach(expense => {\r\n        const { category, amount } = expense;\r\n        if (!category) return;\r\n        \r\n        categoryTotals[category] = (categoryTotals[category] || 0) + parseFloat(amount || 0);\r\n      });\r\n      \r\n      insights.topCategories = Object.entries(categoryTotals)\r\n        .map(([category, total]) => ({ category, total }))\r\n        .sort((a, b) => b.total - a.total)\r\n        .slice(0, 5); // Get top 5\r\n      \r\n      // Calculate monthly totals\r\n      const monthlyData = {};\r\n      relevantExpenses.forEach(expense => {\r\n        if (!expense.date) return;\r\n        \r\n        const expenseDate = new Date(expense.date);\r\n        const monthYear = `${expenseDate.getFullYear()}-${expenseDate.getMonth()+1}`;\r\n        \r\n        if (!monthlyData[monthYear]) {\r\n          monthlyData[monthYear] = {\r\n            month: expenseDate.getMonth(),\r\n            year: expenseDate.getFullYear(),\r\n            total: 0,\r\n            label: expenseDate.toLocaleString('default', { month: 'short', year: 'numeric' })\r\n          };\r\n        }\r\n        \r\n        monthlyData[monthYear].total += parseFloat(expense.amount || 0);\r\n      });\r\n      \r\n      insights.monthlyTotals = Object.values(monthlyData)\r\n        .sort((a, b) => {\r\n          if (a.year !== b.year) return a.year - b.year;\r\n          return a.month - b.month;\r\n        });\r\n      \r\n      // Calculate receipt usage statistics\r\n      const receiptsCount = relevantExpenses.filter(expense => expense.fromReceipt).length;\r\n      insights.receiptUsage = {\r\n        total: receiptsCount,\r\n        percentage: relevantExpenses.length > 0 \r\n          ? (receiptsCount / relevantExpenses.length) * 100 \r\n          : 0\r\n      };\r\n      \r\n      return insights;\r\n    } catch (error) {\r\n      console.error('Error generating spending insights:', error);\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  // Load categories and other settings from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setExpenseCategories([]);\r\n      setIncomeCategories([]);\r\n      setBudgets({});\r\n      return;\r\n    }\r\n    \r\n    // Load categories and budgets\r\n    const fetchSettings = async () => {\r\n      try {\r\n        // Get expense categories\r\n        const expenseCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'expenseCategories');\r\n        const expenseCategoriesDoc = await getDoc(expenseCategoriesRef);\r\n        \r\n        if (expenseCategoriesDoc.exists()) {\r\n          setExpenseCategories(expenseCategoriesDoc.data().categories || DEFAULT_EXPENSE_CATEGORIES);\r\n        } else {\r\n          // Create default categories if none exist\r\n          await setDoc(expenseCategoriesRef, {\r\n            categories: DEFAULT_EXPENSE_CATEGORIES\r\n          });\r\n          setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\r\n        }\r\n        \r\n        // Get income categories\r\n        const incomeCategoriesRef = doc(db, 'users', currentUser.uid, 'settings', 'incomeCategories');\r\n        const incomeCategoriesDoc = await getDoc(incomeCategoriesRef);\r\n        \r\n        if (incomeCategoriesDoc.exists()) {\r\n          setIncomeCategories(incomeCategoriesDoc.data().categories || DEFAULT_INCOME_CATEGORIES);\r\n        } else {\r\n          // Create default categories if none exist\r\n          await setDoc(incomeCategoriesRef, {\r\n            categories: DEFAULT_INCOME_CATEGORIES\r\n          });\r\n          setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\r\n        }\r\n        \r\n        // Get budgets\r\n        const budgetsRef = doc(db, 'users', currentUser.uid, 'settings', 'budgets');\r\n        const budgetsDoc = await getDoc(budgetsRef);\r\n        \r\n        if (budgetsDoc.exists()) {\r\n          setBudgets(budgetsDoc.data());\r\n        }\r\n      } catch (error) {\r\n        console.error('Error loading settings:', error);\r\n        setExpenseCategories(DEFAULT_EXPENSE_CATEGORIES);\r\n        setIncomeCategories(DEFAULT_INCOME_CATEGORIES);\r\n      }\r\n    };\r\n    \r\n    fetchSettings();\r\n  }, [currentUser]);\r\n  \r\n  // Load alerts from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setAlerts([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for alerts\r\n    const alertsQuery = query(\r\n      collection(db, 'alerts'),\r\n      where('userId', '==', currentUser.uid),\r\n      where('read', '==', false)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(alertsQuery, (snapshot) => {\r\n      const alertsList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setAlerts(alertsList);\r\n    }, (error) => {\r\n      console.error(\"Error getting alerts:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  // Load receipt scans from Firestore\r\n  useEffect(() => {\r\n    if (!currentUser) {\r\n      setReceiptScans([]);\r\n      return;\r\n    }\r\n    \r\n    // Query Firestore for receipt scans\r\n    const scansQuery = query(\r\n      collection(db, 'receiptScans'),\r\n      where('userId', '==', currentUser.uid)\r\n    );\r\n    \r\n    // Set up real-time listener\r\n    const unsubscribe = onSnapshot(scansQuery, (snapshot) => {\r\n      const scansList = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n      setReceiptScans(scansList);\r\n    }, (error) => {\r\n      console.error(\"Error getting receipt scans:\", error);\r\n    });\r\n    \r\n    return () => unsubscribe();\r\n  }, [currentUser]);\r\n  \r\n  return (\r\n    <ExpenseContext.Provider value={{\r\n      expenses,\r\n      incomes,\r\n      budgets,\r\n      alerts,\r\n      expenseCategories,\r\n      incomeCategories,\r\n      receiptScanStatus,\r\n      receiptScans,\r\n      emailStatus,\r\n      loading,\r\n      addExpense,\r\n      addIncome,\r\n      deleteExpense,\r\n      deleteIncome,\r\n      updateExpense,\r\n      updateIncome,\r\n      updateBudget,\r\n      deleteBudget,\r\n      markAlertAsRead,\r\n      deleteAlert,\r\n      addExpenseCategory,\r\n      deleteExpenseCategory,\r\n      editExpenseCategory,\r\n      addIncomeCategory,\r\n      deleteIncomeCategory,\r\n      editIncomeCategory,\r\n      scanReceipt,\r\n      addExpenseFromReceipt,\r\n      rejectScannedReceipt,\r\n      getMonthlyExpenses,\r\n      getMonthlyIncomes,\r\n      getReceiptScans,\r\n      exportData,\r\n      importData,\r\n      getSpendingInsights\r\n    }}>\r\n      {children}\r\n    </ExpenseContext.Provider>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}